<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Toolchains | BenchmarkDotNet </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Toolchains | BenchmarkDotNet ">
    <meta name="generator" content="docfx 2.57.2.0">
    
    <link rel="shortcut icon" href="../../logo/icon-32.png">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  
    <!-- Google Analytics -->
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  
      ga('create', 'UA-41419012-6', 'auto');
      ga('send', 'pageview');
  
    </script>
    <!-- /Google Analytics -->
    <!-- Yandex.Metrika counter -->
    <script type="text/javascript">
        (function (d, w, c) {
            (w[c] = w[c] || []).push(function() {
                try {
                    w.yaCounter40812449 = new Ya.Metrika({
                        id:40812449,
                        clickmap:true,
                        trackLinks:true,
                        accurateTrackBounce:true
                    });
                } catch(e) { }
            });
  
            var n = d.getElementsByTagName("script")[0],
                s = d.createElement("script"),
                f = function () { n.parentNode.insertBefore(s, n); };
            s.type = "text/javascript";
            s.async = true;
            s.src = "https://mc.yandex.ru/metrika/watch.js";
  
            if (w.opera == "[object Opera]") {
                d.addEventListener("DOMContentLoaded", f, false);
            } else { f(); }
        })(document, window, "yandex_metrika_callbacks");
    </script>
    <noscript><div><img src="https://mc.yandex.ru/watch/40812449" style="position:absolute; left:-9999px;" alt=""></div></noscript>
    <!-- /Yandex.Metrika counter -->
    <!-- at the end of the HEAD -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.css">
    <link rel="stylesheet" href="../../styles/search.css">
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo/icon.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <div class="navbar-right navbar-form">
                <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off" autofocus="">
              </div>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="docs.toolchains">
<h1 id="toolchains">Toolchains</h1>

<p>To achieve process-level isolation, BenchmarkDotNet generates, builds and executes a new console app per every benchmark. A <strong>toolchain</strong> contains generator, builder, and executor.</p>
<p>When you run your benchmarks without specifying the toolchain in an explicit way, the default one is used:</p>
<ul>
<li>Roslyn for Full .NET Framework and Mono</li>
<li>dotnet cli for .NET Core and CoreRT</li>
</ul>
<h2 id="multiple-frameworks-support">Multiple frameworks support</h2>
<p>If you want to test multiple frameworks, your project file <strong>MUST target all of them</strong> and you <strong>MUST install the corresponding SDKs</strong>:</p>
<pre><code class="lang-xml">&lt;TargetFrameworks&gt;netcoreapp3.0;netcoreapp2.1;net48&lt;/TargetFrameworks&gt;
</code></pre>
<p>If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks <strong>using the same framework as the host process</strong>:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1
dotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0
dotnet run -c Release -f net48         # is going to run the benchmarks using .NET 4.8
mono $pathToExe                        # is going to run the benchmarks using Mono from your PATH
</code></pre>
<p>To run the benchmarks for multiple runtimes with a single command, you need to specify the target framework moniker names via <code>--runtimes|-r</code> console argument:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0
dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48         # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8
</code></pre>
<p>What is going to happen if you provide multiple Full .NET Framework monikers? Let's say:</p>
<pre><code class="lang-cmd">dotnet run -c Release -f net461 net472 net48
</code></pre>
<p>Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on target version they were compiled for. You can read more about this <a href="https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/version-compatibility">here</a> and <a href="https://docs.microsoft.com/en-us/dotnet/framework/migration-guide/application-compatibility">here</a>. This is <strong>.NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool</strong>.</p>
<p><strong>Note:</strong> Console arguments support works only if you pass the <code>args</code> to <code>BenchmarkSwitcher</code>:</p>
<pre><code class="lang-cs">class Program
{
    static void Main(string[] args) 
        =&gt; BenchmarkSwitcher
            .FromAssembly(typeof(Program).Assembly)
            .Run(args); // crucial to make it work
}
</code></pre>
<p>You can achieve the same thing using <code>[SimpleJobAttribute]</code>:</p>
<pre><code class="lang-cs">using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Jobs;

namespace BenchmarkDotNet.Samples
{
    [SimpleJob(RuntimeMoniker.Net48)]
    [SimpleJob(RuntimeMoniker.Mono)]
    [SimpleJob(RuntimeMoniker.NetCoreApp21)]
    [SimpleJob(RuntimeMoniker.NetCoreApp30)]
    public class TheClassWithBenchmarks
</code></pre>
<p>Or using a custom config:</p>
<pre><code class="lang-cs">using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;

namespace BenchmarkDotNet.Samples
{
    class Program
    {
        static void Main(string[] args)
        {
            var config = DefaultConfig.Instance
                .With(Job.Default.With(CoreRuntime.Core21))
                .With(Job.Default.With(CoreRuntime.Core30))
                .With(Job.Default.With(ClrRuntime.Net48))
                .With(Job.Default.With(MonoRuntime.Default));

            BenchmarkSwitcher
                .FromAssembly(typeof(Program).Assembly)
                .Run(args, config);
        }
    }
}
</code></pre>
<p>The recommended way of running the benchmarks for multiple runtimes is to use the <code>--runtimes</code> console line argument. By using the console line argument you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark other people can run it even if they don't have the exact same framework version installed.</p>
<h2 id="custom-net-core-runtime">Custom .NET Core Runtime</h2>
<p>We can run your benchmarks for custom <code>&lt;RuntimeFrameworkVersion&gt;</code> if you want. All you need to do is to create custom toolchain by calling <code>CsProjCoreToolchain.From</code> method, which accepts <code>NetCoreAppSettings</code>.</p>
<pre><code class="lang-cs">public class MyConfig : ManualConfig
{
    public MyConfig()
    {
        Add(Job.Default.With(
            CsProjCoreToolchain.From(
                new NetCoreAppSettings(
                    targetFrameworkMoniker: &quot;netcoreapp2.1&quot;, 
                    runtimeFrameworkVersion: &quot;2.1.0-preview2-25628-01&quot;, 
                    name: &quot;.NET Core 2.1&quot;))));
    }
}
</code></pre>
<h2 id="custom-net-runtime">Custom .NET Runtime</h2>
<p>It's possible to benchmark a private build of .NET Runtime. All you need to do is to define a job with the right version of <code>ClrRuntime</code>.</p>
<pre><code class="lang-cs">BenchmarkSwitcher
    .FromAssembly(typeof(Program).Assembly)
    .Run(args, 
        DefaultConfig.Instance.With(
            Job.ShortRun.With(ClrRuntime.CreateForLocalFullNetFrameworkBuild(version: &quot;4.0&quot;))));
</code></pre>
<p>This sends the provided version as a <code>COMPLUS_Version</code> env var to the benchmarked process.</p>
<h2 id="custom-dotnet-cli-path">Custom dotnet cli path</h2>
<p>We internally use dotnet cli to build and run .NET Core executables. Sometimes it might be mandatory to use non-default dotnet cli path. An example scenario could be a comparison of RyuJit 32bit vs 64 bit. It required due this <a href="https://github.com/dotnet/cli/issues/7532">limitation</a> of dotnet cli</p>
<pre><code class="lang-cs">public class CustomPathsConfig : ManualConfig
{
    public CustomPathsConfig() 
    {
        var dotnetCli32bit = NetCoreAppSettings
            .NetCoreApp20
            .WithCustomDotNetCliPath(@&quot;C:\Program Files (x86)\dotnet\dotnet.exe&quot;, &quot;32 bit cli&quot;);

        var dotnetCli64bit = NetCoreAppSettings
            .NetCoreApp20
            .WithCustomDotNetCliPath(@&quot;C:\Program Files\dotnet\dotnet.exe&quot;, &quot;64 bit cli&quot;);

        Add(Job.RyuJitX86.With(CsProjCoreToolchain.From(dotnetCli32bit)).WithId(&quot;32 bit cli&quot;));
        Add(Job.RyuJitX64.With(CsProjCoreToolchain.From(dotnetCli64bit)).WithId(&quot;64 bit cli&quot;));
    }
}
</code></pre>
<pre><code class="lang-ini">BenchmarkDotNet=v0.10.9.20170910-develop, OS=Windows 10 Redstone 1 (10.0.14393)
Processor=Intel Core i7-6600U CPU 2.60GHz (Skylake), ProcessorCount=4
Frequency=2742185 Hz, Resolution=364.6727 ns, Timer=TSC
.NET Core SDK=2.1.0-preview1-007074
  [Host]     : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT
  32 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 32bit RyuJIT
  64 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT

Jit=RyuJit  
</code></pre>
<p>This feature is now also exposed with the <code>--cli</code> console argument.</p>
<p>Example: <code>dotnet run -c Release -- --cli &quot;C:\Projects\machinelearning\Tools\dotnetcli\dotnet.exe&quot;</code></p>
<h2 id="corerun">CoreRun</h2>
<p>To use CoreRun for running the benchmarks you need to use <code>--coreRun </code>command line argument. You can combine it with <code>--cli</code> described above. This is most probably the easiest and most reliable way of running benchmarks against local CoreFX/CoreCLR builds.</p>
<p>Example: <code>dotnet run -c Release -- --coreRun &quot;C:\Projects\corefx\bin\testhost\netcoreapp-Windows_NT-Release-x64\shared\Microsoft.NETCore.App\9.9.9\CoreRun.exe&quot;</code></p>
<hr>
<h2 id="sample-introinprocess">Sample: IntroInProcess</h2>
<p>InProcessEmitToolchain is our toolchain which does not generate any new executable.
It emits IL on the fly and runs it from within the process itself.
It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support.
An example could be a local build of CoreCLR.</p>
<h3 id="usage">Usage</h3>
<pre><code class="lang-cs">[InProcessAttribute]
public class TypeWithBenchmarks
{
}
</code></pre>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroInProcess.cs">using System.Runtime.CompilerServices;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Order;
using BenchmarkDotNet.Toolchains.InProcess.Emit;

namespace BenchmarkDotNet.Samples
{
    [Config(typeof(Config))]
    [Orderer(SummaryOrderPolicy.FastestToSlowest)]
    [MemoryDiagnoser]
    public class IntroInProcess
    {
        private class Config : ManualConfig
        {
            public Config()
            {
                AddJob(Job.MediumRun
                    .WithLaunchCount(1)
                    .WithId(&quot;OutOfProc&quot;));

                AddJob(Job.MediumRun
                    .WithLaunchCount(1)
                    .WithToolchain(InProcessEmitToolchain.Instance)
                    .WithId(&quot;InProcess&quot;));
            }
        }

        [Benchmark(Description = &quot;new byte[10kB]&quot;)]
        public byte[] Allocate()
        {
            return new byte[10000];
        }

        [Benchmark(Description = &quot;stackalloc byte[10kB]&quot;)]
        public unsafe void AllocateWithStackalloc()
        {
            var array = stackalloc byte[10000];
            Consume(array);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static unsafe void Consume(byte* input)
        {
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="toolchains.html">Toolchains</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroInProcess.html">Sample: IntroInProcess</a></li>
</ul>
<hr>
<h2 id="sample-introinprocesswrongenv">Sample: IntroInProcessWrongEnv</h2>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroInProcessWrongEnv.cs">using System;
using System.Runtime.CompilerServices;
using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Order;
using BenchmarkDotNet.Toolchains.InProcess;
using BenchmarkDotNet.Toolchains.InProcess.Emit;

namespace BenchmarkDotNet.Samples
{
    [Config(typeof(Config))]
    [Orderer(SummaryOrderPolicy.FastestToSlowest)]
    [MemoryDiagnoser]
    public class IntroInProcessWrongEnv
    {
        private class Config : ManualConfig
        {
            public Config()
            {
                var wrongPlatform = Environment.Is64BitProcess
                    ? Platform.X64
                    : Platform.X86;

                AddJob(Job.MediumRun
                    .WithLaunchCount(1)
                    .WithPlatform(wrongPlatform)
                    .WithToolchain(InProcessEmitToolchain.Instance)
                    .WithId(&quot;InProcess&quot;));

                AddValidator(InProcessValidator.DontFailOnError);
            }
        }

        [Benchmark(Description = &quot;new byte[10kB]&quot;)]
        public byte[] Allocate()
        {
            return new byte[10000];
        }

        [Benchmark(Description = &quot;stackalloc byte[10kB]&quot;)]
        public unsafe void AllocateWithStackalloc()
        {
            var array = stackalloc byte[10000];
            Consume(array);
        }

        [MethodImpl(MethodImplOptions.NoInlining)]
        private static unsafe void Consume(byte* input)
        {
        }
    }
}
</code></pre><h3 id="output">Output</h3>
<h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="toolchains.html">Toolchains</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroInProcessWrongEnv.html">Sample: IntroInProcessWrongEnv</a></li>
</ul>
<hr>
<h2 id="corert">CoreRT</h2>
<p>BenchmarkDotNet supports <a href="https://github.com/dotnet/runtimelab/tree/feature/NativeAOT">CoreRT</a>! However, you might want to know how it works to get a better understanding of the results that you get.</p>
<ul>
<li>CoreRT is a flavor of .NET Core. Which means that:
<ul>
<li>you have to target .NET Core to be able to build CoreRT benchmarks (example: <code>&lt;TargetFramework&gt;net5.0&lt;/TargetFramework&gt;</code> in the .csproj file)</li>
<li>you have to specify the CoreRT runtime in an explicit way, either by using <code>[SimpleJob]</code> attribute or by using the fluent Job config API <code>Job.ShortRun.With(CoreRtRuntime.$version)</code> or console line arguments <code>--runtimes corert50</code></li>
<li>to run CoreRT benchmark you run the app as a .NET Core/.NET process (example: <code>dotnet run -c Release -f net5.01</code>) and BenchmarkDotNet does all the CoreRT compilation for you. If you want to check what files are generated you need to apply <code>[KeepBenchmarkFiles]</code> attribute to the class which defines benchmarks.</li>
</ul>
</li>
</ul>
<p>By default BenchmarkDotNet uses the latest version of <code>Microsoft.DotNet.ILCompiler</code> to build the CoreRT benchmark according to <a href="https://github.com/dotnet/runtimelab/blob/d0a37893a67c125f9b0cd8671846ff7d867df241/samples/HelloWorld/README.md#add-corert-to-your-project">this instructions</a>.</p>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
    .With(Job.Default.With(CoreRtRuntime.CoreRt50)); // compiles the benchmarks as net5.0 and uses the latest CoreRT to build a native app

BenchmarkSwitcher
    .FromAssembly(typeof(Program).Assembly)
    .Run(args, config);
</code></pre>
<pre><code class="lang-cs">[SimpleJob(RuntimeMoniker.CoreRt50)] // compiles the benchmarks as net5.0 and uses the latest CoreRT to build a native app
public class TheTypeWithBenchmarks
{
   [Benchmark] // the benchmarks go here
}
</code></pre>
<p><strong>Note</strong>: BenchmarkDotNet is going to run <code>dotnet restore</code> on the auto-generated project. The first time it does so, it's going to take a <strong>LOT</strong> of time to download all the dependencies (few minutes). Just give it some time and don't press <code>Ctrl+C</code> too fast ;)</p>
<p>If you want to benchmark some particular version of CoreRT (or from a different NuGet feed) you have to specify it in an explicit way:</p>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
    .With(Job.ShortRun
        .With(CoreRtToolchain.CreateBuilder()
            .UseCoreRtNuGet(
                microsoftDotNetILCompilerVersion: &quot;6.0.0-*&quot;, // the version goes here
                nuGetFeedUrl: &quot;https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json&quot;) // this address might change over time
            .DisplayName(&quot;CoreRT NuGet&quot;)
            .TargetFrameworkMoniker(&quot;net5.0&quot;)
            .ToToolchain()));
</code></pre>
<h3 id="compiling-source-to-native-code-using-the-ilcompiler-you-built">Compiling source to native code using the ILCompiler you built</h3>
<p>If you are an CoreRT contributor and you want to benchmark your local build of CoreRT you have to provide necessary info (IlcPath):</p>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
    .With(Job.ShortRun
        .With(CoreRtToolchain.CreateBuilder()
            .UseCoreRtLocal(@&quot;C:\Projects\corert\bin\Windows_NT.x64.Release&quot;) // IlcPath
            .DisplayName(&quot;Core RT RyuJit&quot;)
            .TargetFrameworkMoniker(&quot;netcoreapp2.1&quot;)
            .ToToolchain()));
</code></pre>
<p>BenchmarkDotNet is going to follow <a href="https://github.com/dotnet/corert/blob/7f902d4d8b1c3280e60f5e06c71951a60da173fb/Documentation/how-to-build-and-run-ilcompiler-in-console-shell-prompt.md#compiling-source-to-native-code-using-the-ilcompiler-you-built">these instructrions</a> to get it working for you.</p>
<h3 id="using-cpp-code-generator">Using CPP Code Generator</h3>
<blockquote>
<p>This approach uses transpiler to convert IL to C++, and then uses platform specific C++ compiler and linker for compiling/linking the application. The transpiler is a lot less mature than the RyuJIT path. If you came here to give CoreRT a try on your .NET Core program, use the RyuJIT option above.</p>
</blockquote>
<p>If you want to test <a href="https://github.com/dotnet/corert/blob/7f902d4d8b1c3280e60f5e06c71951a60da173fb/Documentation/how-to-build-and-run-ilcompiler-in-console-shell-prompt.md#using-cpp-code-generator">CPP Code Generator</a> you have to use <code>UseCppCodeGenerator</code> method:</p>
<pre><code class="lang-cs">var config = DefaultConfig.Instance
    .With(Job.Default
        .With(
            CoreRtToolchain.CreateBuilder()
                .UseCoreRtLocal(@&quot;C:\Projects\corert\bin\Windows_NT.x64.Release&quot;) // IlcPath
                .UseCppCodeGenerator() // ENABLE IT
                .TargetFrameworkMoniker(&quot;netcoreapp2.1&quot;)
                .DisplayName(&quot;CPP&quot;)
                .ToToolchain()));
</code></pre>
<p><strong>Note</strong>: You might get some <code>The method or operation is not implemented.</code> errors as of today if the code that you are trying to benchmark is using some features that are not implemented by CoreRT/transpiler yet...</p>
<h2 id="wasm">Wasm</h2>
<p>BenchmarkDotNet supports Web Assembly on Unix! However, currently you need to build the <strong>dotnet runtime</strong> yourself to be able to run the benchmarks.</p>
<p>For up-to-date docs, you should visit <a href="https://github.com/dotnet/runtime/blob/master/docs/workflow/testing/libraries/testing-wasm.md">dotnet/runtime repository</a>.</p>
<p>The docs below are specific to Ubuntu 18.04 at the moment of writing this document (16/07/2020).</p>
<p>Firs of all, you need to install.... <strong>npm</strong> 10+:</p>
<pre><code class="lang-cmd">curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash -
sudo apt install nodejs
</code></pre>
<p>After this, you need to install <a href="https://github.com/GoogleChromeLabs/jsvu">jsvu</a>:</p>
<pre><code class="lang-cmd">npm install jsvu -g
</code></pre>
<p>Add it to PATH:</p>
<pre><code class="lang-cmd">export PATH=&quot;${HOME}/.jsvu:${PATH}&quot;
</code></pre>
<p>And use it to install V8, JavaScriptCore and SpiderMonkey:</p>
<pre><code class="lang-cmd">jsvu --os=linux64 --engines=javascriptcore,spidermonkey,v8
</code></pre>
<p>Now you need to install <a href="https://emscripten.org/docs/getting_started/downloads.html#installation-instructions">Emscripten</a>:</p>
<pre><code class="lang-cmd">git clone https://github.com/emscripten-core/emsdk.git
cd emsdk
./emsdk install latest
./emsdk activate latest
source ./emsdk_env.sh
</code></pre>
<p>The last thing before cloning dotnet/runtime repository is creation of <code>EMSDK_PATH</code> env var used by Mono build scripts:</p>
<pre><code class="lang-cmd">export EMSDK_PATH=$EMSDK
</code></pre>
<p>Now you need to clone dotnet/runtime repository:</p>
<pre><code class="lang-cmd">git clone https://github.com/dotnet/runtime
cd runtime
</code></pre>
<p>Install <a href="https://github.com/dotnet/runtime/blob/master/docs/workflow/testing/libraries/testing-wasm.md">all Mono prerequisites</a>:</p>
<pre><code class="lang-cmd">sudo apt-get install cmake llvm-9 clang-9 autoconf automake libtool build-essential python curl git lldb-6.0 liblldb-6.0-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libssl-dev libnuma-dev libkrb5-dev zlib1g-dev
</code></pre>
<p>And FINALLY build Mono Runtime with Web Assembly support:</p>
<pre><code class="lang-cmd">./build.sh --arch wasm --os Browser -c release
</code></pre>
<p>Before you run the benchmarks, you need to make sure that following two file exists:</p>
<pre><code class="lang-cmd">runtime/src/mono/wasm/runtime-test.js
runtime/build.sh
</code></pre>
<p>And that you have .NET 5 feed added to your <code>nuget.config</code> file:</p>
<pre><code class="lang-xml">&lt;add key=&quot;dotnet5&quot; value=&quot;https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json&quot; /&gt;
</code></pre>
<p>Now you should be able to run the Wasm benchmarks!</p>
<h2 id="sample-introwasm">Sample: IntroWasm</h2>
<p>WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine.</p>
<h3 id="source-code">Source code</h3>
<pre><code class="lang-csharp" name="IntroInProcess.cs">using BenchmarkDotNet.Attributes;
using BenchmarkDotNet.Configs;
using BenchmarkDotNet.Environments;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Running;
using System.IO;
using BenchmarkDotNet.Toolchains;
using BenchmarkDotNet.Toolchains.DotNetCli;
using BenchmarkDotNet.Toolchains.MonoWasm;

namespace BenchmarkDotNet.Samples
{
    // *** Command Line Arguments ***
    public class IntroWasmCmdConfig
    {
        // the args must contain:
        // an information that we want to run benchmark as Wasm:
        // --runtimes Wasm
        // path to dotnet cli
        // --cli /home/adam/projects/runtime/dotnet.sh
        // path to main js:
        // --wasmMainJs /home/adam/projects/runtime/src/mono/wasm/runtime-test.js
        public static void Run(string[] args) =&gt; BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args);

        [Benchmark]
        public void Foo()
        {
            // Benchmark body
        }
    }

    // *** Fluent Config ***
    public class IntroWasmFluentConfig
    {
        public static void Run()
        {
            // the Wasm Toolchain requires two mandatory arguments:
            const string mainJsPath = @&quot;/home/adam/projects/runtime/src/mono/wasm/runtime-test.js&quot;;
            const string cliPath = @&quot;/home/adam/projects/runtime/dotnet.sh&quot;;

            WasmRuntime runtime = new WasmRuntime(mainJs: new FileInfo(mainJsPath), msBuildMoniker: &quot;net5.0&quot;);
            NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings(
                targetFrameworkMoniker: &quot;net5.0&quot;, runtimeFrameworkVersion: null, name: &quot;Wasm&quot;,
                customDotNetCliPath: cliPath);
            IToolchain toolChain = WasmToolChain.From(netCoreAppSettings);

            BenchmarkRunner.Run&lt;IntroCustomMonoFluentConfig&gt;(DefaultConfig.Instance
                .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain)));
        }

        [Benchmark]
        public void Foo()
        {
            // Benchmark body
        }
    }
}
</code></pre><h3 id="links">Links</h3>
<ul>
<li><a class="xref" href="toolchains.html">Toolchains</a></li>
<li>The permanent link to this sample: <a class="xref" href="../samples/IntroWasm.html">Sample: IntroWasm</a></li>
</ul>
<hr>
<h2 id="monoaotllvm">MonoAotLLVM</h2>
<p>BenchmarkDotNet supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses llvm on the back end).</p>
<p>Using this tool chain requires the following flags:</p>
<pre><code>--runtimes monoaotllvm
--aotcompilerpath &lt;path to mono aot compiler&gt;
--customruntimepack &lt;path to runtime pack&gt;
</code></pre>
<p>and optionally (defaults to mini)</p>
<pre><code>--aotcompilermode &lt;mini|llvm&gt;  
</code></pre>
<p>As of this writing, the mono aot compiler is not available as a seperate download or nuget package. Therefore, it is required to build the compiler in the [dotnet/runtime repository].</p>
<p>The compiler binary (mono-sgen) is built as part of the <code>mono</code> subset, so it can be built (along with the runtime pack) like so (in the root of [dotnet/runtime]).</p>
<p><code>./build.sh -subset mono+libs -c Release</code></p>
<p>The compiler binary should be generated here (modify for your platform):</p>
<pre><code>&lt;runtime root&gt;/artifacts/obj/mono/OSX.x64.Release/mono/mini/mono-sgen
</code></pre>
<p>And the runtime pack should be generated here:</p>
<pre><code>&lt;runtimeroot&gt;artifacts/bin/microsoft.netcore.app.runtime.osx-x64/Release/
</code></pre>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                  <li>
                    <a href="https://github.com/dotnet/BenchmarkDotNet/blob/master/docs/articles/configs/toolchains.md/#L1" class="contribution-link">Improve this Doc</a>
                  </li>
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Copyright &copy; 2013–2021 .NET Foundation and contributors
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
    <!-- at the end of the BODY -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/docsearch.js@2/dist/cdn/docsearch.min.js"></script>
    <script type="text/javascript">
        docsearch({
            apiKey: 'c56d6c558557cfa1fd103a049363cf8b',
            indexName: 'benchmarkdotnet',
            inputSelector: '#search-query',
            debug: false // Set debug to true if you want to inspect the dropdown
        });
    </script>  </body>
</html>
