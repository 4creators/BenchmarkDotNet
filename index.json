{
  "api/index.html": {
    "href": "api/index.html",
    "title": "BenchmarkDotNet API Reference | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet API Reference"
  },
  "articles/configs/analysers.html": {
    "href": "articles/configs/analysers.html",
    "title": "Analysers | BenchmarkDotNet",
    "keywords": "Analysers An analyser can analyse summary of your benchmarks and produce some useful warnings. For example, EnvironmentAnalyser warns you, if you build your application in the DEBUG mode or run it with an attached debugger."
  },
  "articles/configs/columns.html": {
    "href": "articles/configs/columns.html",
    "title": "Columns | BenchmarkDotNet",
    "keywords": "Columns A column is a column in the summary table. Default columns In this section, default columns (which be added to the Summary table by default) are presented. Some of columns are optional, i.e. they can be omitted (it depends on the measurements from the summary). Target There are 3 default columns which describes the target benchmark: Namespace , Type , Method . Namespace and Type will be omitted when all the benchmarks have the same namespace or type name. Method column always be a part of the summary table. Job There are many different job characteristics, but the summary includes only characteristics which has at least one non-default value. Statistics There are also a lot of different statistics which can be considered. It will be really hard to analyse the summary table, if all of the available statistics will be shown. Fortunately, BenchmarkDotNet has some heuristics for statistics columns and shows only important columns. For example, if all of the standard deviations are zero (we run our benchmarks against Dry job), this column will be omitted. The standard error will be shown only for cases when we are failed to achieve required accuracy level. Only Mean will be always shown. If the distribution looks strange, BenchmarkDotNet could also print additional columns like Median or P95 (95th percentile). If you need specific statistics, you always could add them manually. Params If you have params , the corresponded columns will be automatically added. Diagnosers If you turned on diagnosers which providers additional columns, they will be also included in the summary page. Custom columns Of course, you can define own custom columns and use it everywhere. Here is the definition of TagColumn : using System; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Columns { public class TagColumn : IColumn { private readonly Func<string, string> getTag; public string Id { get; } public string ColumnName { get; } public TagColumn(string columnName, Func<string, string> getTag) { this.getTag = getTag; ColumnName = columnName; Id = nameof(TagColumn) + \".\" + ColumnName; } public bool IsDefault(Summary summary, BenchmarkCase benchmarkCase) => false; public string GetValue(Summary summary, BenchmarkCase benchmarkCase) => getTag(benchmarkCase.Descriptor.WorkloadMethod.Name); public bool IsAvailable(Summary summary) => true; public bool AlwaysShow => true; public ColumnCategory Category => ColumnCategory.Custom; public int PriorityInCategory => 0; public bool IsNumeric => false; public UnitType UnitType => UnitType.Dimensionless; public string Legend => $\"Custom '{ColumnName}' tag column\"; public string GetValue(Summary summary, BenchmarkCase benchmarkCase, SummaryStyle style) => GetValue(summary, benchmarkCase); public override string ToString() => ColumnName; } } Sample: IntroTagColumn In the following example, we introduce two new columns which contains a tag based on a benchmark method name. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { // You can add custom tags per each method using Columns [Config(typeof(Config))] public class IntroTagColumn { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddColumn(new TagColumn(\"Kind\", name => name.Substring(0, 3))); AddColumn(new TagColumn(\"Number\", name => name.Substring(3))); } } [Benchmark] public void Foo1() => Thread.Sleep(10); [Benchmark] public void Foo12() => Thread.Sleep(10); [Benchmark] public void Bar3() => Thread.Sleep(10); [Benchmark] public void Bar34() => Thread.Sleep(10); } } Output | Method | Mean | Kind | Number | | ------ | ---------- | ---- | ------ | | Bar34 | 10.3636 ms | Bar | 34 | | Bar3 | 10.4662 ms | Bar | 3 | | Foo12 | 10.1377 ms | Foo | 12 | | Foo1 | 10.2814 ms | Foo | 1 | Links Columns The permanent link to this sample: Sample: IntroTagColumn"
  },
  "articles/configs/configoptions.html": {
    "href": "articles/configs/configoptions.html",
    "title": "Config Options | BenchmarkDotNet",
    "keywords": "Config Options The config options let you customize some behavior of BenchmarkDotNet - mainly regarding the output. Available config options are: ConfigOptions.Default - No configuration option is set - this is the default. ConfigOptions.KeepBenchmarkFiles - All auto-generated files should be kept after running the benchmarks (by default they are removed). ConfigOptions.JoinSummary - All benchmarks results should be joined into a single summary (by default we have a summary per type). ConfigOptions.StopOnFirstError - Benchmarking should be stopped after the first error (by default it's not). ConfigOptions.DisableOptimizationsValidator - Mandatory optimizations validator should be entirely turned off. ConfigOptions.DontOverwriteResults - The exported result files should not be overwritten (by default they are overwritten). ConfigOptions.DisableLogFile - Disables the log file written on disk. All of these options could be combined and are available as CLI (Comand Line Interface) option (except DisableOptimizationsValidator ), see Console Arguments for further information how to use the CLI. Any of these options could be used either in object style config or fluent style config : Object style config public class Config : ManualConfig { public Config() { // Using the WithOptions() factory method: this.WithOptions(ConfigOptions.JoinSummary) .WithOptions(ConfigOptions.DisableLogFile); // Or (The ConfigOptions Enum is defined as a BitField) this.WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile); } } Fluent style config public static void Run() { BenchmarkRunner .Run<Benchmarks>( ManualConfig .Create(DefaultConfig.Instance) .WithOptions(ConfigOptions.JoinSummary) .WithOptions(ConfigOptions.DisableLogFile) // or .WithOptions(ConfigOptions.JoinSummary | ConfigOptions.DisableLogFile)); }"
  },
  "articles/configs/configs.html": {
    "href": "articles/configs/configs.html",
    "title": "Configs | BenchmarkDotNet",
    "keywords": "Configs Config is a set of so called jobs , columns , exporters , loggers , diagnosers , analysers , validators that help you to build your benchmark. Built-in configuration There are two built-in ways to set your config: Object style [Config(typeof(Config))] public class MyClassWithBenchmarks { private class Config : ManualConfig { public Config() { AddJob(new Job1(), new Job2()); AddColumn(new Column1(), new Column2()); AddColumnProvider(new ColumnProvider1(), new ColumnProvider2()); AddExporter(new Exporter1(), new Exporter2()); AddLogger(new Logger1(), new Logger2()); AddDiagnoser(new Diagnoser1(), new Diagnoser2()); AddAnalyser(new Analyser1(), new Analyser2()); AddValidator(new Validator2(),new Validator2()); AddHardwareCounters(HardwareCounter enum1, HardwareCounter enum2); AddFilter(new Filter1(), new Filter2()); AddLogicalGroupRules(BenchmarkLogicalGroupRule enum1, BenchmarkLogicalGroupRule enum2); } } [Benchmark] public void Benchmark1() { } [Benchmark] public void Benchmark2() { } } Sample: IntroConfigSource You can define own config attribute. Source code using System; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MyConfigSource(Jit.LegacyJit, Jit.RyuJit)] public class IntroConfigSource { /// <summary> /// Dry-x64 jobs for specific jits /// </summary> private class MyConfigSourceAttribute : Attribute, IConfigSource { public IConfig Config { get; } public MyConfigSourceAttribute(params Jit[] jits) { var jobs = jits .Select(jit => new Job(Job.Dry) { Environment = { Jit = jit, Platform = Platform.X64 } }) .ToArray(); Config = ManualConfig.CreateEmpty().AddJob(jobs); } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: Sample: IntroConfigSource Sample: IntroConfigUnion Source code using System.Threading; using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Exporters.Csv; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Loggers; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroConfigUnion { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddLogger(ConsoleLogger.Default); AddColumn(TargetMethodColumn.Method, StatisticColumn.Max); AddExporter(RPlotExporter.Default, CsvExporter.Default); AddAnalyser(EnvironmentAnalyser.Default); UnionRule = ConfigUnionRule.AlwaysUseLocal; } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: Sample: IntroConfigUnion Sample: IntroFluentConfigBuilder There is no need to create new Config type, you can simply use fluent interface. Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Validators; namespace BenchmarkDotNet.Samples { public class Algo_Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public Algo_Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } public class IntroFluentConfigBuilder { public static void Run() { BenchmarkRunner .Run<Algo_Md5VsSha256>( DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(ClrRuntime.Net461)) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core21)) .AddValidator(ExecutionValidator.FailOnError)); } } } Links Configs The permanent link to this sample: Sample: IntroFluentConfigBuilder"
  },
  "articles/configs/diagnosers.html": {
    "href": "articles/configs/diagnosers.html",
    "title": "Diagnosers | BenchmarkDotNet",
    "keywords": "Diagnosers A diagnoser can attach to your benchmark and get some useful info. The current Diagnosers are: GC and Memory Allocation ( MemoryDiagnoser ) which is cross platform, built-in and is not enabled by default anymore . Please see Adam Sitnik's blog post for all the details. JIT Inlining Events ( InliningDiagnoser ). You can find this diagnoser in a separate package with diagnosers for Windows ( BenchmarkDotNet.Diagnostics.Windows ): JIT Tail Call Events ( TailCallDiagnoser ). You can find this diagnoser as well as the ( InliningDiagnoser ) in a separate package with diagnosers for Windows ( BenchmarkDotNet.Diagnostics.Windows ): Please see this post for all the details. Hardware Counter Diagnoser. You can find this diagnoser in a separate package with diagnosers for Windows ( BenchmarkDotNet.Diagnostics.Windows ): . Please see Adam Sitnik's blog post for all the details. Disassembly Diagnoser. It allows you to disassemble the benchmarked code to asm, IL and C#/F#. Please see Adam Sitnik's blog post for all the details. ETW Profiler ( EtwProfiler ). It allows you to not only benchmark, but also profile the code. It's using TraceEvent, which internally uses ETW and exports all the information to a trace file. The trace file contains all of the stack traces captured by the profiler, PDBs to resolve symbols for both native and managed code and captured GC, JIT and CLR events. Please use one of the free tools: PerfView or Windows Performance Analyzer to analyze and visualize the data from trace file. You can find this diagnoser in a separate package with diagnosers for Windows ( BenchmarkDotNet.Diagnostics.Windows ): Please see Adam Sitnik's blog post for all the details. Concurrency Visualizer Profiler ( ConcurrencyVisualizerProfiler ) It uses EtwProfiler to profile the code using ETW and create not only .etl file but also a CVTrace file which can be opened by Concurrency Visualizer plugin from Visual Studio. Please see Adam Sitnik's blog post for all the details. Native Memory Profiler ( NativeMemoryProfiler ) It uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak . Please see Wojciech Nagórski's blog post for all the details. Event Pipe Profiler ( EventPipeProfiler ). It is a cross-platform profiler that allows profile .NET code on every platform - Windows, Linux, macOS. Please see Wojciech Nagórski's blog post for all the details. Threading Diagnoser ( ThreadingDiagnoser ) - .NET Core 3.0+ diagnoser that reports some Threading statistics. Usage Below is a sample output from the GC and Memory Allocation diagnoser, note the extra columns on the right-hand side (\"Gen 0\", \"Gen 1\", \"Gen 2\" and \"Allocated\"): Method | Mean | StdErr | Median | Gen 0 | Allocated | ----------------- |------------ |----------- |------------ |------- |---------- | 'new byte[10kB]' | 884.4896 ns | 46.3528 ns | 776.4237 ns | 0.1183 | 10 kB | A config example: private class Config : ManualConfig { public Config() { Add(MemoryDiagnoser.Default); Add(new InliningDiagnoser()); Add(new EtwProfiler()); Add(ThreadingDiagnoser.Default); } } You can also use one of the following attributes (apply it on a class that contains Benchmarks): [MemoryDiagnoser] [InliningDiagnoser] [TailCallDiagnoser] [EtwProfiler] [ConcurrencyVisualizerProfiler] [NativeMemoryProfiler] [ThreadingDiagnoser] In BenchmarkDotNet, 1kB = 1024B, 1MB = 1024kB, and so on. The column Gen X means number of GC collections per 1000 operations for that generation. Restrictions In order to not affect main results we perform a separate run if any diagnoser is used. That's why it might take more time to execute benchmarks. MemoryDiagnoser: Mono currently does not expose any api to get the number of allocated bytes. That's why our Mono users will get ? in Allocated column. In order to get the number of allocated bytes in cross platform way we are using GC.GetAllocatedBytesForCurrentThread which recently got exposed for netcoreapp1.1. That's why BenchmarkDotNet does not support netcoreapp1.0 from version 0.10.1. MemoryDiagnoser is 99.5% accurate about allocated memory when using default settings or Job.ShortRun (or any longer job than it). Threading Diagnoser: Works only for .NET Core 3.0+ HardwareCounters: Windows 8+ only (we plan to add Unix support in the future) No Hyper-V (Virtualization) support Requires running as Admin (ETW Kernel Session) No InProcessToolchain support ( #394 ) EtwProfiler, ConcurrencyVisualizerProfiler and NativeMemoryProfiler: Windows only Requires running as Admin (ETW Kernel Session) No InProcessToolchain support ( #394 ) Disassembly Diagnoser: .NET Core disassembler works only on Windows Mono disassembler does not support recursive disassembling and produces output without IL and C#. Indirect calls are not tracked. To be able to compare different platforms, you need to target AnyCPU <PlatformTarget>AnyCPU</PlatformTarget> To get the corresponding C#/F# code from disassembler you need to configure your project in following way: <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> Sample: IntroHardwareCounters This diagnoser is not enabled in explicit way as the other diagnosers. You need to specify [HardwareCounters] and we choose the right diagnoser in the runtime. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [HardwareCounters( HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)] public class IntroHardwareCounters { private const int N = 32767; private readonly int[] sorted, unsorted; public IntroHardwareCounters() { var random = new Random(0); unsorted = new int[N]; sorted = new int[N]; for (int i = 0; i < N; i++) sorted[i] = unsorted[i] = random.Next(256); Array.Sort(sorted); } private static int Branch(int[] data) { int sum = 0; for (int i = 0; i < N; i++) if (data[i] >= 128) sum += data[i]; return sum; } private static int Branchless(int[] data) { int sum = 0; for (int i = 0; i < N; i++) { int t = (data[i] - 128) >> 31; sum += ~t & data[i]; } return sum; } [Benchmark] public int SortedBranch() => Branch(sorted); [Benchmark] public int UnsortedBranch() => Branch(unsorted); [Benchmark] public int SortedBranchless() => Branchless(sorted); [Benchmark] public int UnsortedBranchless() => Branchless(unsorted); } } Output Method Mean Mispredict rate BranchInstructions/Op BranchMispredictions/Op SortedBranch 21.4539 us 0,04% 70121 24 UnsortedBranch 136.1139 us 23,70% 68788 16301 SortedBranchless 28.6705 us 0,06% 35711 22 UnsortedBranchless 28.9336 us 0,05% 35578 17 Links Diagnosers The permanent link to this sample: Sample: IntroHardwareCounters Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyRyuJit Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassembly Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU . <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net461)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net461)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net461)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here . The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyAllJits Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once . Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyDry Sample: IntroTailcall You need to use the TailcallDiagnoser attribute to configure it. The available options are: logFailuresOnly: Track only the methods that failed to get tail called. True by default. filterByNamespace : Track only the methods from declaring type's namespace. Set to false if you want to see all Jit tail events. True by default. Restrictions Windows only x64 Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.TailCallDiagnoser] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] public class IntroTailcall { [Benchmark] public long Calc() => FactorialWithoutTailing(7) - FactorialWithTailing(7); private static long FactorialWithoutTailing(int depth) => depth == 0 ? 1 : depth * FactorialWithoutTailing(depth - 1); private static long FactorialWithTailing(int pos, int depth) => pos == 0 ? depth : FactorialWithTailing(pos - 1, depth * pos); private static long FactorialWithTailing(int depth) => FactorialWithTailing(depth - 1, depth); } } Output // * Diagnostic Output - TailCallDiagnoser * -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64) -------------------- Caller: <null>.<null> - <null> Callee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64 (int32,int32) Tail prefix: False Tail call type: RecursiveLoop ------------------- Links Diagnosers The permanent link to this sample: Sample: IntroTailcall Sample: IntroNativeMemory The NativeMemoryProfiler uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak to the benchmark results table. Source code using System; using System.Drawing; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.Windows.Configs; namespace BenchmarkDotNet.Samples { [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } } Output Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B Profiling memory leaks The BenchmarkDotNet repeats benchmarking function many times. Sometimes it can cause a memory overflow. In this case, the BenchmarkDotNet shows the message: OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. In this case, you should try to reduce the number of invocation, by adding [ShortRunJob] attribute or using Job.Short for custom configuration. Links Diagnosers The permanent link to this sample: Sample: IntroNativeMemory Sample: IntroThreadingDiagnoser The ThreadingDiagnoser uses new APIs exposed in .NET Core 3.0 to report: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [ThreadingDiagnoser] // ENABLE the diagnoser public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } } Output Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - Links Diagnosers The permanent link to this sample: Sample: IntroThreadingDiagnoser"
  },
  "articles/configs/exporters.html": {
    "href": "articles/configs/exporters.html",
    "title": "Exporters | BenchmarkDotNet",
    "keywords": "Exporters An exporter allows you to export results of your benchmark in different formats. By default, files with results will be located in .\\BenchmarkDotNet.Artifacts\\results directory. Default exporters are: csv, html and markdown. Sample: IntroExport BenchmarkDotNet has a lot of predefined exporters. Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [ShortRunJob] [MediumRunJob] [KeepBenchmarkFiles] [AsciiDocExporter] [CsvExporter] [CsvMeasurementsExporter] [HtmlExporter] [PlainExporter] [RPlotExporter] [JsonExporterAttribute.Brief] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.Full] [JsonExporterAttribute.FullCompressed] [MarkdownExporterAttribute.Default] [MarkdownExporterAttribute.GitHub] [MarkdownExporterAttribute.StackOverflow] [MarkdownExporterAttribute.Atlassian] [XmlExporterAttribute.Brief] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.Full] [XmlExporterAttribute.FullCompressed] public class IntroExport { private Random random = new Random(42); [Benchmark(Baseline = true)] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep50Noisy() => Thread.Sleep(random.Next(100)); } } Links Exporters The permanent link to this sample: Sample: IntroExport Sample: IntroExportJson BenchmarkDotNet has a set of json exporters. You can customize the following properties of these exporters: fileNameSuffix : a string which be placed in the end of target file name. indentJson = false / true : should we format json or not. excludeMeasurements = false / true : should we exclude detailed information about measurements or not (the final summary with statistics will be in the json file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters.Json; namespace BenchmarkDotNet.Samples { // *** Attribute style *** [DryJob] [JsonExporterAttribute.Brief] [JsonExporterAttribute.Full] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.FullCompressed] [JsonExporter(\"-custom\", indentJson: true, excludeMeasurements: true)] public class IntroExportJson { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } // *** Object style *** [Config(typeof(Config))] public class IntroJsonExportObjectStyle { private class Config : ManualConfig { public Config() { AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Full); AddExporter(JsonExporter.BriefCompressed); AddExporter(JsonExporter.FullCompressed); AddExporter(JsonExporter.Custom(\"-custom\", indentJson: true, excludeMeasurements: true)); } } [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroJsonExport-report-brief.json : { \"Title\":\"IntroJsonExport\", \"HostEnvironmentInfo\":{ \"BenchmarkDotNetCaption\":\"BenchmarkDotNet-Dev.Core\", \"BenchmarkDotNetVersion\":\"0.9.9.0\", \"OsVersion\":\"Microsoft Windows NT 6.2.9200.0\", \"ProcessorName\":{ \"IsValueCreated\":true, \"Value\":\"Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz\" }, \"ProcessorCount\":8, \"ClrVersion\":\"MS.NET 4.0.30319.42000\", \"Architecture\":\"64-bit\", \"HasAttachedDebugger\":false, \"HasRyuJit\":true, \"Configuration\":\"RELEASE\", \"JitModules\":\"clrjit-v4.6.1586.0\", \"DotNetCliVersion\":\"1.0.0-preview2-003121\", \"ChronometerFrequency\":2143474, \"HardwareTimerKind\":\"Tsc\" }, \"Benchmarks\":[ { \"ShortInfo\":\"IntroJsonExport_Sleep10\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep10\", \"MethodTitle\":\"Sleep10\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"TargetCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":10265993.7209375, \"LowerFence\":10255329.082734371, \"Q1\":10337369.528437499, \"Median\":10360382.6953125, \"Mean\":10362283.085796878, \"Q3\":10392063.158906251, \"UpperFence\":10474103.60460938, \"Max\":10436008.3209375, \"InterquartileRange\":54693.630468752235, \"Outliers\":[ ], \"StandardError\":10219.304338928456, \"Variance\":2088683623.4328396, \"StandardDeviation\":45702.118369205156, \"Skewness\":-0.1242777170069375, \"Kurtosis\":2.31980277935226, \"ConfidenceInterval\":{ \"Mean\":10362283.085796878, \"Error\":10219.304338928456, \"Level\":6, \"Margin\":20029.836504299772, \"Lower\":10342253.249292579, \"Upper\":10382312.922301177 }, \"Percentiles\":{ \"P0\":10265993.7209375, \"P25\":10338555.905625, \"P50\":10360382.6953125, \"P67\":10373496.555659376, \"P80\":10400703.4841875, \"P85\":10417280.326718749, \"P90\":10424125.595812501, \"P95\":10435620.51609375, \"P100\":10436008.3209375 } } },{ \"ShortInfo\":\"IntroJsonExport_Sleep20\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep20\", \"MethodTitle\":\"Sleep20\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"TargetCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":20258672.37, \"LowerFence\":20206333.269843742, \"Q1\":20325342.761249997, \"Median\":20362636.192500003, \"Mean\":20360791.931687497, \"Q3\":20404682.4221875, \"UpperFence\":20523691.913593754, \"Max\":20422396.073125, \"InterquartileRange\":79339.66093750298, \"Outliers\":[ ], \"StandardError\":10728.817907277158, \"Variance\":2302150673.7502208, \"StandardDeviation\":47980.732317777525, \"Skewness\":-0.50826238372439869, \"Kurtosis\":2.11050327966268, \"ConfidenceInterval\":{ \"Mean\":20360791.931687497, \"Error\":10728.817907277158, \"Level\":6, \"Margin\":21028.48309826323, \"Lower\":20339763.448589232, \"Upper\":20381820.414785761 }, \"Percentiles\":{ \"P0\":20258672.37, \"P25\":20327638.975312497, \"P50\":20362636.192500003, \"P67\":20391669.3762875, \"P80\":20406370.68625, \"P85\":20412542.034406248, \"P90\":20414412.5376875, \"P95\":20416606.697718751, \"P100\":20422396.073125 } } } ] } Links Exporters The permanent link to this sample: Sample: IntroExportJson Sample: IntroExportXml BenchmarkDotNet has a set of XML exporters. You can customize the following properties of these exporters: fileNameSuffix : a string which be placed in the end of target file name. indentXml = false / true : should we format xml or not. excludeMeasurements = false / true : should we exclude detailed information about measurements or not (the final summary with statistics will be in the XML file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [XmlExporterAttribute.Brief] [XmlExporterAttribute.Full] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.FullCompressed] [XmlExporter(\"-custom\", indentXml: true, excludeMeasurements: true)] public class IntroExportXml { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroXmlExport-report-brief.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <Summary> <Title>IntroXmlExport</Title> <HostEnvironmentInfo> <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption> <BenchmarkDotNetVersion>0.10.9.20170805-develop</BenchmarkDotNetVersion> <OsVersion>Windows 10 Redstone 2 (10.0.15063)</OsVersion> <ProcessorName>Intel Core i7-3770K CPU 3.50GHz (Ivy Bridge)</ProcessorName> <ProcessorCount>8</ProcessorCount> <RuntimeVersion>.NET Framework 4.7 (CLR 4.0.30319.42000)</RuntimeVersion> <Architecture>64bit</Architecture> <HasAttachedDebugger>False</HasAttachedDebugger> <HasRyuJit>True</HasRyuJit> <Configuration>RELEASE</Configuration> <JitModules>clrjit-v4.7.2101.1</JitModules> <DotNetSdkVersion>1.0.4</DotNetSdkVersion> <ChronometerFrequency> <Hertz>3410220</Hertz> </ChronometerFrequency> <HardwareTimerKind>Tsc</HardwareTimerKind> </HostEnvironmentInfo> <Benchmarks> <Benchmark> <DisplayInfo>IntroXmlExport.Sleep10: DefaultJob</DisplayInfo> <Namespace>BenchmarkDotNet.Samples.Intro</Namespace> <Type>IntroXmlExport</Type> <Method>Sleep10</Method> <MethodTitle>Sleep10</MethodTitle> <Statistics> <N>15</N> <Min>10989865.8785938</Min> <LowerFence>10989836.0967969</LowerFence> <Q1>10990942.6053125</Q1> <Median>10991249.5870313</Median> <Mean>10991270.0524583</Mean> <Q3>10991680.2776563</Q3> <UpperFence>10992786.7861719</UpperFence> <Max>10992115.5501563</Max> <InterquartileRange>737.672343749553</InterquartileRange> <StandardError>148.484545262958</StandardError> <Variance>330714.902729213</Variance> <StandardDeviation>575.07817097262</StandardDeviation> <Skewness>-0.67759778074187</Skewness> <Kurtosis>3.14296703520386</Kurtosis> <ConfidenceInterval> <N>15</N> <Mean>10991270.0524583</Mean> <StandardError>148.484545262958</StandardError> <Level>L999</Level> <Margin>614.793505974065</Margin> <Lower>10990655.2589524</Lower> <Upper>10991884.8459643</Upper> </ConfidenceInterval> <Percentiles> <P0>10989865.8785938</P0> <P25>10991027.3689063</P25> <P50>10991249.5870313</P50> <P67>10991489.490875</P67> <P80>10991696.7722187</P80> <P85>10991754.5031875</P85> <P90>10991933.1939688</P90> <P95>10992067.441125</P95> <P100>10992115.5501563</P100> </Percentiles> </Statistics> </Benchmark> </Benchmarks> </Summary> Links Exporters The permanent link to this sample: Sample: IntroExportXml Plots You can install R to automatically get nice plots of your benchmark results. First, make sure Rscript.exe or Rscript is in your path, or define an R_HOME environment variable pointing to the R installation directory. eg: If Rscript is located in /path/to/R/R-1.2.3/bin/Rscript , then R_HOME must point to /path/to/R/R-1.2.3/ , it should not point to /path/to/R/R-1.2.3/bin Use RPlotExporter.Default and CsvMeasurementsExporter.Default in your config, and the BuildPlots.R script in your bin directory will take care of the rest. Examples: <BenchmarkName>-barplot.png <BenchmarkName>-boxplot.png <BenchmarkName>-<MethodName>-density.png <BenchmarkName>-<MethodName>-facetTimeline.png <BenchmarkName>-<MethodName>-facetTimelineSmooth.png <BenchmarkName>-<MethodName>-<JobName>-timelineSmooth.png <BenchmarkName>-<MethodName>-<JobName>-timelineSmooth.png A config example in C#: public class Config : ManualConfig { public Config() { Add(CsvMeasurementsExporter.Default); Add(RPlotExporter.Default); } } A config example in F#: module MyBenchmark open BenchmarkDotNet.Attributes open BenchmarkDotNet.Configs open BenchmarkDotNet.Exporters open BenchmarkDotNet.Exporters.Csv open MyProjectUnderTest type MyConfig() as this = inherit ManualConfig() do this.Add(CsvMeasurementsExporter.Default) this.Add(RPlotExporter.Default) [< MemoryDiagnoser; Config(typeof<MyConfig>); RPlotExporter >] type MyPerformanceTests() = let someTestData = getTestDataAsList () [<Benchmark>] member __.SomeTestCase() = someTestData |> myFunctionUnderTest CSV The CSV file format is often used to graph the output or to analyze the results programmatically. The CSV exporter may be configured to produce sanitized output, where cell values are numerals and their units are predefined. The CSV exporter and other compatible exporters may consume an instance of ISummaryStyle that defines how the output should look like: Property Remarks Default PrintUnitsInHeader If true, units will be displayed in the header row false PrintUnitsInContent If true, units will be appended to the value true TimeUnit If null, unit will be automatically selected null SizeUnit If null, unit will be automatically selected null Example of CSV exporter configured to always use microseconds, kilobytes, and to render units only in column headers: var exporter = new CsvExporter( CsvSeparator.CurrentCulture, new SummaryStyle( cultureInfo: System.Globalization.CultureInfo.CurrentCulture, printUnitsInHeader: true, printUnitsInContent: false, timeUnit: Perfolizer.Horology.TimeUnit.Microsecond, sizeUnit: SizeUnit.KB )); var config = ManualConfig.CreateMinimumViable().AddExporter(exporter); Excerpt from the resulting CSV file: Method,...,Mean [us],Error [us],StdDev [us],Min [us],Max [us],Allocated [KB] Benchmark,...,\"37,647.6\",\"32,717.9\",\"21,640.9\",\"11,209.2\",\"59,492.6\",1.58"
  },
  "articles/configs/filters.html": {
    "href": "articles/configs/filters.html",
    "title": "Filters | BenchmarkDotNet",
    "keywords": "Filters Sometimes you don't want to run all of your benchmarks. In this case, you can filter some of them with the help of filters . Predefined filters: Filter Type Filters benchmarks by Console argument Console example GlobFilter Provided glob pattern filter --filter Serializer .ToStream AttributesFilter Provided attribute names attribute --attribute STAThread AllCategoriesFilter All Provided category names categories --allCategories Priority1 CoreFX AnyCategoriesFilter Any provided category names anycategories --anyCategories Json Xml SimpleFilter Provided lambda predicate - NameFilter Provided lambda predicate - UnionFilter Logical AND - DisjunctionFilter Logical OR - Sample: IntroFilters You can either use one of the predefined Filter types or create a custom type which implements IFilter interface. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [DryJob] [Config(typeof(Config))] public class IntroFilters { private class Config : ManualConfig { // We will benchmark ONLY method with // names (which contains \"A\" OR \"1\") AND (have length < 3) public Config() { // benchmark with names which contains \"A\" OR \"1\" AddFilter(new DisjunctionFilter( new NameFilter(name => name.Contains(\"A\")), new NameFilter(name => name.Contains(\"1\")) )); // benchmark with names with length < 3 AddFilter(new NameFilter(name => name.Length < 3)); } } [Benchmark] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A3() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B2() => Thread.Sleep(10); [Benchmark] public void B3() => Thread.Sleep(10); [Benchmark] public void C1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void C2() => Thread.Sleep(10); [Benchmark] public void C3() => Thread.Sleep(10); [Benchmark] public void Aaa() => Thread.Sleep(10); } } Links Filters The permanent link to this sample: Sample: IntroFilters Sample: IntroCategories Combined together with [BenchmarkCategory] attribute, you can group the benchmarks into categories and filter them by categories. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [BenchmarkCategory(\"Awesome\")] [AnyCategoriesFilter(\"A\", \"1\")] public class IntroCategories { [Benchmark] [BenchmarkCategory(\"A\", \"1\")] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"A\", \"2\")] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"1\")] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"2\")] public void B2() => Thread.Sleep(10); } } Command line examples: --allCategories=A,B --anyCategories=A,B Links Filters The permanent link to this sample: Sample: IntroCategories Sample: IntroJoin If you are using BenchmarkSwitcher and want to run all the benchmarks with a category from all types and join them into one summary table, use the --join option (or BenchmarkSwitcher.RunAllJoined ): Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // Run BenchmarkSwitcher with arguments: \"--join --category=IntroJoinA\" [DryJob] public class IntroJoin1 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } [DryJob] public class IntroJoin2 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } } Command line --join --allCategories=IntroJoinA Output | Type | Method | Mean | Error | |----------- |------- |---------:|------:| | IntroJoin1 | A | 10.99 ms | NA | | IntroJoin2 | A | 12.50 ms | NA | Links Filters The permanent link to this sample: Sample: IntroJoin"
  },
  "articles/configs/jobs.html": {
    "href": "articles/configs/jobs.html",
    "title": "Jobs | BenchmarkDotNet",
    "keywords": "Jobs Basically, a job describes how to run your benchmark. Practically, it's a set of characteristics which can be specified. You can specify one or several jobs for your benchmarks. Characteristics There are several categories of characteristics which you can specify. Let's consider each category in detail. Id It's a single string characteristic. It allows to name your job. This name will be used in logs and a part of a folder name with generated files for this job. Id doesn't affect benchmark results, but it can be useful for diagnostics. If you don't specify Id , random value will be chosen based on other characteristics Environment Environment specifies an environment of the job. You can specify the following characteristics: Platform : x86 or x64 Runtime : Clr : Full .NET Framework (available only on Windows) Core : CoreCLR (x-plat) Mono : Mono (x-plat) Jit : LegacyJit (available only for Runtime.Clr ) RyuJit (available only for Runtime.Clr and Runtime.Core ) Llvm (available only for Runtime.Mono ) Affinity : Affinity of a benchmark process GcMode : settings of Garbage Collector Server : true (Server mode) or false (Workstation mode) Concurrent : true (Concurrent mode) or false (NonConcurrent mode) CpuGroups : Specifies whether garbage collection supports multiple CPU groups Force : Specifies whether the BenchmarkDotNet's benchmark runner forces full garbage collection after each benchmark invocation AllowVeryLargeObjects : On 64-bit platforms, enables arrays that are greater than 2 gigabytes (GB) in total size EnvironmentVariables : customized environment variables for target benchmark. See also: Sample: IntroEnvVars BenchmarkDotNet will use host process environment characteristics for non specified values. Run In this category, you can specifiy how to benchmark each method. RunStrategy : Throughput : default strategy which allows to get good precision level ColdStart : should be used only for measuring cold start of the application or testing purpose Monitoring : A mode without overhead evaluating, with several target iterations LaunchCount : how many times we should launch process with target benchmark WarmupCount : how many warmup iterations should be performed IterationCount : how many target iterations should be performed (if specified, BenchmarkDotNet.Jobs.RunMode.MinIterationCount and BenchmarkDotNet.Jobs.RunMode.MaxIterationCount will be ignored) IterationTime : desired time of a single iteration UnrollFactor : how many times the benchmark method will be invoked per one iteration of a generated loop InvocationCount : count of invocation in a single iteration (if specified, IterationTime will be ignored), must be a multiple of UnrollFactor MinIterationCount : Minimum count of target iterations that should be performed, the default value is 15 MaxIterationCount : Maximum count of target iterations that should be performed, the default value is 100 MinWarmupIterationCount : Minimum count of warmup iterations that should be performed, the default value is 6 MaxWarmupIterationCount : Maximum count of warmup iterations that should be performed, the default value is 50 Usually, you shouldn't specify such characteristics like LaunchCount , WarmupCount , TargetCount , or IterationTime because BenchmarkDotNet has a smart algorithm to choose these values automatically based on received measurements. You can specify it for testing purposes or when you are damn sure that you know the right characteristics for your benchmark (when you set TargetCount = 20 you should understand why 20 is a good value for your case). Accuracy If you want to change the accuracy level, you should use the following characteristics instead of manually adjusting values of WarmupCount , TargetCount , and so on. MaxRelativeError , MaxAbsoluteError : Maximum acceptable error for a benchmark (by default, BenchmarkDotNet continue iterations until the actual error is less than the specified error). In these two characteristics , the error means half of 99.9% confidence interval. MaxAbsoluteError is an absolute TimeInterval ; doesn't have a default value. MaxRelativeError defines max acceptable ( (<half of CI 99.9%>) / Mean ). MinIterationTime : Minimum time of a single iteration. Unlike Run.IterationTime , this characteristic specifies only the lower limit. In case of need, BenchmarkDotNet can increase this value. MinInvokeCount : Minimum about of target method invocation. Default value if 4 but you can decrease this value for cases when single invocations takes a lot of time. EvaluateOverhead : if you benchmark method takes nanoseconds, BenchmarkDotNet overhead can significantly affect measurements. If this characterics is enable, the overhead will be evaluated and subtracted from the result measurements. Default value is true . WithOutlierMode : sometimes you could have outliers in your measurements. Usually these are unexpected outliers which arose because of other processes activities. By default ( OutlierMode.RemoveUpper ), all upper outliers (which is larger than Q3) will be removed from the result measurements. However, some of benchmarks have expected outliers. In these situation, you expect that some of invocation can produce outliers measurements (e.g. in case of network activities, cache operations, and so on). If you want to see result statistics with these outliers, you should use OutlierMode.DontRemove . If you can also choose OutlierMode.RemoveLower (outliers which are smaller than Q1 will be removed) or OutlierMode.RemoveAll (all outliers will be removed). See also: @BenchmarkDotNet.Mathematics.OutlierMode AnalyzeLaunchVariance : this characteristic makes sense only if Run.LaunchCount is default. If this mode is enabled and, BenchmarkDotNet will try to perform several launches and detect if there is a veriance between launches. If this mode is disable, only one launch will be performed. Infrastructure Usually, you shouldn't specify any characteristics from this section, it can be used for advanced cases only. Toolchain : a toolchain which generates source code for target benchmark methods, builds it, and executes it. BenchmarkDotNet has own toolchains for .NET, .NET Core, Mono and CoreRT projects. If you want, you can define own toolchain. Clock : a clock which will be used for measurements. BenchmarkDotNet automatically choose the best available clock source, but you can specify own clock source. EngineFactory : a provider for measurement engine which performs all the measurement magic. If you don't trust BenchmarkDotNet, you can define own engine and implement all the measurement stages manually. Usage There are several ways to specify a job. Object style You can create own jobs directly from the source code via a custom config: [Config(typeof(Config))] public class MyBenchmarks { private class Config : ManualConfig { public Config() { Add( new Job(\"MySuperJob\", RunMode.Dry, EnvMode.RyuJitX64) { Env = { Runtime = Runtime.Core }, Run = { LaunchCount = 5, IterationTime = TimeInterval.Millisecond * 200 }, Accuracy = { MaxStdErrRelative = 0.01 } }); // The same, using the .With() factory methods: Add( Job.Dry .WithPlatform(Platform.X64) .WithJit(Jit.RyuJit) .WithRuntime(Runtime.Core) .WithLaunchCount(5) .WithIterationTime(TimeInterval.Millisecond * 200) .WithMaxRelativeError(0.01) .WithId(\"MySuperJob\")); } } // Benchmarks } Basically, it's a good idea to start with predefined values (e.g. EnvMode.RyuJitX64 and RunMode.Dry passed as constructor args) and modify rest of the properties using property setters or with help of object initializer syntax. Note that the job cannot be modified after it's added into config. Trying to set a value on property of the frozen job will throw an InvalidOperationException . Use the Job.Frozen property to determine if the code properties can be altered. If you do want to create a new job based on frozen one (all predefined job values are frozen) you can use the .With() extension method var newJob = Job.Dry.With(Platform.X64); or pass the frozen value as a constructor argument var newJob = new Job(Job.Dry) { Env = { Platform = Platform.X64 } }; or use the .Apply() method on unfrozen job var newJob = new Job() { Env = { Platform = Platform.X64 } }.Apply(Job.Dry); in any case the Id property will not be transfered and you must pass it explicitly (using the .ctor id argument or the .WithId() extension method). Attribute style You can also add new jobs via attributes. Examples: [DryJob] [ClrJob, CoreJob, MonoJob] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] [SimpleJob(RunStrategy.ColdStart, launchCount: 1, warmupCount: 5, targetCount: 5, id: \"FastAndDirtyJob\")] public class MyBenchmarkClass Note that each of the attributes identifies a separate job, the sample above will result in 8 different jobs, not a single merged job. Attribute style for merging jobs Sometimes you want to apply some changes to other jobs, without adding a new job to a config (which results in one extra benchmark run). To do that you can use following predefined job mutator attributes: [EvaluateOverhead] [GcConcurrent] [GcForce] [GcServer] [InnerIterationCount] [InvocationCount] [IterationCount] [IterationTime] [MaxAbsoluteError] [MaxIterationCount] [MaxRelativeError] [MinInvokeCount] [MinIterationCount] [MinIterationTime] [Outliers] [ProcessCount] [RunOncePerIteration] [WarmupCount] [MinWarmupCount] [MaxWarmupCount] So following example: [ClrJob, CoreJob] [GcServer(true)] public class MyBenchmarkClass Is going to be merged to a config with two jobs: CoreJob with GcServer=true ClrJob with GcServer=true Custom attributes You can also create your own custom attributes with your favourite set of jobs. Example: [AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly)] public class MySuperJobAttribute : Attribute, IConfigSource { protected MySuperJobAttribute() { var job = new Job(\"MySuperJob\", RunMode.Core); job.Env.Platform = Platform.X64; Config = ManualConfig.CreateEmpty().With(job); } public IConfig Config { get; } } [MySuperJob] public class MyBenchmarks Sample: IntroGcMode Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroGcMode { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(true).WithId(\"ServerForce\")); AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(false).WithId(\"Server\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(true).WithId(\"Workstation\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(false).WithId(\"WorkstationForce\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Jobs The permanent link to this sample: Sample: IntroGcMode"
  },
  "articles/configs/loggers.html": {
    "href": "articles/configs/loggers.html",
    "title": "Loggers | BenchmarkDotNet",
    "keywords": "Loggers A logger allows you to log results of your benchmark. By default, you can see log on console and in a file ( <BenchmarkName>.log )."
  },
  "articles/configs/orderers.html": {
    "href": "articles/configs/orderers.html",
    "title": "Orderers | BenchmarkDotNet",
    "keywords": "Orderers Orderers allows customizing the order of benchmark results in the summary table. Sample: IntroOrderAttr Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Orderer(SummaryOrderPolicy.FastestToSlowest, MethodOrderPolicy.Declared)] [DryJob] public class IntroOrderAttr { [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Slow() => Thread.Sleep(X * 100); [Benchmark] public void Fast() => Thread.Sleep(X * 50); } } Links Orderers The permanent link to this sample: Sample: IntroOrderAttr Sample: IntroOrderManual Source code using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [DryJob] [RankColumn] public class IntroOrderManual { private class Config : ManualConfig { public Config() => Orderer = new FastestToSlowestOrderer(); private class FastestToSlowestOrderer : IOrderer { public IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase) => from benchmark in benchmarksCase orderby benchmark.Parameters[\"X\"] descending, benchmark.Descriptor.WorkloadMethodDisplayInfo select benchmark; public IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) => from benchmark in benchmarksCase orderby summary[benchmark].ResultStatistics.Mean select benchmark; public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) => null; public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) => benchmarkCase.Job.DisplayInfo + \"_\" + benchmarkCase.Parameters.DisplayInfo; public IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups) => logicalGroups.OrderBy(it => it.Key); public bool SeparateLogicalGroups => true; } } [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Fast() => Thread.Sleep(X * 50); [Benchmark] public void Slow() => Thread.Sleep(X * 100); } } Links Orderers The permanent link to this sample: Sample: IntroOrderManual"
  },
  "articles/configs/powerplans.html": {
    "href": "articles/configs/powerplans.html",
    "title": "Power Plans | BenchmarkDotNet",
    "keywords": "Power Plans BenchmarkDotNet forces Windows OS to execute on the High-Performance power plan. You can disable this feature by modify PowerPlanMode property. You can see it in the Sample: IntroPowerPlan . Please note. During an execution, BenchmarkDotNet saves the current power plan and applies it according to the PowerPlanMode property. When all of the benchmarks finish, a previous power plan comes back. However, if someone killed process or energy was plugged off, we could stay with the High-Performance power plan. In this situation, we should return it manually in Windows Control Panel or by powercfg command. Links Power policy settings: https://docs.microsoft.com/en-us/windows/desktop/power/power-policy-settings Powercfg command: https://docs.microsoft.com/en-us/windows-hardware/design/device-experiences/powercfg-command-line-options Sample: IntroPowerPlan"
  },
  "articles/configs/toolchains.html": {
    "href": "articles/configs/toolchains.html",
    "title": "Toolchains | BenchmarkDotNet",
    "keywords": "Toolchains To achieve process-level isolation, BenchmarkDotNet generates, builds and executes a new console app per every benchmark. A toolchain contains generator, builder, and executor. When you run your benchmarks without specifying the toolchain in an explicit way, the default one is used: Roslyn for Full .NET Framework and Mono dotnet cli for .NET Core and CoreRT Multiple frameworks support If you want to test multiple frameworks, your project file MUST target all of them and you MUST install the corresponding SDKs : <TargetFrameworks>netcoreapp3.0;netcoreapp2.1;net48</TargetFrameworks> If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks using the same framework as the host process : dotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1 dotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0 dotnet run -c Release -f net48 # is going to run the benchmarks using .NET 4.8 mono $pathToExe # is going to run the benchmarks using Mono from your PATH To run the benchmarks for multiple runtimes with a single command, you need to specify the target framework moniker names via --runtimes|-r console argument: dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0 dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48 # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8 What is going to happen if you provide multiple Full .NET Framework monikers? Let's say: dotnet run -c Release -f net461 net472 net48 Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on target version they were compiled for. You can read more about this here and here . This is .NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool . Note: Console arguments support works only if you pass the args to BenchmarkSwitcher : class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args); // crucial to make it work } You can achieve the same thing using [SimpleJobAttribute] : using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(RuntimeMoniker.Net48)] [SimpleJob(RuntimeMoniker.Mono)] [SimpleJob(RuntimeMoniker.NetCoreApp21)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] public class TheClassWithBenchmarks Or using a custom config: using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { class Program { static void Main(string[] args) { var config = DefaultConfig.Instance .With(Job.Default.With(CoreRuntime.Core21)) .With(Job.Default.With(CoreRuntime.Core30)) .With(Job.Default.With(ClrRuntime.Net48)) .With(Job.Default.With(MonoRuntime.Default)); BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); } } } The recommended way of running the benchmarks for multiple runtimes is to use the --runtimes console line argument. By using the console line argument you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark other people can run it even if they don't have the exact same framework version installed. Custom .NET Core Runtime We can run your benchmarks for custom <RuntimeFrameworkVersion> if you want. All you need to do is to create custom toolchain by calling CsProjCoreToolchain.From method, which accepts NetCoreAppSettings . public class MyConfig : ManualConfig { public MyConfig() { Add(Job.Default.With( CsProjCoreToolchain.From( new NetCoreAppSettings( targetFrameworkMoniker: \"netcoreapp2.1\", runtimeFrameworkVersion: \"2.1.0-preview2-25628-01\", name: \".NET Core 2.1\")))); } } Custom .NET Runtime It's possible to benchmark a private build of .NET Runtime. All you need to do is to define a job with the right version of ClrRuntime . BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, DefaultConfig.Instance.With( Job.ShortRun.With(ClrRuntime.CreateForLocalFullNetFrameworkBuild(version: \"4.0\")))); This sends the provided version as a COMPLUS_Version env var to the benchmarked process. Custom dotnet cli path We internally use dotnet cli to build and run .NET Core executables. Sometimes it might be mandatory to use non-default dotnet cli path. An example scenario could be a comparison of RyuJit 32bit vs 64 bit. It required due this limitation of dotnet cli public class CustomPathsConfig : ManualConfig { public CustomPathsConfig() { var dotnetCli32bit = NetCoreAppSettings .NetCoreApp20 .WithCustomDotNetCliPath(@\"C:\\Program Files (x86)\\dotnet\\dotnet.exe\", \"32 bit cli\"); var dotnetCli64bit = NetCoreAppSettings .NetCoreApp20 .WithCustomDotNetCliPath(@\"C:\\Program Files\\dotnet\\dotnet.exe\", \"64 bit cli\"); Add(Job.RyuJitX86.With(CsProjCoreToolchain.From(dotnetCli32bit)).WithId(\"32 bit cli\")); Add(Job.RyuJitX64.With(CsProjCoreToolchain.From(dotnetCli64bit)).WithId(\"64 bit cli\")); } } BenchmarkDotNet=v0.10.9.20170910-develop, OS=Windows 10 Redstone 1 (10.0.14393) Processor=Intel Core i7-6600U CPU 2.60GHz (Skylake), ProcessorCount=4 Frequency=2742185 Hz, Resolution=364.6727 ns, Timer=TSC .NET Core SDK=2.1.0-preview1-007074 [Host] : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT 32 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 32bit RyuJIT 64 bit cli : .NET Core 2.0.0 (Framework 4.6.00001.0), 64bit RyuJIT Jit=RyuJit This feature is now also exposed with the --cli console argument. Example: dotnet run -c Release -- --cli \"C:\\Projects\\machinelearning\\Tools\\dotnetcli\\dotnet.exe\" CoreRun To use CoreRun for running the benchmarks you need to use --coreRun command line argument. You can combine it with --cli described above. This is most probably the easiest and most reliable way of running benchmarks against local CoreFX/CoreCLR builds. Example: dotnet run -c Release -- --coreRun \"C:\\Projects\\corefx\\bin\\testhost\\netcoreapp-Windows_NT-Release-x64\\shared\\Microsoft.NETCore.App\\9.9.9\\CoreRun.exe\" Sample: IntroInProcess InProcessEmitToolchain is our toolchain which does not generate any new executable. It emits IL on the fly and runs it from within the process itself. It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support. An example could be a local build of CoreCLR. Usage [InProcessAttribute] public class TypeWithBenchmarks { } Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcess { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun .WithLaunchCount(1) .WithId(\"OutOfProc\")); AddJob(Job.MediumRun .WithLaunchCount(1) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: Sample: IntroInProcess Sample: IntroInProcessWrongEnv Source code using System; using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcessWrongEnv { private class Config : ManualConfig { public Config() { var wrongPlatform = Environment.Is64BitProcess ? Platform.X64 : Platform.X86; AddJob(Job.MediumRun .WithLaunchCount(1) .WithPlatform(wrongPlatform) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); AddValidator(InProcessValidator.DontFailOnError); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: Sample: IntroInProcessWrongEnv CoreRT BenchmarkDotNet supports CoreRT ! However, you might want to know how it works to get a better understanding of the results that you get. CoreRT is a flavor of .NET Core. Which means that: you have to target .NET Core to be able to build CoreRT benchmarks (example: <TargetFramework>net5.0</TargetFramework> in the .csproj file) you have to specify the CoreRT runtime in an explicit way, either by using [SimpleJob] attribute or by using the fluent Job config API Job.ShortRun.With(CoreRtRuntime.$version) or console line arguments --runtimes corert50 to run CoreRT benchmark you run the app as a .NET Core/.NET process (example: dotnet run -c Release -f net5.01 ) and BenchmarkDotNet does all the CoreRT compilation for you. If you want to check what files are generated you need to apply [KeepBenchmarkFiles] attribute to the class which defines benchmarks. By default BenchmarkDotNet uses the latest version of Microsoft.DotNet.ILCompiler to build the CoreRT benchmark according to this instructions . var config = DefaultConfig.Instance .With(Job.Default.With(CoreRtRuntime.CoreRt50)); // compiles the benchmarks as net5.0 and uses the latest CoreRT to build a native app BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); [SimpleJob(RuntimeMoniker.CoreRt50)] // compiles the benchmarks as net5.0 and uses the latest CoreRT to build a native app public class TheTypeWithBenchmarks { [Benchmark] // the benchmarks go here } Note : BenchmarkDotNet is going to run dotnet restore on the auto-generated project. The first time it does so, it's going to take a LOT of time to download all the dependencies (few minutes). Just give it some time and don't press Ctrl+C too fast ;) If you want to benchmark some particular version of CoreRT (or from a different NuGet feed) you have to specify it in an explicit way: var config = DefaultConfig.Instance .With(Job.ShortRun .With(CoreRtToolchain.CreateBuilder() .UseCoreRtNuGet( microsoftDotNetILCompilerVersion: \"6.0.0-*\", // the version goes here nuGetFeedUrl: \"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet-experimental/nuget/v3/index.json\") // this address might change over time .DisplayName(\"CoreRT NuGet\") .TargetFrameworkMoniker(\"net5.0\") .ToToolchain())); Compiling source to native code using the ILCompiler you built If you are an CoreRT contributor and you want to benchmark your local build of CoreRT you have to provide necessary info (IlcPath): var config = DefaultConfig.Instance .With(Job.ShortRun .With(CoreRtToolchain.CreateBuilder() .UseCoreRtLocal(@\"C:\\Projects\\corert\\bin\\Windows_NT.x64.Release\") // IlcPath .DisplayName(\"Core RT RyuJit\") .TargetFrameworkMoniker(\"netcoreapp2.1\") .ToToolchain())); BenchmarkDotNet is going to follow these instructrions to get it working for you. Using CPP Code Generator This approach uses transpiler to convert IL to C++, and then uses platform specific C++ compiler and linker for compiling/linking the application. The transpiler is a lot less mature than the RyuJIT path. If you came here to give CoreRT a try on your .NET Core program, use the RyuJIT option above. If you want to test CPP Code Generator you have to use UseCppCodeGenerator method: var config = DefaultConfig.Instance .With(Job.Default .With( CoreRtToolchain.CreateBuilder() .UseCoreRtLocal(@\"C:\\Projects\\corert\\bin\\Windows_NT.x64.Release\") // IlcPath .UseCppCodeGenerator() // ENABLE IT .TargetFrameworkMoniker(\"netcoreapp2.1\") .DisplayName(\"CPP\") .ToToolchain())); Note : You might get some The method or operation is not implemented. errors as of today if the code that you are trying to benchmark is using some features that are not implemented by CoreRT/transpiler yet... Wasm BenchmarkDotNet supports Web Assembly on Unix! However, currently you need to build the dotnet runtime yourself to be able to run the benchmarks. For up-to-date docs, you should visit dotnet/runtime repository . The docs below are specific to Ubuntu 18.04 at the moment of writing this document (16/07/2020). Firs of all, you need to install.... npm 10+: curl -sL https://deb.nodesource.com/setup_12.x | sudo -E bash - sudo apt install nodejs After this, you need to install jsvu : npm install jsvu -g Add it to PATH: export PATH=\"${HOME}/.jsvu:${PATH}\" And use it to install V8, JavaScriptCore and SpiderMonkey: jsvu --os=linux64 --engines=javascriptcore,spidermonkey,v8 Now you need to install Emscripten : git clone https://github.com/emscripten-core/emsdk.git cd emsdk ./emsdk install latest ./emsdk activate latest source ./emsdk_env.sh The last thing before cloning dotnet/runtime repository is creation of EMSDK_PATH env var used by Mono build scripts: export EMSDK_PATH=$EMSDK Now you need to clone dotnet/runtime repository: git clone https://github.com/dotnet/runtime cd runtime Install all Mono prerequisites : sudo apt-get install cmake llvm-9 clang-9 autoconf automake libtool build-essential python curl git lldb-6.0 liblldb-6.0-dev libunwind8 libunwind8-dev gettext libicu-dev liblttng-ust-dev libssl-dev libnuma-dev libkrb5-dev zlib1g-dev And FINALLY build Mono Runtime with Web Assembly support: ./build.sh --arch wasm --os Browser -c release Before you run the benchmarks, you need to make sure that following two file exists: runtime/src/mono/wasm/runtime-test.js runtime/build.sh And that you have .NET 5 feed added to your nuget.config file: <add key=\"dotnet5\" value=\"https://pkgs.dev.azure.com/dnceng/public/_packaging/dotnet5/nuget/v3/index.json\" /> Now you should be able to run the Wasm benchmarks! Sample: IntroWasm WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using System.IO; using BenchmarkDotNet.Toolchains; using BenchmarkDotNet.Toolchains.DotNetCli; using BenchmarkDotNet.Toolchains.MonoWasm; namespace BenchmarkDotNet.Samples { // *** Command Line Arguments *** public class IntroWasmCmdConfig { // the args must contain: // an information that we want to run benchmark as Wasm: // --runtimes Wasm // path to dotnet cli // --cli /home/adam/projects/runtime/dotnet.sh // path to main js: // --wasmMainJs /home/adam/projects/runtime/src/mono/wasm/runtime-test.js public static void Run(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args); [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroWasmFluentConfig { public static void Run() { // the Wasm Toolchain requires two mandatory arguments: const string mainJsPath = @\"/home/adam/projects/runtime/src/mono/wasm/runtime-test.js\"; const string cliPath = @\"/home/adam/projects/runtime/dotnet.sh\"; WasmRuntime runtime = new WasmRuntime(mainJs: new FileInfo(mainJsPath), msBuildMoniker: \"net5.0\"); NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings( targetFrameworkMoniker: \"net5.0\", runtimeFrameworkVersion: null, name: \"Wasm\", customDotNetCliPath: cliPath); IToolchain toolChain = WasmToolChain.From(netCoreAppSettings); BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(DefaultConfig.Instance .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Toolchains The permanent link to this sample: Sample: IntroWasm MonoAotLLVM BenchmarkDotNet supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses llvm on the back end). Using this tool chain requires the following flags: --runtimes monoaotllvm --aotcompilerpath <path to mono aot compiler> --customruntimepack <path to runtime pack> and optionally (defaults to mini) --aotcompilermode <mini|llvm> As of this writing, the mono aot compiler is not available as a seperate download or nuget package. Therefore, it is required to build the compiler in the [dotnet/runtime repository]. The compiler binary (mono-sgen) is built as part of the mono subset, so it can be built (along with the runtime pack) like so (in the root of [dotnet/runtime]). ./build.sh -subset mono+libs -c Release The compiler binary should be generated here (modify for your platform): <runtime root>/artifacts/obj/mono/OSX.x64.Release/mono/mini/mono-sgen And the runtime pack should be generated here: <runtimeroot>artifacts/bin/microsoft.netcore.app.runtime.osx-x64/Release/"
  },
  "articles/configs/validators.html": {
    "href": "articles/configs/validators.html",
    "title": "Validators | BenchmarkDotNet",
    "keywords": "Validators A validator can validate your benchmarks before they are executed and produce validation errors. If any of the validation errors is critical, then none of the benchmarks will get executed. Available validators are: BaselineValidator.FailOnError - it checks if more than 1 Benchmark per class has Baseline = true applied. This validator is mandatory. JitOptimizationsValidator.(Dont)FailOnError - it checks whether any of the referenced assemblies is non-optimized. DontFailOnError version is enabled by default. ExecutionValidator.(Dont)FailOnError - it checks if it is possible to run your benchmarks by executing each of them once. Optional. ReturnValueValidator.(Dont)FailOnError - it checks if non-void benchmarks return equal values. Optional."
  },
  "articles/contributing/building.html": {
    "href": "articles/contributing/building.html",
    "title": "Building | BenchmarkDotNet",
    "keywords": "Building There are two recommended options to build BenchmarkDotNet from source: Option A (Windows only) - Visual Studio Visual Studio 2017 version 15.7 Preview 4 or higher (Community, Professional, Enterprise). Visual Studio 2017 doesn't have installed necessary the .NET Core SDK 2.1 Preview 1, but you can get it from the Installing the .Net Core SDK page . You may also need .NET Core Runtime 2.1 Preview 1 . Visual Studio 2017 should have installed “F# language support” feature. You can also install the support directly as a separate download . Once all the necessary tools are in place, building is trivial. Simply open solution file BenchmarkDotNet.sln that lives at the base of the repository and run Build action. Option B (Windows, Linux, macOS) - Cake (C# Make) Cake (C# Make) is a cross platform build automation system with a C# DSL to do things like compiling code, copy files/folders, running unit tests, compress files and build NuGet packages. The build currently depends on the following prerequisites: Windows: PowerShell version 5 or higher MSBuild version 15.1 or higher .NET Framework 4.6 or higher Linux: Install Mono version 5 or higher Install fsharp package Install packages required to .NET Core SDK gettext libcurl4-openssl-dev libicu-dev libssl-dev libunwind8 macOS Install Mono version 5 or higher Install fsharp package Install the latest version of OpenSSL . After you have installed these pre-requisites, you can build the BenchmarkDotNet by invoking the build script ( build.ps1 on Windows, or build.sh on Linux and macOS) at the base of the BenchmarkDotNet repository. By default the build process also run all the tests. There are quite a few tests, taking a significant amount of time that is not necessary if you just want to experiment with changes. You can skip the tests phase by adding the skiptests argument to the build script, e.g. .\\build.ps1 --SkipTests=True or ./build.sh --skiptests=true . Build has a number of options that you use. Some of the more important options are skiptests - do not run the tests. This can shorten build times quite a bit. On Windows: .\\build.ps1 --SkipTests=True or ./build.sh --skiptests=true on Linux/macOS. configuration - build the 'Release' or 'Debug' build type. Default value is 'Release'. On Windows: .\\build.ps1 -Configuration Debug or ./build.sh --configuration debug on Linux/macOS. target - with this parameter you can run a specific target from build pipeline. Default value is 'Default' target. On Windows: .\\build.ps1 -Target Default or ./build.sh --target default on Linux/macOS. Available targets: Default - run all actions one by one. Clean - clean all obj , bin and artifacts directories. Restore - automatically execute Clean action and after that restore all NuGet dependencies. Build - automatically execute Restore action, then run MSBuild for the solution file. FastTests - automatically execute Build action, then run all tests from the BenchmarkDotNet.Tests project. SlowTests - automatically execute Build action, then run all tests from the BenchmarkDotNet.IntegrationTests project. Pack - automatically execute Build action and after that creates local NuGet packages."
  },
  "articles/contributing/debugging.html": {
    "href": "articles/contributing/debugging.html",
    "title": "Debugging | BenchmarkDotNet",
    "keywords": "Debugging There should be two debug profiles available in VS drop down However due to VS 2017 RC4 bug it seems that it's impossible to choose as of 2/19/2017. If you want to change it then please edit the project file (.csproj) and set your order - the first framework moniker is always used. <TargetFrameworks>netcoreapp1.1;net461</TargetFrameworks>"
  },
  "articles/contributing/development.html": {
    "href": "articles/contributing/development.html",
    "title": "Development | BenchmarkDotNet",
    "keywords": "Development When you want to add some dependency then you just use the \"Add reference\" option avaiable in Visual Studio. However, sometimes it might be not enough. If it supports all frameworks Just add it to the top level of csproj. <ItemGroup> <ProjectReference Include=\"..\\..\\src\\BenchmarkDotNet\\BenchmarkDotNet.csproj\" /> </ItemGroup> If the package/project is not available for all target frameworks Specify a conditional dependency: <ItemGroup Condition=\" $(TargetFramework.StartsWith('net4')) \"> <ProjectReference Include=\"..\\..\\src\\BenchmarkDotNet.Diagnostics.Windows\\BenchmarkDotNet.Diagnostics.Windows.csproj\" /> </ItemGroup> Once you add it as dependency to specific framework, you need to use ugly #if #endif to exclude it for other compilation targets. We define #CLASSIC, #CORE. In other OSS projects you can meet more complex names like #NET40, #NET451, #DNXCORE50 or #NETCORE. #if CLASSIC using Microsoft.Build.Framework; using Microsoft.Build.Utilities; namespace BenchmarkDotNet.Loggers { internal class MsBuildConsoleLogger : Logger { private ILogger Logger { get; set; } public MsBuildConsoleLogger(ILogger logger) { Logger = logger; } public override void Initialize(IEventSource eventSource) { // By default, just show errors not warnings if (eventSource != null) eventSource.ErrorRaised += OnEventSourceErrorRaised; } private void OnEventSourceErrorRaised(object sender, BuildErrorEventArgs e) => Logger.WriteLineError(\"// {0}({1},{2}): error {3}: {4}\", e.File, e.LineNumber, e.ColumnNumber, e.Code, e.Message); } } #endif"
  },
  "articles/contributing/disassembler.html": {
    "href": "articles/contributing/disassembler.html",
    "title": "Contributing to Disassembler | BenchmarkDotNet",
    "keywords": "Contributing to Disassembler The disassembler might looks scarry, but once you know how it works and how to debug it, it's very easy to develop it. How it works We have 3 disassemblers: Mono x64 for Windows x86 for Windows The MonoDisassembler is very simple: it spawns Mono with the right arguments to get the asm, Mono prints the output to the console and we just parse it. Single class does the job: MonoDisassembler . When it comes to Windows disassemblers it's not so easy. To obtain the disassm we are using ClrMD. ClrMD can attach only to the process of same bitness (architecture). This is why we have two dissasemblers: x64 and x86. The code is the same (single class, linked in two projects) but compiled for two different architectures. Unfortunately ClrMD is not a signed dll. This is why, we keep both diassemblers in the resources of the BenchmarkDotNet.dll. When we need the disassembler, we search for it in the resources, copy it to the disk and run (it's an exe). How to debug the disassembler You need to create a new project which executes the code that you would like to disassemble. It can be a simple console app. In this app, you need to run the desired code (to get it jitted) and just don't exit. Before you exit, you have to attach with Disassembler to given process. Disassembler requires some arguments to run: id of the process to attach, full type name of the type which contains desired method, name of desired method and what should be disassembled: asm, IL, C#, prolog & epilog. Personally I use following code to run the console app and print arguments that are required to attach to it: namespace Sample { class Program { static void Main(string[] args) { var result = Benchmark(); // execute the benchmark do method gets jitted Console.WriteLine( $\"{Process.GetCurrentProcess().Id} \" + // process Id $\"\\\"{typeof(Program).FullName}\\\" \" + // full type name $\"{nameof(Benchmark)} \" + // benchmarked method name $\"{bool.FalseString} \" + // print Source \"2 \" + // recursive depth $\"{Path.GetTempFileName()}.xml\"); // result xml file path while(true) { Console.WriteLine(\"Press Ctrl+C to kill the process\"); Console.ReadLine(); // block the exe, attach with Disassembler now } GC.KeepAlive(result); } public static IntPtr Benchmark() { return new IntPtr(42).Multiply(4); } } public static class IntPtrHelper { [MethodImpl(MethodImplOptions.AggressiveInlining)] public unsafe static IntPtr Multiply(this IntPtr a, int factor) { return (sizeof(IntPtr) == sizeof(int)) ? new IntPtr((int)a * factor) : new IntPtr((long)a * factor); } } } Important : Please remember that every new classic .NET project in VS compiles as 32 bit. If you want to check the asm produced for x64 you need to go to the properties of the console app (Alt+Enter) and uncheck \"Prefer 32 bit\" in the \"Build\" tab. Once you configure your app, you should run it. It will give you an output similar to this: 13672 ConsoleApp1.RandomSort ArraySort True 7 C:\\Users\\adsitnik\\AppData\\Local\\Temp\\tmpDCB9.tmp.xml Now you go to BenchmarkDotNet solution, select desired Disassembler project in the Solution Explorer and Set it as Startup project. After this you go to the project's properties and in the Debug tab copy-paste the arguments for the disassembler. Now when you start debugging, your IDE will spawn new process of the disassembler with the right arguments to attach to the desired exe. You should be able to debug it like any other app. Please keep in mind that you should always use the disassembler for the correct processor architecture. If you fail to debug it, you are most probably using the wrong one."
  },
  "articles/contributing/documentation.html": {
    "href": "articles/contributing/documentation.html",
    "title": "Documentation | BenchmarkDotNet",
    "keywords": "Documentation BenchmarkDotNet uses DocFX as a documentation generation tool. Hints If you want to provide a link to API, you can use cross references by UID . For example, [SimpleJobAttribute](xref:BenchmarkDotNet.Attributes.SimpleJobAttribute) and @BenchmarkDotNet.Attributes.SimpleJobAttribute will be transformed to SimpleJobAttribute . Notes DocFX uses the following syntax inside block quote for different types of notes: > [!NOTE] > note content > [!TIP] > tip content > [!WARNING] > warning content > [!IMPORTANT] > important content > [!Caution] > caution content It will be transformed to: Note note content Tip tip content Warning warning content Important important content Caution caution content Building documentation locally You can build documentation locally with the help of the DocFX_Build Cake target. Use the DocFX_Serve Cake target to build and run the documentation. Windows (PowerShell): .\\build.ps1 -Target DocFX_Build .\\build.ps1 -Target DocFX_Serve Windows (Batch): .\\build.bat -Target DocFX_Build .\\build.bat -Target DocFX_Serve Linux/macOS (Bash): ./build.sh --target DocFX_Build ./build.sh --target DocFX_Serve See also DocFX User Manual DocFX Tutorials: Links and Cross References DocFX Flavored Markdown"
  },
  "articles/contributing/miscellaneous.html": {
    "href": "articles/contributing/miscellaneous.html",
    "title": "F# | BenchmarkDotNet",
    "keywords": "#Miscellaneous topics F# We have full F# support, all you have to do is to run dotnet restore to download the compilers etc. Chat room How can I help? Here is a list of up-for-grabs issues"
  },
  "articles/contributing/running-tests.html": {
    "href": "articles/contributing/running-tests.html",
    "title": "Running Tests | BenchmarkDotNet",
    "keywords": "Running Tests To run \"Classic\" tests build the solution and run runClassicTests.cmd in the tests directory or comment out the netcoreapp1.0 part of all project.json files that belong to the testing projects. To run \"Core\" tests you just need to open Test Explorer in Visual Studio and rebuild the solution. Then tests show up in Test Explorer and you can simply run them. Important Remember to do both before pulling a PR or publishing new version For some unit tests (e.g. for exporter tests) BenchmarkDotNet uses approval tests' implementation for .NET: ApprovalTests.Net . The expected value for each test is stored in a *.approved.txt file located near the test source file in the repository. ApprovalTests.NET generates approved file's names automatically according test name and its parameters. This files must be added under the source control. It also creates a *.received file for each failed test. You can use different reporters for convenient file comparison. By default we use XUnit2Reporter, so you can find test run results on the test runner console as usual. You can add [UseReporter(typeof(KDiffReporter))] on test class and then ApprovalTests will open KDiff for each failed test. This way you can easily understand what's the difference between approved and received values and choose the correct one."
  },
  "articles/faq.html": {
    "href": "articles/faq.html",
    "title": "FAQ (Frequently asked questions) | BenchmarkDotNet",
    "keywords": "FAQ (Frequently asked questions) Q Why can't I install BenchmarkDotNet in Visual Studio 2010/2012/2013? A BenchmarkDotNet requires NuGet 3.x+ and can't be installed in old versions of Visual Studio which use NuGet 2.x. Consider to use Visual Studio 2015/2017 or Rider . See also: BenchmarkDotNet#237 , roslyn#12780 . Q Why can't I install BenchmarkDotNet in a new .NET Core Console App in Visual Studio 2017? A BenchmarkDotNet supports only netcoreapp2.0+. Some old Visual Studio 2017 can create a new application which targets netcoreapp1.0. You should upgrade it up to 2.0. If you want to target netcoreapp1.0 in your main assembly, it's recommended to create a separated project for benchmarks. Q I created a new .NET Core Console App in Visual Studio 2017. Now I want to run my code on CoreCLR, full .NET Framework, and Mono. How can I do it? A Use the following lines in your .csproj file: <TargetFrameworks>netcoreapp2.0;net46</TargetFrameworks> <PlatformTarget>AnyCPU</PlatformTarget> And mark your benchmark class with the following attributes: [CoreJob, ClrJob, MonoJob] Q My source code targets old versions of .NET Framework or .NET Core, but BenchmarkDotNet requires net461 and netcoreapp2.0 . How can I run benchmarks in this case? A It's a good practice to introduce an additional console application (e.g. MyAwesomeLibrary.Benchmarks ) which will depend on your code and BenchmarkDotNet. Due to the fact that users usually run benchmarks in a develop environment and don't distribute benchmarks for users, it shouldn't be a problem. Q I wrote a small benchmark, but BenchmarkDotNet requires a lot of time for time measurements. How can I reduce this time? A By default, BenchmarkDotNet automatically chooses a number of iterations which allows achieving the best precision. If you don't need such level of precision and just want to have a quick way to get approximated results, you can specify all parameters manually. For example, you can use the SimpleJob or ShortRunJob attributes: [SimpleJob(launchCount: 1, warmupCount: 3, targetCount: 5, invocationCount:100, id: \"QuickJob\")] [ShortRunJob] Q My benchmark unexpectedly stopped and I saw the information about error code. What can I do? A BenchmarkDotNet generates, builds and runs new process for every benchmark. This behavior is sometimes interpreted by anti-virus as dangerous, and the process is killed. Use EnvironmentAnalyser to detect antivirus software and configure your benchmark to use InProcessToolchain . Q Can I run benchmark on the virtual machine? A Yes, of course. However, it can affect results because of the shared, physical machine, virtualization process and incorrect Stopwatch.Frequency . If you are unsure whether an application is running on virtual environment, use EnvironmentAnalyser to detect VM hypervisor. Q I have failed to run my benchmarks, I am getting following errors about non-optimized dll. What can I do? Assembly BenchmarkDotNet.Samples which defines benchmarks references non-optimized BenchmarkDotNet If you own this dependency, please, build it in RELEASE. If you don't, you can create custom config with DontFailOnError to disable our custom policy and allow this b Assembly BenchmarkDotNet.Samples which defines benchmarks is non-optimized Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE. A You should always run your benchmarks in RELEASE mode with optimizations enabled (default setting for RELEASE). However if you have to use non-optimized 3rd party assembly you have to create custom config to disable our default policy. public class AllowNonOptimized : ManualConfig { public AllowNonOptimized() { Add(JitOptimizationsValidator.DontFailOnError); // ALLOW NON-OPTIMIZED DLLS Add(DefaultConfig.Instance.GetLoggers().ToArray()); // manual config has no loggers by default Add(DefaultConfig.Instance.GetExporters().ToArray()); // manual config has no exporters by default Add(DefaultConfig.Instance.GetColumnProviders().ToArray()); // manual config has no columns by default } } Q I have failed to run my benchmarks from LINQPad. How can I fix this problem? Assembly LINQPadQuery which defines benchmarks references non-optimized LINQPad Assembly LINQPadQuery which defines benchmarks is non-optimized Benchmark was built without optimization enabled (most probably a DEBUG configuration). Please, build it in RELEASE. A You need to make sure that you are using AnyCPU 5.22.05+ build of LINQPad with optimizations enabled. To enable the optimizations you need to go to Preferences -> Query and select compile with /optimize+ Q I'm trying to use RPlotExporter but there are no any images in the results folder A Try to specify R_LIBS_USER (e.g. R_LIBS_USER=/usr/local/lib/R/ on Linux/macOS, see also: #692 ) Q My benchmark failed with OutOfMemoryException. How can I fix this problem? A BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use OperationsPerInvoke , IterationSetup and IterationCleanup to do that. An example: public class OOM { private StringBuilder buffer = new StringBuilder(); [Benchmark] public void HasSideEffects() { // This method is growing the buffer to infinity // because it's executed millions of times buffer.Append('a'); } [Benchmark(OperationsPerInvoke = 16)] public void HasNoSideEffects() { buffer.Clear(); for (int i = 0; i < 1024; i++) buffer.Append('a'); } }"
  },
  "articles/features/baselines.html": {
    "href": "articles/features/baselines.html",
    "title": "Benchmark and Job Baselines | BenchmarkDotNet",
    "keywords": "Benchmark and Job Baselines In order to scale your results, you can mark a benchmark method or a job as a baseline. Let's learn this feature by examples. Sample: IntroBenchmarkBaseline You can mark a method as a baseline with the help of [Benchmark(Baseline = true)] . Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroBenchmarkBaseline { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } } Output As a result, you will have additional Ratio column in the summary table: | Method | Mean | Error | StdDev | Ratio | |-------- |----------:|----------:|----------:|------:| | Time50 | 50.46 ms | 0.0779 ms | 0.0729 ms | 0.50 | | Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms | 1.00 | | Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms | 1.50 | This column contains the mean value of the ratio distribution. For example, in the case of Time50 , we divide the first measurement of Time50 into the first measurement of Time100 (it's the baseline), the second measurement of Time50 into the second measurement of Time100 , and so on. Next, we calculate the mean of all these values and display it in the Ratio column. For Time50 , we have 0.50. The Ratio column was formerly known as Scaled . The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46 / 100.39 for Time50 ). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. In @BenchmarkDotNet.Samples.IntroRatioStdDev, you can find an example of how this value can be spoiled by outliers. Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroBenchmarkBaseline Sample: IntroRatioSD The ratio of two benchmarks is not a single number, it's a distribution. In most simple cases, the range of the ratio distribution is narrow, and BenchmarkDotNet displays a single column Ratio with the mean value. However, it also adds the RatioSD column (the standard deviation of the ratio distribution) in complex situations. In the below example, the baseline benchmark is spoiled by a single outlier Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { // Don't remove outliers [Outliers(OutlierMode.DontRemove)] // Skip jitting, pilot, warmup; measure 10 iterations [SimpleJob(RunStrategy.Monitoring, targetCount: 10, invocationCount: 1)] public class IntroRatioSD { private int counter; [GlobalSetup] public void Setup() => counter = 0; [Benchmark(Baseline = true)] public void Base() { Thread.Sleep(100); if (++counter % 7 == 0) Thread.Sleep(5000); // Emulate outlier } [Benchmark] public void Slow() => Thread.Sleep(200); [Benchmark] public void Fast() => Thread.Sleep(50); } } Output Here are statistics details for the baseline benchmark: Mean = 600.6054 ms, StdErr = 500.0012 ms (83.25%); N = 10, StdDev = 1,581.1428 ms Min = 100.2728 ms, Q1 = 100.3127 ms, Median = 100.4478 ms, Q3 = 100.5011 ms, Max = 5,100.6163 ms IQR = 0.1884 ms, LowerFence = 100.0301 ms, UpperFence = 100.7837 ms ConfidenceInterval = [-1,789.8568 ms; 2,991.0677 ms] (CI 99.9%), Margin = 2,390.4622 ms (398.01% of Mean) Skewness = 2.28, Kurtosis = 6.57, MValue = 2 -------------------- Histogram -------------------- [-541.891 ms ; 743.427 ms) | @@@@@@@@@ [ 743.427 ms ; 2027.754 ms) | [2027.754 ms ; 3312.082 ms) | [3312.082 ms ; 4458.453 ms) | [4458.453 ms ; 5742.780 ms) | @ --------------------------------------------------- As you can see, a single outlier significantly affected the metrics. Because of this, BenchmarkDotNet adds the Median and the RatioSD columns in the summary table: Method | Mean | Error | StdDev | Median | Ratio | RatioSD | ------- |----------:|--------------:|--------------:|----------:|------:|--------:| Base | 600.61 ms | 2,390.4622 ms | 1,581.1428 ms | 100.45 ms | 1.00 | 0.00 | Slow | 200.50 ms | 0.4473 ms | 0.2959 ms | 200.42 ms | 1.80 | 0.62 | Fast | 50.54 ms | 0.3435 ms | 0.2272 ms | 50.48 ms | 0.45 | 0.16 | Let's look at the Base and Slow benchmarks. The Mean values are 600 and 200 milliseconds; the \"Scaled Mean\" value is 0.3. The Median values are 100 and 200 milliseconds; the \"Scaled Median\" value is 2. Both values are misleading. BenchmarkDotNet evaluates the ratio distribution and displays the mean (1.80) and the standard deviation (0.62). Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroRatioSD Sample: IntroCategoryBaseline The only way to have several baselines in the same class is to separate them by categories and mark the class with [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] . Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; namespace BenchmarkDotNet.Samples { [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] [CategoriesColumn] public class IntroCategoryBaseline { [BenchmarkCategory(\"Fast\"), Benchmark(Baseline = true)] public void Time50() => Thread.Sleep(50); [BenchmarkCategory(\"Fast\"), Benchmark] public void Time100() => Thread.Sleep(100); [BenchmarkCategory(\"Slow\"), Benchmark(Baseline = true)] public void Time550() => Thread.Sleep(550); [BenchmarkCategory(\"Slow\"), Benchmark] public void Time600() => Thread.Sleep(600); } } Output | Method | Categories | Mean | Error | StdDev | Ratio | |-------- |----------- |----------:|----------:|----------:|------:| | Time50 | Fast | 50.46 ms | 0.0745 ms | 0.0697 ms | 1.00 | | Time100 | Fast | 100.47 ms | 0.0955 ms | 0.0893 ms | 1.99 | | | | | | | | | Time550 | Slow | 550.48 ms | 0.0525 ms | 0.0492 ms | 1.00 | | Time600 | Slow | 600.45 ms | 0.0396 ms | 0.0331 ms | 1.09 | Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroCategoryBaseline Sample: IntroJobBaseline If you want to compare several runtime configuration, you can mark one of your jobs with baseline = true . Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(runtimeMoniker: RuntimeMoniker.Net461, baseline: true)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Mono)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Net50)] public class IntroJobBaseline { [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Output BenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192) Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8 Frequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC .NET Core SDK=2.0.3 [Host] : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Job-MXFYPZ : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0 Core : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Mono : Mono 5.4.0 (Visual Studio), 64bit Method | Runtime | Mean | Error | StdDev | Ratio | RatioSD | ---------- |-------- |---------:|----------:|----------:|------:|--------:| SplitJoin | Clr | 19.42 us | 0.2447 us | 0.1910 us | 1.00 | 0.00 | SplitJoin | Core | 13.00 us | 0.2183 us | 0.1935 us | 0.67 | 0.01 | SplitJoin | Mono | 39.14 us | 0.7763 us | 1.3596 us | 2.02 | 0.07 | Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroJobBaseline"
  },
  "articles/features/disassembler.html": {
    "href": "articles/features/disassembler.html",
    "title": "Disassembler | BenchmarkDotNet",
    "keywords": "Disassembler Can be enabled by using [DisassemblyDiagnoser] or command line args: -d or --disasm . The configuration options available from code level are: maxDepth : Includes called methods to given level. 1 by default, indexed from 1. To print just the benchmark set it to 0. This option is also available from the console arguments level --disasmDepth . printSource : C#|F#|VB source code will be printed. False by default. printInstructionAddresses : Print instruction addresses. False by default. exportGithubMarkdown : Exports to GitHub markdown. True by default. exportHtml : Exports to HTML with clickable links. False by default. exportCombinedDisassemblyReport : Exports all benchmarks to a single HTML report. Makes it easy to compare different runtimes or methods (each becomes a column in HTML table). exportDiff : Exports a diff of the assembly code to the Github markdown format. False by default. Requirements Disassembly Diagnoser requires following settings in your .csproj file: <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> </PropertyGroup> To get the source code we need to locate and read the .pdb files. This is why we need DebugType and DebugSymbols settings. To compare different platforms the project which defines benchmarks has to target AnyCPU . Disassembly Diagnoser for Mono on Windows If you want to get a disassembly listing for Mono on Windows, you need as and x86_64-w64-mingw32-objdump.exe tools. If you don't have it, you will get a warning like follows: It's impossible to get Mono disasm because you don't have some required tools: 'as' is not recognized as an internal or external command 'x86_64-w64-mingw32-objdump.exe' is not recognized as an internal or external command The easiest way to get these tools: Download and install Cygwin On the \"Select Packages\" screen, search for binutils Install binutils and mingw64-x86_64-binutils Add cygwin64\\bin\\ (or cygwin\\bin\\ ) in %PATH% Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassembly Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyRyuJit Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU . <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net461)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net461)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net461)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here . The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyAllJits Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once . Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyDry"
  },
  "articles/features/etwprofiler.html": {
    "href": "articles/features/etwprofiler.html",
    "title": "EtwProfiler | BenchmarkDotNet",
    "keywords": "EtwProfiler EtwProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with PerfView or Windows Performance Analyzer . How it works EtwProfiler uses TraceEvent library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events. Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one. Limitations What we have today comes with following limitations: EtwProfiler works only on Windows (one day we might implement similar thing for Unix using EventPipe) Requires to run as Admin (to create ETW Kernel Session) No InProcessToolchain support To get the best possible managed code symbols you should configure your project in following way: <DebugType>pdbonly</DebugType> <DebugSymbols>true</DebugSymbols> How to use it? You need to install BenchmarkDotNet.Diagnostics.Windows package. It can be enabled in few ways, some of them: Use the new attribute (apply it on a class that contains Benchmarks): using BenchmarkDotNet.Diagnostics.Windows.Configs; [EtwProfiler] public class TheClassThatContainsBenchmarks { /* benchmarks go here */ } Extend the DefaultConfig.Instance with new instance of EtwProfiler : class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, DefaultConfig.Instance .AddDiagnoser(new EtwProfiler())); // HERE } Passing -p ETW or --profiler ETW command line argument to BenchmarkSwitcher Configuration To configure the new diagnoser you need to create an instance of EtwProfilerConfig class and pass it to the EtwProfiler constructor. The parameters that EtwProfilerConfig ctor takes are: performExtraBenchmarksRun - if set to true, benchmarks will be executed one more time with the profiler attached. If set to false, there will be no extra run but the results will contain overhead. True by default. bufferSizeInMb - ETW session buffer size, in MB. 256 by default. intervalSelectors - interval per hardware counter, if not provided then default values will be used. kernelKeywords - kernel session keywords, ImageLoad (for native stack frames) and Profile (for CPU Stacks) are the defaults. providers - providers that should be enabled, if not provided then default values will be used. Using PerfView to work with trace files PerfView is a free .NET profiler from Microsoft. If you don't know how to use it you should watch these instructional videos first. If you are familiar with PerfView, then the only thing you need to know is that BenchmarkDotNet performs Jitting by running the code once, Pilot Experiment to determine how many times benchmark should be executed per iteration, non-trivial Warmup and Actual Workload. This is why when you open your trace file in PerfView you will see your benchmark in a few different places of the StackTrace. The simplest way to filter the data to the actual benchmarks runs is to open the CallTree tab, put \"EngineActualStage\" in the Find box, press enter and when PerfView selects EngineActualStage in the CallTree press Alt+R to Set Time Range. If you want to filter the trace to single iteration, then you must go to the Events panel and search for the WorkloadActual/Start and WorkloadActual/Stop events. Open Events window Put \"WorkloadActual\" in the Filter box and hit enter. Press control or shift and choose the Start and Stop events from the left panel. Hit enter. Choose iteration that you want to investigate (events are sorted by time). Select two or more cells from the \"Time MSec\" column. Right click, choose \"Open Cpu Stacks\". Choose the process with benchmarks, right-click, choose \"Drill Into\""
  },
  "articles/features/event-pipe-profiler.html": {
    "href": "articles/features/event-pipe-profiler.html",
    "title": "EventPipeProfiler | BenchmarkDotNet",
    "keywords": "EventPipeProfiler EventPipeProfiler is a cross-platform profiler that allows profile .NET code on every platform - Windows, Linux, macOS. Collected data are exported to trace files ( .speedscope.json and .nettrace ) which can be analyzed using SpeedScope , PerfView , and Visual Studio Profiler . This new profiler is available from the 0.12.1 version. Configuration EventPipeProfiler can be enabled in three ways: Using parameter -p EP or --profiler EP from the console line. Marking the benchmarked class with [EventPipeProfiler(...)] attribute. You can find an example below. Using a custom configuration. You can find an example below. Sample: EventPipeProfiler The EventPipeProfiler can be enabled using the [EventPipeProfiler(...)] attribute. This attribute takes the following profiles: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [ShortRunJob] [EventPipeProfiler(EventPipeProfile.CpuSampling)] public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope . // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfiler.Sleep-20200406-090113.speedscope.json Sample: EventPipeProfilerAdvanced The most advanced and powerful way to use EventPipeProfiler is a custom configuration. As you can see the below configuration adds EventPipeProfiler that constructor can take the profile and/or a list of providers. Both EventPipeProfiler and dotnet trace use the Microsoft.Diagnostics.NETCore.Client package internally. So before you start using the custom configuration of this profiler, it is worth reading the documentation here and here where you can find more information about how to configure provider list. Source code using System.Buffers; using System.Diagnostics.Tracing; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using Microsoft.Diagnostics.NETCore.Client; using Microsoft.Diagnostics.Tracing.Parsers; namespace BenchmarkDotNet.Samples { [Config(typeof(CustomConfig))] public class IntroEventPipeProfilerAdvanced { private class CustomConfig : ManualConfig { public CustomConfig() { AddJob(Job.ShortRun.WithRuntime(CoreRuntime.Core50)); var providers = new[] { new EventPipeProvider(ClrTraceEventParser.ProviderName, EventLevel.Verbose, (long) (ClrTraceEventParser.Keywords.Exception | ClrTraceEventParser.Keywords.GC | ClrTraceEventParser.Keywords.Jit | ClrTraceEventParser.Keywords.JitTracing // for the inlining events | ClrTraceEventParser.Keywords.Loader | ClrTraceEventParser.Keywords.NGen)), new EventPipeProvider(\"System.Buffers.ArrayPoolEventSource\", EventLevel.Informational, long.MaxValue), }; AddDiagnoser(new EventPipeProfiler(providers: providers)); } } [Benchmark] public void RentAndReturn_Shared() { var pool = ArrayPool<byte>.Shared; byte[] array = pool.Rent(10000); pool.Return(array); } } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope . // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfilerAdvanced.RentAndReturn_Shared-20200406-090136.speedscope.json"
  },
  "articles/features/parameterization.html": {
    "href": "articles/features/parameterization.html",
    "title": "Parameterization | BenchmarkDotNet",
    "keywords": "Parameterization Sample: IntroParams You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you can specify set of values. Every value must be a compile-time constant. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | A | B | Mean | Error | StdDev | |---------- |---- |--- |---------:|--------:|--------:| | Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms | | Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms | | Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms | Links Parameterization The permanent link to this sample: Sample: IntroParams Sample: IntroParamsSource In case you want to use a lot of values, you should use [ParamsSource] You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable ). The source must be within benchmarked type! Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsSource { // property with public setter [ParamsSource(nameof(ValuesForA))] public int A { get; set; } // public field [ParamsSource(nameof(ValuesForB))] public int B; // public property public IEnumerable<int> ValuesForA => new[] { 100, 200 }; // public static method public static IEnumerable<int> ValuesForB() => new[] { 10, 20 }; [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms | | Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms | | Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms | Remarks A remark about IParam. You don't need to use IParam anymore since 0.11.0 . Just use complex types as you wish and override ToString method to change the display names used in the results. Links Parameterization The permanent link to this sample: Sample: IntroParamsSource Sample: IntroParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T> , where T is an enum or boolean Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [DryJob] public class IntroParamsAllValues { public enum CustomEnum { One = 1, Two, Three } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( (int)E * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } } Output Method | E | B | Mean | Error | ---------- |------ |------ |---------:|------:| Benchmark | One | ? | 101.4 ms | NA | Benchmark | One | False | 111.1 ms | NA | Benchmark | One | True | 122.0 ms | NA | Benchmark | Two | ? | 201.3 ms | NA | Benchmark | Two | False | 212.1 ms | NA | Benchmark | Two | True | 221.3 ms | NA | Benchmark | Three | ? | 301.4 ms | NA | Benchmark | Three | False | 311.5 ms | NA | Benchmark | Three | True | 320.8 ms | NA | Links Parameterization The permanent link to this sample: Sample: IntroParamsAllValues Sample: IntroParamsPriority In order to sort columns of parameters in the results table you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue] , lower priorites will appear earlier in the column order. The default priority is set to 0 . Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: Sample: IntroParamsPriority Sample: IntroArguments As an alternative to using [Params] , you can specify arguments for your benchmarks. There are several ways to do it (described below). The [Arguments] allows you to provide a set of values. Every value must be a compile-time constant (it's C# language limitation for attributes in general). You can also combine [Arguments] with [Params] . As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArguments { [Params(true, false)] // Arguments can be combined with Params public bool AddExtra5Milliseconds; [Benchmark] [Arguments(100, 10)] [Arguments(100, 20)] [Arguments(200, 10)] [Arguments(200, 20)] public void Benchmark(int a, int b) { if (AddExtra5Milliseconds) Thread.Sleep(a + b + 5); else Thread.Sleep(a + b); } } } Output | Method | AddExtra5Miliseconds | a | b | Mean | Error | StdDev | |---------- |--------------------- |---- |--- |---------:|----------:|----------:| | Benchmark | False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms | | Benchmark | False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms | | Benchmark | False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms | | Benchmark | False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms | | Benchmark | True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms | | Benchmark | True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms | | Benchmark | True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms | | Benchmark | True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms | Links Parameterization The permanent link to this sample: Sample: IntroArguments Sample: IntroArgumentsSource In case you want to use a lot of values, you should use [ArgumentsSource] . You can mark one or several fields or properties in your class by the [ArgumentsSource] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable ). The source must be within benchmarked type! Source code using System; using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsSource { [Benchmark] [ArgumentsSource(nameof(Numbers))] public double ManyArguments(double x, double y) => Math.Pow(x, y); public IEnumerable<object[]> Numbers() // for multiple arguments it's an IEnumerable of array of objects (object[]) { yield return new object[] { 1.0, 1.0 }; yield return new object[] { 2.0, 2.0 }; yield return new object[] { 4.0, 4.0 }; yield return new object[] { 10.0, 10.0 }; } [Benchmark] [ArgumentsSource(nameof(TimeSpans))] public void SingleArgument(TimeSpan time) => Thread.Sleep(time); public IEnumerable<object> TimeSpans() // for single argument it's an IEnumerable of objects (object) { yield return TimeSpan.FromMilliseconds(10); yield return TimeSpan.FromMilliseconds(100); } } } Output | Method | x | y | Mean | Error | StdDev | |------- |--- |--- |----------:|----------:|----------:| | Pow | 1 | 1 | 9.360 ns | 0.0190 ns | 0.0149 ns | | Pow | 2 | 2 | 40.624 ns | 0.3413 ns | 0.3192 ns | | Pow | 4 | 4 | 40.537 ns | 0.0560 ns | 0.0524 ns | | Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns | Another example If the values are complex types you need to override ToString method to change the display names used in the results. [DryJob] public class WithNonPrimitiveArgumentsSource { [Benchmark] [ArgumentsSource(nameof(NonPrimitive))] public void Simple(SomeClass someClass, SomeStruct someStruct) { for (int i = 0; i < someStruct.RangeEnd; i++) Console.WriteLine($\"// array.Values[{i}] = {someClass.Values[i]}\"); } public IEnumerable<object[]> NonPrimitive() { yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) }; yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) }; } public class SomeClass { public SomeClass(int[] initialValues) => Values = initialValues.Select(val => val * 2).ToArray(); public int[] Values { get; } public override string ToString() => $\"{Values.Length} items\"; } public struct SomeStruct { public SomeStruct(int rangeEnd) => RangeEnd = rangeEnd; public int RangeEnd { get; } public override string ToString() => $\"{RangeEnd}\"; } } | Method | someClass | someStruct | Mean | Error | |------- |---------- |----------- |---------:|------:| | Simple | 10 items | 10 | 887.2 us | NA | | Simple | 15 items | 15 | 963.1 us | NA | Links Parameterization The permanent link to this sample: Sample: IntroArgumentsSource Sample: IntroArrayParam Warning The cost of creating the arguments is not included in the benchmark. So if you want to pass an array as an argument, we are going to allocate it before running the benchmark, and the benchmark will not include this operation. Source code using System; using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArrayParam { [Benchmark] [ArgumentsSource(nameof(Data))] public int ArrayIndexOf(int[] array, int value) => Array.IndexOf(array, value); [Benchmark] [ArgumentsSource(nameof(Data))] public int ManualIndexOf(int[] array, int value) { for (int i = 0; i < array.Length; i++) if (array[i] == value) return i; return -1; } public IEnumerable<object[]> Data() { yield return new object[] { new int[] { 1, 2, 3 }, 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 101 }; } } } Output | Method | array | value | Mean | Error | StdDev | Allocated | |-------------- |----------- |------ |----------:|----------:|----------:|----------:| | ArrayIndexOf | Array[100] | 4 | 15.558 ns | 0.0638 ns | 0.0597 ns | 0 B | | ManualIndexOf | Array[100] | 4 | 5.345 ns | 0.0668 ns | 0.0625 ns | 0 B | | ArrayIndexOf | Array[3] | 4 | 14.334 ns | 0.1758 ns | 0.1558 ns | 0 B | | ManualIndexOf | Array[3] | 4 | 2.758 ns | 0.0905 ns | 0.1208 ns | 0 B | | ArrayIndexOf | Array[100] | 101 | 78.359 ns | 1.8853 ns | 2.0955 ns | 0 B | | ManualIndexOf | Array[100] | 101 | 80.421 ns | 0.6391 ns | 0.5978 ns | 0 B | Links Parameterization The permanent link to this sample: Sample: IntroArrayParam Sample: IntroArgumentsPriority Like Params also Argument columns can be sorted in the table result through their Priority . The priority should be defined only once for multiple Arguments and will keep their inner order as they are defined in the method. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsPriority { [Params(100, Priority = 0)] // Argument priority can be combined with Params priority public int A { get; set; } [Arguments(5, Priority = -10)] // Define priority just once for multiple argument attributes [Arguments(10)] [Arguments(20)] [Benchmark] public void Benchmark(int b) => Thread.Sleep(A + b); [Benchmark] [ArgumentsSource(nameof(Numbers), Priority = 10)] public void ManyArguments(int c, int d) => Thread.Sleep(A + c + d); public IEnumerable<object[]> Numbers() { yield return new object[] { 1, 2 }; } } } Output | Method | b | A | c | d | Mean | Error | StdDev | |-------------- |--- |---- |-- |-- |---------:|--------:|--------:| | ManyArguments | ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms | | Benchmark | 5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms | | Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms | | Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: Sample: IntroArgumentsPriority"
  },
  "articles/features/setup-and-cleanup.html": {
    "href": "articles/features/setup-and-cleanup.html",
    "title": "Setup And Cleanup | BenchmarkDotNet",
    "keywords": "Setup And Cleanup Sometimes we want to write some logic which should be executed before or after a benchmark, but we don't want to measure it. For this purpose, BenchmarkDotNet provides a set of attributes: [GlobalSetup] , [GlobalCleanup] , [IterationSetup] , [IterationCleanup] . Sample: IntroSetupCleanupGlobal A method which is marked by the [GlobalSetup] attribute will be executed only once per a benchmarked method after initialization of benchmark parameters and before all the benchmark method invocations. A method which is marked by the [GlobalCleanup] attribute will be executed only once per a benchmarked method after all the benchmark method invocations. If you are using some unmanaged resources (e.g., which were created in the GlobalSetup method), they can be disposed in the GlobalCleanup method. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroSetupCleanupGlobal { [Params(10, 100, 1000)] public int N; private int[] data; [GlobalSetup] public void GlobalSetup() { data = new int[N]; // executed once per each N value } [Benchmark] public int Logic() { int res = 0; for (int i = 0; i < N; i++) res += data[i]; return res; } [GlobalCleanup] public void GlobalCleanup() { // Disposing logic } } } Links Setup And Cleanup The permanent link to this sample: Sample: IntroSetupCleanupGlobal Sample: IntroSetupCleanupIteration A method which is marked by the [IterationSetup] attribute will be executed exactly once before each benchmark invocation (we have changed that in 0.11.0). It's not recommended to use this attribute in microbenchmarks because it can spoil the results. However, if you are writing a macrobenchmark (e.g. a benchmark which takes at least 100ms) and you want to prepare some data before each invocation, [IterationSetup] can be useful. A method which is marked by the [IterationCleanup] attribute will be executed exactly once after each invocation . This attribute has the same set of constraint with [IterationSetup] : it's not recommended to use [IterationCleanup] in microbenchmarks. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 1, warmupCount: 2, targetCount: 3)] public class IntroSetupCleanupIteration { private int setupCounter; private int cleanupCounter; [IterationSetup] public void IterationSetup() => Console.WriteLine($\"// IterationSetup ({++setupCounter})\"); [IterationCleanup] public void IterationCleanup() => Console.WriteLine($\"// IterationCleanup ({++cleanupCounter})\"); [GlobalSetup] public void GlobalSetup() => Console.WriteLine(\"// \" + \"GlobalSetup\"); [GlobalCleanup] public void GlobalCleanup() => Console.WriteLine(\"// \" + \"GlobalCleanup\"); [Benchmark] public void Benchmark() => Console.WriteLine(\"// \" + \"Benchmark\"); } } The order of method calls // GlobalSetup // IterationSetup (1) // IterationSetup Jitting // IterationCleanup (1) // IterationCleanup Jitting // IterationSetup (2) // MainWarmup1 // Benchmark // MainWarmup1 // IterationCleanup (2) // MainWarmup1 // IterationSetup (3) // MainWarmup2 // Benchmark // MainWarmup2 // IterationCleanup (3) // MainWarmup2 // IterationSetup (4) // MainTarget1 // Benchmark // MainTarget1 // IterationCleanup (4) // MainTarget1 // IterationSetup (5) // MainTarget2 // Benchmark // MainTarget2 // IterationCleanup (5) // MainTarget2 // IterationSetup (6) // MainTarget3 // Benchmark // MainTarget3 // IterationCleanup (6) // MainTarget3 // GlobalCleanup Links Setup And Cleanup The permanent link to this sample: Sample: IntroSetupCleanupIteration Sample: IntroSetupCleanupTarget Sometimes it's useful to run setup or cleanups for specific benchmarks. All four setup and cleanup attributes have a Target property that allow the setup/cleanup method to be run for one or more specific benchmark methods. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 0, warmupCount: 0, targetCount: 1)] public class IntroSetupCleanupTarget { [GlobalSetup(Target = nameof(BenchmarkA))] public void GlobalSetupA() => Console.WriteLine(\"// \" + \"GlobalSetup A\"); [Benchmark] public void BenchmarkA() => Console.WriteLine(\"// \" + \"Benchmark A\"); [GlobalSetup(Targets = new[] { nameof(BenchmarkB), nameof(BenchmarkC) })] public void GlobalSetupB() => Console.WriteLine(\"// \" + \"GlobalSetup B\"); [Benchmark] public void BenchmarkB() => Console.WriteLine(\"// \" + \"Benchmark B\"); [Benchmark] public void BenchmarkC() => Console.WriteLine(\"// \" + \"Benchmark C\"); [Benchmark] public void BenchmarkD() => Console.WriteLine(\"// \" + \"Benchmark D\"); } } The order of method calls // GlobalSetup A // Benchmark A // GlobalSetup B // Benchmark B // GlobalSetup B // Benchmark C // Benchmark D Links Setup And Cleanup The permanent link to this sample: Sample: IntroSetupCleanupTarget"
  },
  "articles/features/statistics.html": {
    "href": "articles/features/statistics.html",
    "title": "Statistics | BenchmarkDotNet",
    "keywords": "Statistics Sample: IntroStatisticsColumns Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [MediumRunJob, SkewnessColumn, KurtosisColumn] public class IntroStatisticsColumns { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public IntroStatisticsColumns() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5A() => md5.ComputeHash(data); [Benchmark] public byte[] Md5B() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } } Output Method Mean Error StdDev Skewness Kurtosis Ratio RatioSD Md5A 15.91 us 0.0807 us 0.1209 us 0.4067 1.646 1.00 0.00 Md5B 15.89 us 0.0709 us 0.1062 us 0.5893 2.141 1.00 0.01 Sha256 36.62 us 0.6390 us 0.9564 us 1.1363 4.014 2.30 0.06 Links Statistics The permanent link to this sample: Sample: IntroStatisticsColumns Sample: IntroPercentiles The percentile represents a higher boundary for specified percentage of the measurements. For example, 95th percentile = 500ms means that 95% of all samples are not slower than 500ms. This metric is not very useful in microbenchmarks, as the values from consequent runs have a very narrow distribution. However, real-world scenarios often have so-called long tail distribution (due to IO delays, locks, memory access latency and so on), so the average execution time cannot be trusted. The percentiles allow to include the tail of distribution into the comparison. However, it requires some preparations steps. At first, you should have enough runs to count percentiles from. The TargetCount in the config should be set to 10-20 runs at least. Second, the count of iterations for each run should not be very high, or the peak timings will be averaged. The IterationTime = 25 works fine for most cases; for long-running benchmarks the Mode = Mode.SingleRun will be the best choice. However, feel free to experiment with the config values. Third, if you want to be sure that measurements are repeatable, set the LaunchCount to 3 or higher. And last, don't forget to include the columns into the config. They are not included by default (as said above, these are not too useful for most of the benchmarks). There're predefined StatisticColumn.P0 .. StatisticColumn.P100 for absolute timing percentiles. Example Run the IntroPercentiles sample. It contains three benchmark methods. First delays for 20 ms constantly. The second has random delays for 10..30 ms. And the third delays for 10ms 85 times of 100 and delays for 40ms 15 times of 100. Here's the output from the benchmark (some columns removed for brevity): Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.3813 ms 0.2051 ms 1.00 20.0272 ms 20.3813 ms 20.4895 ms 20.4954 ms 20.5869 ms 21.1471 ms RandomDelays 19.8055 ms 5.7556 ms 0.97 10.0793 ms 19.8055 ms 25.4173 ms 26.5187 ms 29.0313 ms 29.4550 ms RareDelays 10.3385 ms 11.4828 ms 0.51 10.0157 ms 10.3385 ms 10.5211 ms 40.0560 ms 40.3992 ms 40.4674 ms Also, it's very easy to screw the results with incorrect setup. For example, the same code being run with new Job { TargetCount = 5, IterationTime = 500 } completely hides the peak values: Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.2692 ms 0.0308 ms 1.00 20.1986 ms 20.2692 ms 20.2843 ms 20.2968 ms 20.3097 ms 20.3122 ms RandomDelays 18.9965 ms 0.8601 ms 0.94 18.1339 ms 18.9965 ms 19.8126 ms 19.8278 ms 20.4485 ms 20.9466 ms RareDelays 14.0912 ms 2.8619 ms 0.70 10.2606 ms 14.0912 ms 15.7653 ms 17.3862 ms 18.6728 ms 18.6940 ms Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { // Using percentiles for adequate timings representation [Config(typeof(Config))] [SimpleJob(RunStrategy.ColdStart, launchCount: 4, warmupCount: 3, targetCount: 20, id: \"MyJob\")] public class IntroPercentiles { // To share between runs. // DO NOT do this in production code. The System.Random IS NOT thread safe. private static readonly Random Rnd = new Random(); private class Config : ManualConfig { public Config() { AddColumn( StatisticColumn.P0, StatisticColumn.P25, StatisticColumn.P50, StatisticColumn.P67, StatisticColumn.P80, StatisticColumn.P85, StatisticColumn.P90, StatisticColumn.P95, StatisticColumn.P100); } } [Benchmark(Baseline = true)] public void ConstantDelays() => Thread.Sleep(20); [Benchmark] public void RandomDelays() => Thread.Sleep(10 + (int) (20 * Rnd.NextDouble())); [Benchmark] public void RareDelays() { int rndTime = 10; // Bigger delays for 15% of the runs if (Rnd.NextDouble() > 0.85) { rndTime += 30; } Thread.Sleep(rndTime); } } } Links Statistics The permanent link to this sample: Sample: IntroPercentiles Sample: IntroRankColumn Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Mathematics; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [ShortRunJob] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [RankColumn(NumeralSystem.Arabic)] [RankColumn(NumeralSystem.Roman)] [RankColumn(NumeralSystem.Stars)] public class IntroRankColumn { [Params(1, 2)] public int Factor; [Benchmark] public void Foo() => Thread.Sleep(Factor * 100); [Benchmark] public void Bar() => Thread.Sleep(Factor * 200); } } Output Method | Factor | Mean | Error | StdDev | Rank | Rank | Rank | ------- |------- |---------:|---------:|----------:|-----:|-----:|-----:| Foo | 1 | 100.8 ms | 2.250 ms | 0.1272 ms | 1 | I | * | Foo | 2 | 200.8 ms | 4.674 ms | 0.2641 ms | 2 | II | ** | Bar | 1 | 200.9 ms | 2.012 ms | 0.1137 ms | 2 | II | ** | Bar | 2 | 400.7 ms | 4.509 ms | 0.2548 ms | 3 | III | *** | Links Statistics The permanent link to this sample: Sample: IntroRankColumn Sample: IntroMultimodal Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [MValueColumn] [SimpleJob(RunStrategy.Throughput, 1, 0, -1, 1, \"MyJob\")] public class IntroMultimodal { private readonly Random rnd = new Random(42); private void Multimodal(int n) => Thread.Sleep((rnd.Next(n) + 1) * 100); [Benchmark] public void Unimodal() => Multimodal(1); [Benchmark] public void Bimodal() => Multimodal(2); [Benchmark] public void Trimodal() => Multimodal(3); [Benchmark] public void Quadrimodal() => Multimodal(4); } } Output Method | Mean | Error | StdDev | Median | MValue | ------------ |---------:|-----------:|------------:|---------:|-------:| Unimodal | 100.5 ms | 0.0713 ms | 0.0667 ms | 100.5 ms | 2.000 | Bimodal | 144.5 ms | 16.9165 ms | 49.8787 ms | 100.6 ms | 3.571 | Trimodal | 182.5 ms | 27.4285 ms | 80.8734 ms | 200.5 ms | 4.651 | Quadrimodal | 226.6 ms | 37.2269 ms | 109.7644 ms | 200.7 ms | 5.882 | // * Warnings * MultimodalDistribution IntroMultimodal.Bimodal: MainJob -> It seems that the distribution is bimodal (mValue = 3.57) IntroMultimodal.Trimodal: MainJob -> It seems that the distribution is multimodal (mValue = 4.65) IntroMultimodal.Quadrimodal: MainJob -> It seems that the distribution is multimodal (mValue = 5.88) Links Statistics The permanent link to this sample: Sample: IntroMultimodal Sample: IntroOutliers Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroOutliers { private class Config : ManualConfig { public Config() { var jobBase = Job.Default.WithWarmupCount(0).WithIterationCount(10).WithInvocationCount(1).WithUnrollFactor(1); AddJob(jobBase.WithOutlierMode(OutlierMode.DontRemove).WithId(\"DontRemoveOutliers\")); AddJob(jobBase.WithOutlierMode(OutlierMode.RemoveUpper).WithId(\"RemoveUpperOutliers\")); } } private int counter; [Benchmark] public void Foo() { counter++; int noise = counter % 10 == 0 ? 500 : 0; Thread.Sleep(100 + noise); } } } Output Method | Job | OutlierMode | Mean | Error | StdDev | ------- |-------------------- |------------ |---------:|------------:|------------:| Foo | DontRemoveOutliers | DontRemove | 150.5 ms | 239.1911 ms | 158.2101 ms | Foo | RemoveUpperOutliers | RemoveUpper | 100.5 ms | 0.1931 ms | 0.1149 ms | // * Hints * Outliers IntroOutliers.Foo: DontRemoveOutliers -> 1 outlier was detected IntroOutliers.Foo: RemoveUpperOutliers -> 1 outlier was removed Links Statistics The permanent link to this sample: Sample: IntroOutliers"
  },
  "articles/guides/choosing-run-strategy.html": {
    "href": "articles/guides/choosing-run-strategy.html",
    "title": "Choosing RunStrategy | BenchmarkDotNet",
    "keywords": "Choosing RunStrategy If you run a benchmark, you always (explicitly or implicitly) use a job . Each Job has the RunStrategy parameter which allows switching between different benchmark modes. The default RunStrategy is Throughput , and it works fine for most cases. However, other strategies are also useful in some specific cases. Throughput Throughput is the default RunStrategy , works perfectly for microbenchmarking. It's automatically choosing the amount of operation in main iterations based on a set of pilot iterations. The amount of iterations will also be chosen automatically based on accuracy job settings. A benchmark method should have a steady state. Of course, you can manually set all the characteristics. An example: [SimpleJob(launchCount: 3, warmupCount: 10, targetCount: 30)] public class MyBenchmarkClass Sample: IntroColdStart If you want to measure cold start (without the pilot and warmup stage), the ColdStart strategy is your choice. Usage [SimpleJob(RunStrategy.ColdStart, launchCount:50)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.ColdStart, targetCount: 5)] [MinColumn, MaxColumn, MeanColumn, MedianColumn] public class IntroColdStart { private bool firstCall; [Benchmark] public void Foo() { if (firstCall == false) { firstCall = true; Console.WriteLine(\"// First call\"); Thread.Sleep(1000); } else Thread.Sleep(10); } } } Output Result 1: 1 op, 1002034900.00 ns, 1.0020 s/op Result 2: 1 op, 10219700.00 ns, 10.2197 ms/op Result 3: 1 op, 10406200.00 ns, 10.4062 ms/op Result 4: 1 op, 10473900.00 ns, 10.4739 ms/op Result 5: 1 op, 10449400.00 ns, 10.4494 ms/op Method | Mean | Error | StdDev | Min | Max | Median | ------- |---------:|-----------:|---------:|---------:|-----------:|---------:| Foo | 208.7 ms | 1,707.4 ms | 443.5 ms | 10.22 ms | 1,002.0 ms | 10.45 ms | Links Choosing RunStrategy The permanent link to this sample: Sample: IntroColdStart Sample: IntroMonitoring If a benchmark method takes at least 100ms, you can also use the Monitoring strategy. In this case, the pilot stage will be omitted, by default you get 1 iteration = 1 operation (or you can manually set amount of operation in an iteration). Also you can use [IterationSetup] and [IterationCleanup] in this case: it shouldn't affect time measurements (but it can affect results of MemoryDiagnoser). It's a perfect mode for benchmarks which doesn't have a steady state and the performance distribution is tricky: Monitoring will help you to collect a set of measurements and get statistics. Usage [SimpleJob(RunStrategy.Monitoring, launchCount: 10, warmupCount: 0, targetCount: 100)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, targetCount: 10, id: \"MonitoringJob\")] [MinColumn, Q1Column, Q3Column, MaxColumn] public class IntroMonitoring { private Random random = new Random(42); [Benchmark] public void Foo() { Thread.Sleep(random.Next(10) * 10); } } } Output Result 1: 1 op, 61552600.00 ns, 61.5526 ms/op Result 2: 1 op, 10141700.00 ns, 10.1417 ms/op Result 3: 1 op, 10482900.00 ns, 10.4829 ms/op Result 4: 1 op, 50410900.00 ns, 50.4109 ms/op Result 5: 1 op, 10421400.00 ns, 10.4214 ms/op Result 6: 1 op, 20556100.00 ns, 20.5561 ms/op Result 7: 1 op, 70473200.00 ns, 70.4732 ms/op Result 8: 1 op, 50581700.00 ns, 50.5817 ms/op Result 9: 1 op, 10559000.00 ns, 10.5590 ms/op Result 10: 1 op, 70496300.00 ns, 70.4963 ms/op Method Mean Error StdDev Min Q1 Q3 Max Foo 36.57 ms 40.03 ms 26.47 ms 10.14 ms 10.48 ms 61.55 ms 70.50 ms Links Choosing RunStrategy The permanent link to this sample: Sample: IntroMonitoring"
  },
  "articles/guides/console-args.html": {
    "href": "articles/guides/console-args.html",
    "title": "How to use console arguments | BenchmarkDotNet",
    "keywords": "How to use console arguments BenchmarkSwitcher supports various console arguments, to make it work you need to pass the args to switcher: class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } Note: the docs that you are currently reading might get outdated, to get the most up-to-date info about supported console arguments run the benchmarks with --help . Filter The --filter or just -f allows you to filter the benchmarks by their full name ( namespace.typeName.methodName ) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Note : If you would like to join all the results into a single summary , you need to put --join . For example: -f *ClassA* *ClassB* --join List of benchmarks The --list allows you to print all of the available benchmark names. Available options are: flat - prints list of the available benchmarks: --list flat BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5 BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256 BenchmarkDotNet.Samples.IntroArguments.Benchmark BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf BenchmarkDotNet.Samples.IntroBasic.Sleep [...] tree - prints tree of the available benchmarks: --list tree BenchmarkDotNet └─Samples ├─Algo_Md5VsSha256 │ ├─Md5 │ └─Sha256 ├─IntroArguments │ └─Benchmark ├─IntroArgumentsSource │ ├─SingleArgument │ └─ManyArguments ├─IntroArrayParam │ ├─ArrayIndexOf │ └─ManualIndexOf ├─IntroBasic │ ├─Sleep [...] The --list option works with the --filter option. Examples: --list flat --filter *IntroSetupCleanup* prints: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD --list tree --filter *IntroSetupCleanup* prints: BenchmarkDotNet └─Samples ├─IntroSetupCleanupGlobal │ └─Logic ├─IntroSetupCleanupIteration │ └─Benchmark └─IntroSetupCleanupTarget ├─BenchmarkA ├─BenchmarkB ├─BenchmarkC └─BenchmarkD Categories You can also filter the benchmarks by categories: --anyCategories - runs all benchmarks that belong to any of the provided categories --allCategories - runs all benchmarks that belong to all provided categories Diagnosers -m , --memory - enables MemoryDiagnoser and prints memory statistics -t , --threading - enables ThreadingDiagnoser and prints threading statistics -d , --disasm - enables DisassemblyDiagnoser and exports diassembly of benchmarked code. When you enable this option, you can use: --disasmDepth - Sets the recursive depth for the disassembler. --disasmDiff - Generates diff reports for the disassembler. Runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Clr - BDN will either use Roslyn (if you run it as .NET app) or latest installed .NET SDK to build the benchmarks (if you run it as .NET Core app) Core - if you run it as .NET Core app, BDN will use the same target framework moniker, if you run it as .NET app it's going to use netcoreapp2.1 Mono - it's going to use the Mono from $Path , you can override it with --monoPath CoreRT - it's going to use latest CoreRT. Can be customized with additional options: --ilcPath , --coreRtVersion net46, net461, net462, net47, net471, net472 - to build and run benchmarks against specific .NET framework version netcoreapp2.0, netcoreapp2.1, netcoreapp2.2, netcoreapp3.0 - to build and run benchmarks against specific .NET Core version Example: run the benchmarks for .NET 4.7.2 and .NET Core 2.1: dotnet run -c Release -- --runtimes net472 netcoreapp2.1 Example: run the benchmarks for .NET Core 3.0 and latest .NET SDK installed on your PC: dotnet run -c Release -f netcoreapp3.0 -- --runtimes clr core But same command executed with -f netcoreapp2.0 is going to run the benchmarks for .NET Core 2.0: dotnet run -c Release -f netcoreapp2.0 -- --runtimes clr core Number of invocations and iterations --launchCount - how many times we should launch process with target benchmark. The default is 1. --warmupCount - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic. --minWarmupCount - minimum count of warmup iterations that should be performed. The default is 6. --maxWarmupCount - maximum count of warmup iterations that should be performed. The default is 50. --iterationTime - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default. --iterationCount - how many target iterations should be performed. By default calculated by the heuristic. --minIterationCount - minimum number of iterations to run. The default is 15. --maxIterationCount - maximum number of iterations to run. The default is 100. --invocationCount - invocation count in a single iteration. By default calculated by the heuristic. --unrollFactor - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default --runOncePerIteration - run the benchmark exactly once per iteration. False by default. Example: run single warmup iteration, from 9 to 12 actual workload iterations. dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 Specifying custom default settings for console argument parser If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as .AsDefault and pass it to BenchmarkSwitcher together with the console line arguments. Example: run single warmup iteration by default. static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, GetGlobalConfig()); static IConfig GetGlobalConfig() => DefaultConfig.Instance .With(Job.Default .WithWarmupCount(1) .AsDefault()); // the KEY to get it working Now, the default settings are: WarmupCount=1 but you might still overwrite it from console args like in the example below: dotnet run -c Release -- --warmupCount 2 Statistical Test To perform a Mann–Whitney U Test and display the results in a dedicated column you need to provide the Threshold: --statisticalTest - Threshold for Mann–Whitney U Test. Examples: 5%, 10ms, 100ns, 1s Example: run Mann–Whitney U test with relative ratio of 5% for all benchmarks for .NET Core 2.0 (base) vs .NET Core 2.1 (diff). .NET Core 2.0 will be baseline because it was first. dotnet run -c Release -- --filter * --runtimes netcoreapp2.0 netcoreapp2.1 --statisticalTest 5% More -j , --job (Default: Default) Dry/Short/Medium/Long or Default. -e , --exporters GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML. -i , --inProcess (default: false) run benchmarks in the same process, without spawning child process per benchmark. -a , --artifacts valid path to an accessible directory where output artifacts will be stored. --outliers (default: RemoveUpper) DontRemove/RemoveUpper/RemoveLower/RemoveAll. --affinity affinity mask to set for the benchmark process. --allStats (default: false) Displays all statistics (min, max & more). --allCategories categories to run. If few are provided, only the benchmarks which belong to all of them are going to be executed. --attribute run all methods with given attribute (applied to class or method). --monoPath optional path to Mono which should be used for running benchmarks. --cli path to dotnet cli (optional). --packages the directory to restore packages to (optional). --coreRun path(s) to CoreRun (optional). --coreRt path to ILCompiler for CoreRT --info prints environment configuration including BenchmarkDotNet, OS, CPU and .NET version --stopOnFirstError stop on first error. --help display this help screen. --version display version information. --keepFiles (default: false) determines if all auto-generated files should be kept or removed after running the benchmarks. --noOverwrite (default: false) determines if the exported result files should not be overwritten. --disableLogFile disables the logfile. --maxWidth max parameter column width, the default is 20. --envVars colon separated environment variables (key:value). --strategy the RunStrategy that should be used. Throughput/ColdStart/Monitoring. --platform the Platform that should be used. If not specified, the host process platform is used (default). AnyCpu/X86/X64/Arm/Arm64. --runOncePerIteration run the benchmark exactly once per iteration. --buildTimeout build timeout in seconds. --wasmEngine full path to a java script engine used to run the benchmarks, used by Wasm toolchain. --wasmMainJS path to the main.js file used by Wasm toolchain. Mandatory when using \"--runtimes wasm\" --expose_wasm arguments for the JavaScript engine used by Wasm toolchain. --customRuntimePack specify the path to a custom runtime pack. Only used for wasm currently."
  },
  "articles/guides/customizing-runtime.html": {
    "href": "articles/guides/customizing-runtime.html",
    "title": "Customizing Runtime | BenchmarkDotNet",
    "keywords": "Customizing Runtime Currently, we have only information about customizing Mono in this section. If you want to customize .NET Core, read an article about Toolchains . Sample: IntroCustomMono BenchmarkDotNet allows you to compare different runtimes, including Mono. If you apply [MonoJob] attribute to your class we use your default mono runtime. If you want to compare different versions of Mono you need to provide use the custom paths. You can do this today by using the overloaded ctor of MonoJob attribute or by specifying the runtime in a fluent way. The mono runtime can also operate as an ahead-of-time compiler. Using mono's AOT mode requires providing the AOT compilation arguments, as well as the path to mono's corlib. (See IntroCustomMonoObjectStyleAot in the below example). Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [MonoJob(\"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\")] [MonoJob(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")] public class IntroCustomMono { [Benchmark] public void Foo() { // Benchmark body } } // *** Object Style *** [Config(typeof(Config))] public class IntroCustomMonoObjectStyle { private class Config : ManualConfig { public Config() { AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); } } [Benchmark] public void Foo() { // Benchmark body } } // ** Object Style, Using AOT ** [Config(typeof(Config))] public class IntroCustomMonoObjectStyleAot { private class Config : ManualConfig { public void AddMono (string name, string mono_top_dir) { var aot_compile_args = \"--aot=llvm\"; var mono_bcl = $@\"{mono_top_dir}\\lib\\mono\\4.5\"; var mono_bin = $@\"{mono_top_dir}\\bin\\mono.exe\"; AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( name, mono_bin, aot_compile_args, mono_bcl))); } public Config() { AddMono(\"Mono x64\", @\"C:\\Program Files\\Mono\"); AddMono(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\"); } } [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroCustomMonoFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(ManualConfig .CreateMinimumViable() .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))) .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime The permanent link to this sample: Sample: IntroCustomMono Sample: IntroCustomMonoArguments Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomArguments))] public class IntroCustomMonoArguments { public class ConfigWithCustomArguments : ManualConfig { public ConfigWithCustomArguments() { // --optimize=MODE , -O=mode // MODE is a comma separated list of optimizations. They also allow // optimizations to be turned off by prefixing the optimization // name with a minus sign. AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=inline\") }) .WithId(\"Inlining enabled\")); AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=-inline\") }) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Sample() { ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); } private void ShouldGetInlined() { } } } Output | Method | Job | Arguments | Mean | StdDev | |------- |------------------ |------------------- |-----------:|----------:| | Sample | Inlining disabled | --optimize=-inline | 19.4252 ns | 0.4525 ns | | Sample | Inlining enabled | --optimize=inline | 0.0000 ns | 0.0000 ns | Links Customizing Runtime The permanent link to this sample: Sample: IntroCustomMonoArguments Sample: IntroEnvVars You can configure custom environment variables for the process that is running your benchmarks. One reason for doing this might be checking out how different runtime knobs affect the performance of .NET Core. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomEnvVars))] public class IntroEnvVars { private class ConfigWithCustomEnvVars : ManualConfig { private const string JitNoInline = \"COMPlus_JitNoInline\"; public ConfigWithCustomEnvVars() { AddJob(Job.Default.WithRuntime(CoreRuntime.Core21).WithId(\"Inlining enabled\")); AddJob(Job.Default.WithRuntime(CoreRuntime.Core21) .WithEnvironmentVariables(new EnvironmentVariable(JitNoInline, \"1\")) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime Configs Jobs The permanent link to this sample: Sample: IntroEnvVars Sample: IntroStaThread If the code you want to benchmark requires [System.STAThread] then you need to apply this attribute to the benchmarked method. BenchmarkDotNet will generate executable with [STAThread] applied to it's Main method. Currently it does not work for .NET Core 2.0 due to this bug. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroStaThread { [Benchmark, System.STAThread] public void CheckForSTA() { if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA) { throw new ThreadStateException( \"The current threads apartment state is not STA\"); } } } } Links Customizing Runtime The permanent link to this sample: Sample: IntroStaThread"
  },
  "articles/guides/dotnet-new-templates.html": {
    "href": "articles/guides/dotnet-new-templates.html",
    "title": "BenchmarkDotNet templates | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet templates BenchmarkDotNet provides project templates to setup your benchmarks easily The template exists for each major .NET language ( C# , F# and VB ) with equivalent features and structure. How to install the templates The templates requires the .NET Core SDK . Once installed, run the following command to install the templates: dotnet new -i BenchmarkDotNet.Templates If you want to uninstall all BenchmarkDotNet templates: dotnet new -u BenchmarkDotNet.Templates The template is a nuget package distributed over nuget: BenchmarkDotNet.Templates . Basic usage To create a new C# benchmark library project from the template, run: dotnet new benchmark If you'd like to create F# or VB project, you can specify project language with -lang option: dotnet new benchmark -lang F# dotnet new benchmark -lang VB Project template specific options The template projects has five additional options - all of them are optional. By default a class library project targeting netstandard2.0 is created. You can specify -f or --frameworks to change targeting to one or more frameworks: dotnet new benchmark -f netstandard2.0;net472 The option --console-app creates a console app project targeting netcoreapp3.0 with an entry point: dotnet new benchmark --console-app This lets you run the benchmarks from console ( dotnet run ) or from your favorite IDE. Note: option -f or --frameworks will be ignored when --console-app is set. The option -b or --benchmarkName sets the name of the benchmark class: dotnet new benchmark -b Md5VsSha256 BenchmarkDotNet lets you create a dedicated configuration class (see Configs ) to customize the execution of your benchmarks. To create a benchmark project with a configuration class, use the option -c or --config : dotnet new benchmark -c The option --no-restore if specified, skips the automatic nuget restore after the project is created: dotnet new benchmark --no-restore Use the -h or --help option to display all possible arguments with a description and the default values: dotnet new benchmark --help How to run the benchmarks Please read how to run your benchmarks . The relationship of BenchmarkDotNet and BenchmarkDotNet.Templates The version of the template nuget package is synced with the BenchmarkDotNet package. For instance, the template version 0.11.5 is referencing BenchmarkDotnet 0.11.15 - there is no floating version behavior. Note : This will maybe change when BenchmarkDotNet reaches 1.x . References For more info about the dotnet new CLI, please read the documentation ."
  },
  "articles/guides/getting-started.html": {
    "href": "articles/guides/getting-started.html",
    "title": "Getting started | BenchmarkDotNet",
    "keywords": "Getting started To get started with BenchmarkDotNet, please follow these steps. Step 1. Create a project Create a new console application. Step 2. Installation Install BenchmarkDotNet via the NuGet package: BenchmarkDotNet PM> Install-Package BenchmarkDotNet Read more about BenchmarkDotNet NuGet packages: Installing NuGet packages Step 3. Design a benchmark Write a class with methods that you want to measure and mark them with the Benchmark attribute. In the following example, we compare MD5 and SHA256 cryptographic hash functions: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; namespace MyBenchmarks { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run<Md5VsSha256>(); } } } The BenchmarkRunner.Run<Md5VsSha256>() call runs your benchmarks and print results to console output. Step 4. View results View the results. Here is an example of output from the above benchmark: BenchmarkDotNet=v0.11.3, OS=Windows 10.0.17134.472 (1803/April2018Update/Redstone4) Intel Core i7-2630QM CPU 2.00GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores Frequency=1948699 Hz, Resolution=513.1629 ns, Timer=TSC .NET Core SDK=2.1.502 [Host] : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT DefaultJob : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT | Method | Mean | Error | StdDev | |------- |----------:|----------:|----------:| | Sha256 | 100.90 us | 0.5070 us | 0.4494 us | | Md5 | 37.66 us | 0.1290 us | 0.1207 us | Step 5. Analyze results Analyze it. In your bin directory, you can find a lot of useful files with detailed information. For example: Csv reports with raw data: Md5VsSha256-report.csv , Md5VsSha256-runs.csv Markdown reports: Md5VsSha256-report-default.md , Md5VsSha256-report-stackoverflow.md , Md5VsSha256-report-github.md Plain report and log: Md5VsSha256-report.txt , Md5VsSha256.log Plots (if you have installed R): Md5VsSha256-barplot.png , Md5VsSha256-boxplot.png , and so on. Next steps BenchmarkDotNet provides a lot of features which help to high-quality performance research. If you want to know more about BenchmarkDotNet features, checkout the Overview page. If you want have any questions, checkout the FAQ page. If you didn't find answer for your question on this page, ask it on gitter or create an issue ."
  },
  "articles/guides/good-practices.html": {
    "href": "articles/guides/good-practices.html",
    "title": "Good Practices | BenchmarkDotNet",
    "keywords": "Good Practices Use the Release build without an attached debugger Never use the Debug build for benchmarking. Never . The debug version of the target method can run 10–100 times slower. The release mode means that you should have <Optimize>true</Optimize> in your csproj file or use /optimize for csc . Also your never should use an attached debugger (e.g. Visual Studio or WinDbg) during the benchmarking. The best way is build our benchmark in the Release mode and run it from the command line. Try different environments Please, don't extrapolate your results. Or do it very carefully. I remind you again: the results in different environments may vary significantly. If a Foo1 method is faster than a Foo2 method for CLR4, .NET Framework 4.5, x64, RyuJIT, Windows, it means that the Foo1 method is faster than the Foo2 method for CLR4, .NET Framework 4.5, x64, RyuJIT, Windows and nothing else. And you can not say anything about methods performance for CLR 2 or .NET Framework 4.6 or LegacyJIT-x64 or x86 or Linux+Mono until you try it. Avoid dead code elimination You should also use the result of calculation. For example, if you run the following code: void Foo() { Math.Exp(1); } then JIT can eliminate this code because the result of Math.Exp is not used. The better way is use it like this: double Foo() { return Math.Exp(1); } Power settings and other applications Turn off all of the applications except the benchmark process and the standard OS processes. If you run benchmark and work in the Visual Studio at the same time, it can negatively affect to benchmark results. If you use laptop for benchmarking, keep it plugged in and use the maximum performance mode."
  },
  "articles/guides/how-it-works.html": {
    "href": "articles/guides/how-it-works.html",
    "title": "How it works | BenchmarkDotNet",
    "keywords": "How it works BenchmarkDotNet follows the following steps to run your benchmarks: BenchmarkRunner generates an isolated project per each runtime settings and builds it in Release mode. Next, we take each method/job/params combination and try to measure its performance by launching benchmark process several times ( LaunchCount ). An invocation of the workload method is an operation . A bunch of operation is an iteration . If you have an IterationSetup method, it will be invoked before each iteration, but not between operations. We have the following type of iterations: Pilot : The best operation count will be chosen. OverheadWarmup , OverheadWorkload : BenchmarkDotNet overhead will be evaluated. ActualWarmup : Warmup of the workload method. ActualWorkload : Actual measurements. Result = ActualWorkload - <MedianOverhead> After all of the measurements, BenchmarkDotNet creates: An instance of the Summary class that contains all information about benchmark runs. A set of files that contains summary in human-readable and machine-readable formats. A set of plots. Pseudocode If you don't understand our \"count terminology\", then you might find following pseudocode useful: IEnumerable<Results> Run(Benchmark benchmark) { var toolchain = benchmark.GetToolchain(); var autoGeneratedProject = toolchain.Generate(benchmark); var exe = toolchain.Build(autoGeneratedProject); foreach (var runIndex in LaunchCount) // LaunchCount = 1 by default yield return ParseResults(Process.Start(exe).Output); // calls ActualRun in a separate process } Result ActualRun(Method method, Job job) { GlobalSetup(); int unrollFactor = job.Run.UnrollFactor; // 16 by default long perfectInvocationCount = Pilot(method, unrollFactor); WarmupStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor); // EMPTY_METHOD has same return type and arguments as benchmark var overhead = ActualStage(EMPTY_METHOD, perfectInvocationCount, unrollFactor); WarmupStage(method, perfectInvocationCount, unrollFactor); var result = ActualStage(method, perfectInvocationCount); if (MemoryDiagnoser.IsEnabled) var gcStats = MeasureGcStats(method, perfectInvocationCount, unrollFactor); GlobalCleanup(); return (result - Median(overhead), gcStats); } long Pilot(Method method, int unrollFactor) { // invokeCount is the equivalent of InnerIterationCount from xunit-performance long invokeCount = minInvokeCount; while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (heuristic.IsPilotRequirementMet(measurement)) break; invokeCount *= 2; } return invokeCount; } void Warmup(Method method, long invokeCount, int unrollFactor) { while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (heuristic.IsWarmupRequirementMet(measurement)) break; } } IEnuberable<Measurement> Workload(Method method, long invokeCount, int unrollFactor) { while (true) { var measurement = RunIteration(method, invokeCount, unrollFactor); if (measurement.IsNotOutlier) yield return measurement; if (heuristic.IsWorkloadRequirementMet(measurement)) yield break; } } // every iteration invokes the method (invokeCount / unrollFactor) times Measurement RunIteration(Method method, long invokeCount, long unrollFactor) { IterationSetup(); MemoryCleanup(); var clock = Clock.Start(); for (long i = 0; i < invokeCount / unrollFactor; i++) { // we perform manual loop unrolling!! method(); // 1st call method(); // 2nd call method(); // (unrollFactor - 1)'th call method(); // unrollFactor'th call } var clockSpan = clock.GetElapsed(); IterationCleanup(); MemoryCleanup(); return Measurement(clockSpan); } GcStats MeasureGcStats(Method method, long invokeCount, long unrollFacto) { // we enable monitoring after workload actual run, for this single iteration which is executed at the end // so even if we enable AppDomain monitoring in separate process // it does not matter, because we have already obtained the results! EnableMonitoring(); IterationSetup(); var initialGcStats = GcStats.ReadInitial(); // we do NOT start any clock here, because the enabled monitoring might have some overhead // so we just get the gc stats and ignore the timing // it's last thing the process does before it dies, so also enabled monitoring is not an issue for next benchmarks // because each of them is going to be executed in a new process for (long i = 0; i < invokeCount / unrollFactor; i++) { // we perform manual loop unrolling!! method(); // 1st call method(); // 2nd call method(); // (unrollFactor - 1)'th call method(); // unrollFactor'th call } var finalGcStats = GcStats.ReadFinal(); IterationCleanup(); return finalGcStats - initialGcStats; // the result is the difference between the stats collected after and before running the extra iteration }"
  },
  "articles/guides/how-to-run.html": {
    "href": "articles/guides/how-to-run.html",
    "title": "How to run your benchmarks | BenchmarkDotNet",
    "keywords": "How to run your benchmarks There are several ways to run your benchmarks. What is important is that BenchmarkDotNet works only with Console Apps . It does not support any other kind of application like ASP.NET, Azure WebJobs, etc. Types If you have just a few types with benchmarks, you can use BenchmarkRunner : var summary = BenchmarkRunner.Run<MyBenchmarkClass>(); var summary = BenchmarkRunner.Run(typeof(MyBenchmarkClass)); The disadvantage of BenchmarkRunner is that it always runs all benchmarks in a given type (or assembly) and to change the type you need to modify the source code. But it's great for a quick start. BenchmarkSwitcher If you have more types and you want to choose which benchmark to run (either by using console line arguments or console input) you should use BenchmarkSwitcher : static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); Also you can use the config command style to specify some config from command line (more @docs.console-args): dotnet run -c Release -- --job short --runtimes net461 netcoreapp21--filter *BenchmarkClass1* The most important thing about BenchmarkSwitcher is that you need to pass the args from Main to the Run method. If you don't, it won't parse the arguments. Url You can also run a benchmark directly from the internet: string url = \"<E.g. direct link to raw content of a gist>\"; var summary = BenchmarkRunner.RunUrl(url); Note: it works only for Full .NET Framework. It's not recommended to use this approach. Source string benchmarkSource = \"public class MyBenchmarkClass { ...\"; var summary = BenchmarkRunner.RunSource(benchmarkSource); Note: it works only for Full .NET Framework. It's not recommended to use this approach."
  },
  "articles/guides/nuget.html": {
    "href": "articles/guides/nuget.html",
    "title": "Installing NuGet packages | BenchmarkDotNet",
    "keywords": "Installing NuGet packages Packages We have the following set of NuGet packages (you can install it directly from nuget.org ): BenchmarkDotNet : Basic BenchmarkDotNet infrastructure and logic. This is all you need to run benchmarks. BenchmarkDotNet.Diagnostics.Windows : an additional optional package that provides a set of Windows diagnosers. BenchmarkDotNet.Templates : Templates for BenchmarkDotNet. You might find other NuGet packages that start with BenchmarkDotNet name, but they are internal BDN packages that should not be installed manually. All that matters are the three packages mentioned above. Versioning system and feeds We have 3 kinds of versions: stable , nightly , and develop . You can get the current version from the source code via BenchmarkDotNetInfo.FullVersion and the full title via BenchmarkDotNetInfo.FullTitle . Stable These versions are available from the official NuGet feed. <packageSources> <add key=\"api.nuget.org\" value=\"https://api.nuget.org/v3/index.json\" protocolVersion=\"3\" /> </packageSources> Example of the main NuGet package: BenchmarkDotNet.0.10.3.nupkg . Example of BenchmarkDotNetInfo.FullTitle : BenchmarkDotNet v0.10.3 . Nightly If you want to use a nightly version of the BenchmarkDotNet, add the https://ci.appveyor.com/nuget/benchmarkdotnet feed in the <packageSources> section of your NuGet.config : <packageSources> <add key=\"bdn-nightly\" value=\"https://ci.appveyor.com/nuget/benchmarkdotnet\" /> </packageSources> Now you can install the packages from the bdn-nightly feed. Example of the main NuGet package: BenchmarkDotNet.0.10.3.13.nupkg . Example of BenchmarkDotNetInfo.FullTitle : BenchmarkDotNet v0.10.3.13-nightly . Develop You also can build BenchmarkDotNet from source code. The .nupkg files could be build with the help of .\\build\\build-and-pack.cmd . Example of the main NuGet package: BenchmarkDotNet.0.10.3-develop.nupkg . Example of BenchmarkDotNetInfo.FullTitle : BenchmarkDotNet v0.10.3.20170304-develop ."
  },
  "articles/guides/troubleshooting.html": {
    "href": "articles/guides/troubleshooting.html",
    "title": "Troubleshooting | BenchmarkDotNet",
    "keywords": "Troubleshooting BenchmarkDotNet You need to be aware of the fact that to ensure process-level isolation BenchmarkDotNet generates, builds and executes every benchmark in a dedicated process. For .NET and Mono we generate a C# file and compile it using Roslyn. For .NET Core and CoreRT we generate not only C# file but also a project file which later is restored and build with dotnet cli. If your project has some non-trivial build settings like a .props and .target files or native dependencies things might not work well out of the box. How do you know that BenchmarkDotNet has failed to build the project? BDN is going to tell you about it. An example: // Validating benchmarks: // ***** BenchmarkRunner: Start ***** // ***** Found 1 benchmark(s) in total ***** // ***** Building 1 exe(s) in Parallel: Start ***** // start dotnet restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4 // command took 0.51s and exited with 1 // ***** Done, took 00:00:00 (0.66 sec) ***** // Found 1 benchmarks: // IntroBasic.Sleep: DefaultJob // Build Error: Standard output: Standard error: C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4\\BenchmarkDotNet.Autogenerated.csproj(36,1): error MSB4025: The project file could not be loaded. Unexpected end of file while parsing Comment has occurred. Line 36, position 1. // BenchmarkDotNet has failed to build the auto-generated boilerplate code. // It can be found in C:\\Projects\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\bin\\Release\\netcoreapp2.1\\c6045772-d3c7-4dbe-ab37-4aca6dcb6ec4 // Please follow the troubleshooting guide: https://benchmarkdotnet.org/articles/guides/troubleshooting.html If the error message is not clear enough, you need to investigate it further. How to troubleshoot the build process: Run the benchmarks. Read the error message. If it does not contain the answer to your problem, please continue to the next step. Go to the build artifacts folder (path printed by BDN). The folder should contain: a file with source code (ends with .notcs to make sure IDE don't include it in other projects by default) a project file ( .csproj ) a script file ( .bat on Windows, .sh for other OSes) which should be doing exactly the same thing as BDN does: dotnet restore dotnet build (with some parameters like -c Release ) Run the script, read the error message. From here you continue with the troubleshooting like it was a project in your solution. The recommended order of solving build issues: Change the right settings in your project file which defines benchmarks to get it working. Customize the Job settings using available options like job.WithCustomBuildConfiguration($name) or job.With(new Argument[] { new MsBuildArgument(\"/p:SomeProperty=Value\")}) . Implement your own IToolchain and generate and build all the right things in your way (you can use existing Builders and Generators and just override some methods to change specific behaviour). Report a bug in BenchmarkDotNet repository. Debugging Benchmarks In the same process If your benchmark builds but fails to run, you can simply debug it. The first thing you should try is to do it in a single process (host process === runner process). Use DebugInProcessConfig static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args, new DebugInProcessConfig()); Set the breakpoints in your favorite IDE Start debugging the project with benchmarks In a different process Sometimes you won't be able to reproduce the problem in the same process. In this case, you have 3 options: Launch a debugger from the benchmark process using Debugger API [GlobalSetup] public void Setup() { System.Diagnostics.Debugger.Launch(); } Attach a debugger from IDE Modify your benchmark to sleep until the Debugger is not attached and use your favorite IDE to attach the debugger to benchmark process. Do attach to the process which is running the benchmark (the arguments of the process are going to be --benchmarkId $someNumber --benchmarkName $theName ), not the host process. [GlobalSetup] public void Setup() { while(!System.Diagnostics.Debugger.IsAttached) Thread.Sleep(TimeSpan.FromMilliseconds(100)); } One of the above, but with a Debug build By default, BDN builds everything in Release. But debugging Release builds even with full symbols might be non-trivial. To enforce BDN to build the benchmark in Debug please use DebugBuildConfig and then attach the debugger."
  },
  "articles/license.html": {
    "href": "articles/license.html",
    "title": "The MIT License | BenchmarkDotNet",
    "keywords": "The MIT License Copyright (c) 2013–2021 .NET Foundation and contributors Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/overview.html": {
    "href": "articles/overview.html",
    "title": "Overview | BenchmarkDotNet",
    "keywords": "Overview Install Create new console application and install the BenchmarkDotNet NuGet package. We support: Projects: classic and modern with PackageReferences Runtimes: Full .NET Framework (4.6+), .NET Core (2.0+), Mono, CoreRT OS: Windows, Linux, MacOS Languages: C#, F#, VB Design a benchmark Create a new console application, write a class with methods that you want to measure and mark them with the Benchmark attribute. In the following example, we compare the MD5 and SHA256 cryptographic hash functions: using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Running; namespace MyBenchmarks { public class Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly SHA256 sha256 = SHA256.Create(); private readonly MD5 md5 = MD5.Create(); public Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } public class Program { public static void Main(string[] args) { var summary = BenchmarkRunner.Run(typeof(Program).Assembly); } } } The BenchmarkRunner.Run<Md5VsSha256>() call runs your benchmarks and print results to console output. Notice, that you should use only the Release configuration for your benchmarks. Otherwise, the results will not correspond to reality. If you forgot to change the configuration, BenchmarkDotNet will print a warning. Benchmark results BenchmarkDotNet=v0.11.3, OS=Windows 10.0.17134.472 (1803/April2018Update/Redstone4) Intel Core i7-2630QM CPU 2.00GHz (Sandy Bridge), 1 CPU, 8 logical and 4 physical cores Frequency=1948699 Hz, Resolution=513.1629 ns, Timer=TSC .NET Core SDK=2.1.502 [Host] : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT DefaultJob : .NET Core 2.1.6 (CoreCLR 4.6.27019.06, CoreFX 4.6.27019.05), 64bit RyuJIT | Method | Mean | Error | StdDev | |------- |----------:|----------:|----------:| | Sha256 | 100.90 us | 0.5070 us | 0.4494 us | | Md5 | 37.66 us | 0.1290 us | 0.1207 us | Jobs You can check several environments at once. For example, you can compare performance of Full .NET Framework, .NET Core, Mono and CoreRT. Just add the ClrJob , MonoJob , CoreJob , CoreRtJob attributes before the class declaration (it requires a .NETCore project, installed CoreCLR and Mono): [ClrJob, MonoJob, CoreJob, CoreRtJob] public class Md5VsSha256 Example of the result: BenchmarkDotNet=v0.11.0, OS=Windows 10.0.16299.309 (1709/FallCreatorsUpdate/Redstone3) Intel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores Frequency=3507504 Hz, Resolution=285.1030 ns, Timer=TSC .NET Core SDK=2.1.300-preview1-008174 [Host] : .NET Core 2.1.0-preview1-26216-03 (CoreCLR 4.6.26216.04, CoreFX 4.6.26216.02), 64bit RyuJIT Job-YRHGTP : .NET Framework 4.7.1 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2633.0 Core : .NET Core 2.1.0-preview1-26216-03 (CoreCLR 4.6.26216.04, CoreFX 4.6.26216.02), 64bit RyuJIT CoreRT : .NET CoreRT 1.0.26414.01, 64bit AOT Mono : Mono 5.10.0 (Visual Studio), 64bit | Method | Runtime | Mean | Error | StdDev | |------- |-------- |-----------:|----------:|----------:| | Sha256 | Clr | 75.780 us | 1.0445 us | 0.9771 us | | Sha256 | Core | 41.134 us | 0.2185 us | 0.1937 us | | Sha256 | CoreRT | 40.895 us | 0.0804 us | 0.0628 us | | Sha256 | Mono | 141.377 us | 0.5598 us | 0.5236 us | | | | | | | | Md5 | Clr | 18.575 us | 0.0727 us | 0.0644 us | | Md5 | Core | 17.562 us | 0.0436 us | 0.0408 us | | Md5 | CoreRT | 17.447 us | 0.0293 us | 0.0244 us | | Md5 | Mono | 34.500 us | 0.1553 us | 0.1452 us | There are a lot of predefined jobs which you can use. For example, you can compare LegacyJitX86 vs LegacyJitX64 vs RyuJitX64 : [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] Or you can define own jobs: [Config(typeof(Config))] public class Md5VsSha256 { private class Config : ManualConfig { public Config() { Add(new Job(EnvMode.LegacyJitX86, EnvMode.Clr, RunMode.Dry) { Env = { Runtime = Runtime.Clr }, Run = { LaunchCount = 3, WarmupCount = 5, TargetCount = 10 }, Accuracy = { MaxStdErrRelative = 0.01 } })); } } Read more: Jobs , Configs Columns You can also add custom columns to the summary table: [MinColumn, MaxColumn] public class Md5VsSha256 Method Median StdDev Min Max Sha256 131.3200 us 4.6744 us 129.8216 us 147.7630 us Md5 26.2847 us 0.4424 us 25.8442 us 27.4258 us Of course, you can define own columns based on full benchmark summary. Read more: Columns Exporters You can export result of your benchmark in different formats: [MarkdownExporter, AsciiDocExporter, HtmlExporter, CsvExporter, RPlotExporter] public class Md5VsSha256 If you have installed R, RPlotExporter will generate a lot of nice plots: Read more: Exporters Baseline In order to scale your results you need to mark one of your benchmark methods as a Baseline : public class Sleeps { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } As a result, you will have additional column in the summary table: Method Median StdDev Ratio Time100 100.2640 ms 0.1238 ms 1.00 Time150 150.2093 ms 0.1034 ms 1.50 Time50 50.2509 ms 0.1153 ms 0.50 Read more: Baselines Params You can mark one or several fields or properties in your class by the Params attribute. In this attribute, you can specify set of values. As a result, you will get results for each combination of params values. public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep(A + B + 5); } } Method Median StdDev A B Benchmark 115.3325 ms 0.0242 ms 100 10 Benchmark 125.3282 ms 0.0245 ms 100 20 Benchmark 215.3024 ms 0.0375 ms 200 10 Benchmark 225.2710 ms 0.0434 ms 200 20 Read more: Parameterization Languages You can also write you benchmarks on F# or VB . Examples: type StringKeyComparison () = let mutable arr : string [] = [||] let dict1 = ConcurrentDictionary<_,_>() let dict2 = ConcurrentDictionary<_,_>(StringComparer.Ordinal) [<Params (100, 500, 1000, 2000)>] member val public DictSize = 0 with get, set [<GlobalSetup>] member self.GlobalSetupData() = dict1.Clear(); dict2.Clear() arr <- getStrings self.DictSize arr |> Array.iter (fun x -> dict1.[x] <- true ; dict2.[x] <- true) [<Benchmark>] member self.StandardLookup () = lookup arr dict1 [<Benchmark>] member self.OrdinalLookup () = lookup arr dict2 Public Class Sample <Params(1, 2)> Public Property A As Integer <Params(3, 4)> Public Property B As Integer <Benchmark> Public Function Benchmark() As Integer return A + B End Function End Class Diagnostics A diagnoser can attach to your benchmark and get some useful info. The current Diagnosers are: GC and Memory Allocation ( MemoryDiagnoser ) which is cross platform, built-in and is not enabled by default anymore . JIT Inlining Events ( InliningDiagnoser ). You can find this diagnoser in a separated package with diagnosers for Windows ( BenchmarkDotNet.Diagnostics.Windows ): Below is a sample output from the MemoryDiagnoser , note the extra columns on the right-hand side ( Gen 0 and Allocated ): Method | Mean | StdDev | Gen 0 | Allocated | ---------- |----------- |---------- |------- |---------- | Iterative | 31.0739 ns | 0.1091 ns | - | 0 B | LINQ | 83.0435 ns | 1.0103 ns | 0.0069 | 32 B | Read more: Diagnosers BenchmarkRunner There are several ways to run your benchmarks: you can use an existing class, run a benchmark based on code from internet or based on source code: var summary = BenchmarkRunner.Run<MyBenchmarkClass>(); var summary = BenchmarkRunner.Run(typeof(MyBenchmarkClass)); string url = \"<E.g. direct link to a gist>\"; var summary = BenchmarkRunner.RunUrl(url); string benchmarkSource = \"public class MyBenchmarkClass { ...\"; var summary = BenchmarkRunner.RunSource(benchmarkSource); Read more: HowToRun"
  },
  "articles/samples/IntroArguments.html": {
    "href": "articles/samples/IntroArguments.html",
    "title": "Sample: IntroArguments | BenchmarkDotNet",
    "keywords": "Sample: IntroArguments As an alternative to using [Params] , you can specify arguments for your benchmarks. There are several ways to do it (described below). The [Arguments] allows you to provide a set of values. Every value must be a compile-time constant (it's C# language limitation for attributes in general). You can also combine [Arguments] with [Params] . As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArguments { [Params(true, false)] // Arguments can be combined with Params public bool AddExtra5Milliseconds; [Benchmark] [Arguments(100, 10)] [Arguments(100, 20)] [Arguments(200, 10)] [Arguments(200, 20)] public void Benchmark(int a, int b) { if (AddExtra5Milliseconds) Thread.Sleep(a + b + 5); else Thread.Sleep(a + b); } } } Output | Method | AddExtra5Miliseconds | a | b | Mean | Error | StdDev | |---------- |--------------------- |---- |--- |---------:|----------:|----------:| | Benchmark | False | 100 | 10 | 110.1 ms | 0.0056 ms | 0.0044 ms | | Benchmark | False | 100 | 20 | 120.1 ms | 0.0155 ms | 0.0138 ms | | Benchmark | False | 200 | 10 | 210.2 ms | 0.0187 ms | 0.0175 ms | | Benchmark | False | 200 | 20 | 220.3 ms | 0.1055 ms | 0.0986 ms | | Benchmark | True | 100 | 10 | 115.3 ms | 0.1375 ms | 0.1286 ms | | Benchmark | True | 100 | 20 | 125.3 ms | 0.1212 ms | 0.1134 ms | | Benchmark | True | 200 | 10 | 215.4 ms | 0.0779 ms | 0.0691 ms | | Benchmark | True | 200 | 20 | 225.4 ms | 0.0775 ms | 0.0725 ms | Links Parameterization The permanent link to this sample: Sample: IntroArguments"
  },
  "articles/samples/IntroArgumentsPriority.html": {
    "href": "articles/samples/IntroArgumentsPriority.html",
    "title": "Sample: IntroArgumentsPriority | BenchmarkDotNet",
    "keywords": "Sample: IntroArgumentsPriority Like Params also Argument columns can be sorted in the table result through their Priority . The priority should be defined only once for multiple Arguments and will keep their inner order as they are defined in the method. Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsPriority { [Params(100, Priority = 0)] // Argument priority can be combined with Params priority public int A { get; set; } [Arguments(5, Priority = -10)] // Define priority just once for multiple argument attributes [Arguments(10)] [Arguments(20)] [Benchmark] public void Benchmark(int b) => Thread.Sleep(A + b); [Benchmark] [ArgumentsSource(nameof(Numbers), Priority = 10)] public void ManyArguments(int c, int d) => Thread.Sleep(A + c + d); public IEnumerable<object[]> Numbers() { yield return new object[] { 1, 2 }; } } } Output | Method | b | A | c | d | Mean | Error | StdDev | |-------------- |--- |---- |-- |-- |---------:|--------:|--------:| | ManyArguments | ? | 100 | 1 | 2 | 103.4 ms | 0.09 ms | 0.08 ms | | Benchmark | 5 | 100 | ? | ? | 105.5 ms | 0.21 ms | 0.19 ms | | Benchmark | 10 | 100 | ? | ? | 110.5 ms | 0.14 ms | 0.14 ms | | Benchmark | 20 | 100 | ? | ? | 120.4 ms | 0.16 ms | 0.15 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: Sample: IntroArgumentsPriority"
  },
  "articles/samples/IntroArgumentsSource.html": {
    "href": "articles/samples/IntroArgumentsSource.html",
    "title": "Sample: IntroArgumentsSource | BenchmarkDotNet",
    "keywords": "Sample: IntroArgumentsSource In case you want to use a lot of values, you should use [ArgumentsSource] . You can mark one or several fields or properties in your class by the [ArgumentsSource] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable ). The source must be within benchmarked type! Source code using System; using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArgumentsSource { [Benchmark] [ArgumentsSource(nameof(Numbers))] public double ManyArguments(double x, double y) => Math.Pow(x, y); public IEnumerable<object[]> Numbers() // for multiple arguments it's an IEnumerable of array of objects (object[]) { yield return new object[] { 1.0, 1.0 }; yield return new object[] { 2.0, 2.0 }; yield return new object[] { 4.0, 4.0 }; yield return new object[] { 10.0, 10.0 }; } [Benchmark] [ArgumentsSource(nameof(TimeSpans))] public void SingleArgument(TimeSpan time) => Thread.Sleep(time); public IEnumerable<object> TimeSpans() // for single argument it's an IEnumerable of objects (object) { yield return TimeSpan.FromMilliseconds(10); yield return TimeSpan.FromMilliseconds(100); } } } Output | Method | x | y | Mean | Error | StdDev | |------- |--- |--- |----------:|----------:|----------:| | Pow | 1 | 1 | 9.360 ns | 0.0190 ns | 0.0149 ns | | Pow | 2 | 2 | 40.624 ns | 0.3413 ns | 0.3192 ns | | Pow | 4 | 4 | 40.537 ns | 0.0560 ns | 0.0524 ns | | Pow | 10 | 10 | 40.395 ns | 0.3274 ns | 0.3063 ns | Another example If the values are complex types you need to override ToString method to change the display names used in the results. [DryJob] public class WithNonPrimitiveArgumentsSource { [Benchmark] [ArgumentsSource(nameof(NonPrimitive))] public void Simple(SomeClass someClass, SomeStruct someStruct) { for (int i = 0; i < someStruct.RangeEnd; i++) Console.WriteLine($\"// array.Values[{i}] = {someClass.Values[i]}\"); } public IEnumerable<object[]> NonPrimitive() { yield return new object[] { new SomeClass(Enumerable.Range(0, 10).ToArray()), new SomeStruct(10) }; yield return new object[] { new SomeClass(Enumerable.Range(0, 15).ToArray()), new SomeStruct(15) }; } public class SomeClass { public SomeClass(int[] initialValues) => Values = initialValues.Select(val => val * 2).ToArray(); public int[] Values { get; } public override string ToString() => $\"{Values.Length} items\"; } public struct SomeStruct { public SomeStruct(int rangeEnd) => RangeEnd = rangeEnd; public int RangeEnd { get; } public override string ToString() => $\"{RangeEnd}\"; } } | Method | someClass | someStruct | Mean | Error | |------- |---------- |----------- |---------:|------:| | Simple | 10 items | 10 | 887.2 us | NA | | Simple | 15 items | 15 | 963.1 us | NA | Links Parameterization The permanent link to this sample: Sample: IntroArgumentsSource"
  },
  "articles/samples/IntroArrayParam.html": {
    "href": "articles/samples/IntroArrayParam.html",
    "title": "Sample: IntroArrayParam | BenchmarkDotNet",
    "keywords": "Sample: IntroArrayParam Warning The cost of creating the arguments is not included in the benchmark. So if you want to pass an array as an argument, we are going to allocate it before running the benchmark, and the benchmark will not include this operation. Source code using System; using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroArrayParam { [Benchmark] [ArgumentsSource(nameof(Data))] public int ArrayIndexOf(int[] array, int value) => Array.IndexOf(array, value); [Benchmark] [ArgumentsSource(nameof(Data))] public int ManualIndexOf(int[] array, int value) { for (int i = 0; i < array.Length; i++) if (array[i] == value) return i; return -1; } public IEnumerable<object[]> Data() { yield return new object[] { new int[] { 1, 2, 3 }, 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 4 }; yield return new object[] { Enumerable.Range(0, 100).ToArray(), 101 }; } } } Output | Method | array | value | Mean | Error | StdDev | Allocated | |-------------- |----------- |------ |----------:|----------:|----------:|----------:| | ArrayIndexOf | Array[100] | 4 | 15.558 ns | 0.0638 ns | 0.0597 ns | 0 B | | ManualIndexOf | Array[100] | 4 | 5.345 ns | 0.0668 ns | 0.0625 ns | 0 B | | ArrayIndexOf | Array[3] | 4 | 14.334 ns | 0.1758 ns | 0.1558 ns | 0 B | | ManualIndexOf | Array[3] | 4 | 2.758 ns | 0.0905 ns | 0.1208 ns | 0 B | | ArrayIndexOf | Array[100] | 101 | 78.359 ns | 1.8853 ns | 2.0955 ns | 0 B | | ManualIndexOf | Array[100] | 101 | 80.421 ns | 0.6391 ns | 0.5978 ns | 0 B | Links Parameterization The permanent link to this sample: Sample: IntroArrayParam"
  },
  "articles/samples/IntroBasic.html": {
    "href": "articles/samples/IntroBasic.html",
    "title": "Sample: IntroBasic | BenchmarkDotNet",
    "keywords": "Sample: IntroBasic Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // It is very easy to use BenchmarkDotNet. You should just create a class public class IntroBasic { // And define a method with the Benchmark attribute [Benchmark] public void Sleep() => Thread.Sleep(10); // You can write a description for your method. [Benchmark(Description = \"Thread.Sleep(10)\")] public void SleepWithDescription() => Thread.Sleep(10); } } Links The permanent link to this sample: Sample: IntroBasic"
  },
  "articles/samples/IntroBenchmarkBaseline.html": {
    "href": "articles/samples/IntroBenchmarkBaseline.html",
    "title": "Sample: IntroBenchmarkBaseline | BenchmarkDotNet",
    "keywords": "Sample: IntroBenchmarkBaseline You can mark a method as a baseline with the help of [Benchmark(Baseline = true)] . Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroBenchmarkBaseline { [Benchmark] public void Time50() => Thread.Sleep(50); [Benchmark(Baseline = true)] public void Time100() => Thread.Sleep(100); [Benchmark] public void Time150() => Thread.Sleep(150); } } Output As a result, you will have additional Ratio column in the summary table: | Method | Mean | Error | StdDev | Ratio | |-------- |----------:|----------:|----------:|------:| | Time50 | 50.46 ms | 0.0779 ms | 0.0729 ms | 0.50 | | Time100 | 100.39 ms | 0.0762 ms | 0.0713 ms | 1.00 | | Time150 | 150.48 ms | 0.0986 ms | 0.0922 ms | 1.50 | This column contains the mean value of the ratio distribution. For example, in the case of Time50 , we divide the first measurement of Time50 into the first measurement of Time100 (it's the baseline), the second measurement of Time50 into the second measurement of Time100 , and so on. Next, we calculate the mean of all these values and display it in the Ratio column. For Time50 , we have 0.50. The Ratio column was formerly known as Scaled . The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46 / 100.39 for Time50 ). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. In @BenchmarkDotNet.Samples.IntroRatioStdDev, you can find an example of how this value can be spoiled by outliers. Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroBenchmarkBaseline"
  },
  "articles/samples/IntroCategories.html": {
    "href": "articles/samples/IntroCategories.html",
    "title": "Sample: IntroCategories | BenchmarkDotNet",
    "keywords": "Sample: IntroCategories Combined together with [BenchmarkCategory] attribute, you can group the benchmarks into categories and filter them by categories. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [CategoriesColumn] [BenchmarkCategory(\"Awesome\")] [AnyCategoriesFilter(\"A\", \"1\")] public class IntroCategories { [Benchmark] [BenchmarkCategory(\"A\", \"1\")] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"A\", \"2\")] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"1\")] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] [BenchmarkCategory(\"B\", \"2\")] public void B2() => Thread.Sleep(10); } } Command line examples: --allCategories=A,B --anyCategories=A,B Links Filters The permanent link to this sample: Sample: IntroCategories"
  },
  "articles/samples/IntroCategoryBaseline.html": {
    "href": "articles/samples/IntroCategoryBaseline.html",
    "title": "Sample: IntroCategoryBaseline | BenchmarkDotNet",
    "keywords": "Sample: IntroCategoryBaseline The only way to have several baselines in the same class is to separate them by categories and mark the class with [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] . Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; namespace BenchmarkDotNet.Samples { [GroupBenchmarksBy(BenchmarkLogicalGroupRule.ByCategory)] [CategoriesColumn] public class IntroCategoryBaseline { [BenchmarkCategory(\"Fast\"), Benchmark(Baseline = true)] public void Time50() => Thread.Sleep(50); [BenchmarkCategory(\"Fast\"), Benchmark] public void Time100() => Thread.Sleep(100); [BenchmarkCategory(\"Slow\"), Benchmark(Baseline = true)] public void Time550() => Thread.Sleep(550); [BenchmarkCategory(\"Slow\"), Benchmark] public void Time600() => Thread.Sleep(600); } } Output | Method | Categories | Mean | Error | StdDev | Ratio | |-------- |----------- |----------:|----------:|----------:|------:| | Time50 | Fast | 50.46 ms | 0.0745 ms | 0.0697 ms | 1.00 | | Time100 | Fast | 100.47 ms | 0.0955 ms | 0.0893 ms | 1.99 | | | | | | | | | Time550 | Slow | 550.48 ms | 0.0525 ms | 0.0492 ms | 1.00 | | Time600 | Slow | 600.45 ms | 0.0396 ms | 0.0331 ms | 1.09 | Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroCategoryBaseline"
  },
  "articles/samples/IntroColdStart.html": {
    "href": "articles/samples/IntroColdStart.html",
    "title": "Sample: IntroColdStart | BenchmarkDotNet",
    "keywords": "Sample: IntroColdStart If you want to measure cold start (without the pilot and warmup stage), the ColdStart strategy is your choice. Usage [SimpleJob(RunStrategy.ColdStart, launchCount:50)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.ColdStart, targetCount: 5)] [MinColumn, MaxColumn, MeanColumn, MedianColumn] public class IntroColdStart { private bool firstCall; [Benchmark] public void Foo() { if (firstCall == false) { firstCall = true; Console.WriteLine(\"// First call\"); Thread.Sleep(1000); } else Thread.Sleep(10); } } } Output Result 1: 1 op, 1002034900.00 ns, 1.0020 s/op Result 2: 1 op, 10219700.00 ns, 10.2197 ms/op Result 3: 1 op, 10406200.00 ns, 10.4062 ms/op Result 4: 1 op, 10473900.00 ns, 10.4739 ms/op Result 5: 1 op, 10449400.00 ns, 10.4494 ms/op Method | Mean | Error | StdDev | Min | Max | Median | ------- |---------:|-----------:|---------:|---------:|-----------:|---------:| Foo | 208.7 ms | 1,707.4 ms | 443.5 ms | 10.22 ms | 1,002.0 ms | 10.45 ms | Links Choosing RunStrategy The permanent link to this sample: Sample: IntroColdStart"
  },
  "articles/samples/IntroConfigSource.html": {
    "href": "articles/samples/IntroConfigSource.html",
    "title": "Sample: IntroConfigSource | BenchmarkDotNet",
    "keywords": "Sample: IntroConfigSource You can define own config attribute. Source code using System; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [MyConfigSource(Jit.LegacyJit, Jit.RyuJit)] public class IntroConfigSource { /// <summary> /// Dry-x64 jobs for specific jits /// </summary> private class MyConfigSourceAttribute : Attribute, IConfigSource { public IConfig Config { get; } public MyConfigSourceAttribute(params Jit[] jits) { var jobs = jits .Select(jit => new Job(Job.Dry) { Environment = { Jit = jit, Platform = Platform.X64 } }) .ToArray(); Config = ManualConfig.CreateEmpty().AddJob(jobs); } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: Sample: IntroConfigSource"
  },
  "articles/samples/IntroConfigUnion.html": {
    "href": "articles/samples/IntroConfigUnion.html",
    "title": "Sample: IntroConfigUnion | BenchmarkDotNet",
    "keywords": "Sample: IntroConfigUnion Source code using System.Threading; using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Exporters.Csv; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Loggers; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroConfigUnion { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddLogger(ConsoleLogger.Default); AddColumn(TargetMethodColumn.Method, StatisticColumn.Max); AddExporter(RPlotExporter.Default, CsvExporter.Default); AddAnalyser(EnvironmentAnalyser.Default); UnionRule = ConfigUnionRule.AlwaysUseLocal; } } [Benchmark] public void Foo() { Thread.Sleep(10); } } } Links Configs The permanent link to this sample: Sample: IntroConfigUnion"
  },
  "articles/samples/IntroCustomMono.html": {
    "href": "articles/samples/IntroCustomMono.html",
    "title": "Sample: IntroCustomMono | BenchmarkDotNet",
    "keywords": "Sample: IntroCustomMono BenchmarkDotNet allows you to compare different runtimes, including Mono. If you apply [MonoJob] attribute to your class we use your default mono runtime. If you want to compare different versions of Mono you need to provide use the custom paths. You can do this today by using the overloaded ctor of MonoJob attribute or by specifying the runtime in a fluent way. The mono runtime can also operate as an ahead-of-time compiler. Using mono's AOT mode requires providing the AOT compilation arguments, as well as the path to mono's corlib. (See IntroCustomMonoObjectStyleAot in the below example). Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [MonoJob(\"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\")] [MonoJob(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")] public class IntroCustomMono { [Benchmark] public void Foo() { // Benchmark body } } // *** Object Style *** [Config(typeof(Config))] public class IntroCustomMonoObjectStyle { private class Config : ManualConfig { public Config() { AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); } } [Benchmark] public void Foo() { // Benchmark body } } // ** Object Style, Using AOT ** [Config(typeof(Config))] public class IntroCustomMonoObjectStyleAot { private class Config : ManualConfig { public void AddMono (string name, string mono_top_dir) { var aot_compile_args = \"--aot=llvm\"; var mono_bcl = $@\"{mono_top_dir}\\lib\\mono\\4.5\"; var mono_bin = $@\"{mono_top_dir}\\bin\\mono.exe\"; AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( name, mono_bin, aot_compile_args, mono_bcl))); } public Config() { AddMono(\"Mono x64\", @\"C:\\Program Files\\Mono\"); AddMono(\"Mono x86\", @\"C:\\Program Files (x86)\\Mono\"); } } [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroCustomMonoFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(ManualConfig .CreateMinimumViable() .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x64\", @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))) .AddJob(Job.ShortRun.WithRuntime(new MonoRuntime( \"Mono x86\", @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\")))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime The permanent link to this sample: Sample: IntroCustomMono"
  },
  "articles/samples/IntroCustomMonoArguments.html": {
    "href": "articles/samples/IntroCustomMonoArguments.html",
    "title": "Sample: IntroCustomMonoArguments | BenchmarkDotNet",
    "keywords": "Sample: IntroCustomMonoArguments Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomArguments))] public class IntroCustomMonoArguments { public class ConfigWithCustomArguments : ManualConfig { public ConfigWithCustomArguments() { // --optimize=MODE , -O=mode // MODE is a comma separated list of optimizations. They also allow // optimizations to be turned off by prefixing the optimization // name with a minus sign. AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=inline\") }) .WithId(\"Inlining enabled\")); AddJob(Job.Default .WithRuntime(MonoRuntime.Default) .WithArguments(new[] { new MonoArgument(\"--optimize=-inline\") }) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Sample() { ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); ShouldGetInlined(); } private void ShouldGetInlined() { } } } Output | Method | Job | Arguments | Mean | StdDev | |------- |------------------ |------------------- |-----------:|----------:| | Sample | Inlining disabled | --optimize=-inline | 19.4252 ns | 0.4525 ns | | Sample | Inlining enabled | --optimize=inline | 0.0000 ns | 0.0000 ns | Links Customizing Runtime The permanent link to this sample: Sample: IntroCustomMonoArguments"
  },
  "articles/samples/IntroDeferredExecution.html": {
    "href": "articles/samples/IntroDeferredExecution.html",
    "title": "Sample: IntroDeferredExecution | BenchmarkDotNet",
    "keywords": "Sample: IntroDeferredExecution In LINQ, execution of a query is usually deferred until the moment when you actually request the data. If your benchmark just returns IEnumerable or IQueryable it's not measuring the execution of the query, just the creation. This is why we decided to warn you about this issue whenever it happens: Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that. Don't worry! We are also providing you with a Consume extension method which can execute given IEnumerable or IQueryable and consume its results. All you need to do is to create a Consumer instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to Consume extension method. Do not call .ToArray() because it's an expensive operation and it might dominate given benchmark! Source code using System.Collections.Generic; using System.Linq; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { public class IntroDeferredExecution { private readonly int[] numbers = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; private readonly Consumer consumer = new Consumer(); /// <summary> /// this benchmark returns a deferred LINQ query which is NOT executed /// so the benchmark measures the cost of creating the query, not the actual execution /// this is WRONG /// You can read more about LINQ and Deferred Execution <see href=\"https://blogs.msdn.microsoft.com/charlie/2007/12/10/linq-and-deferred-execution/\">here</see> /// </summary> /// <returns>deferred LINQ query</returns> [Benchmark] public IEnumerable<int> Wrong() => from number in numbers orderby number descending select number; /// <summary> /// this benchmark uses .Consume extension method which executes given deferred query and consumes its result /// so the benchmark measures the cost of creating the query and executing it /// </summary> [Benchmark] public void Ok() => (from number in numbers orderby number descending select number).Consume(consumer); } } Links The permanent link to this sample: Sample: IntroDeferredExecution"
  },
  "articles/samples/IntroDisassembly.html": {
    "href": "articles/samples/IntroDisassembly.html",
    "title": "Sample: IntroDisassembly | BenchmarkDotNet",
    "keywords": "Sample: IntroDisassembly Source code using BenchmarkDotNet.Attributes; using System.Linq; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output ; .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.7.3110.0 05452718 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 0545271c d9ee fldz IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 0545271e 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 05452720 8945fc mov dword ptr [ebp-4],eax 05452723 db45fc fild dword ptr [ebp-4] 05452726 dec1 faddp st(1),st IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 05452728 40 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 05452729 83f840 cmp eax,40h 0545272c 7cf2 jl 05452720 IL_001c: ldloc.0 IL_001d: ret 0545272e 8be5 mov esp,ebp ; .NET Core 2.1.0 (CoreCLR 4.6.26515.07, CoreFX 4.6.26515.06), 64bit RyuJIT 00007ffa`6c621320 BenchmarkDotNet.Samples.IntroDisassembly.Sum() IL_0000: ldc.r8 0 IL_0009: stloc.0 00007ffa`6c621323 c4e17857c0 vxorps xmm0,xmm0,xmm0 IL_000a: ldc.i4.0 IL_000b: stloc.1 IL_000c: br.s IL_0017 00007ffa`6c621328 33c0 xor eax,eax IL_000e: ldloc.0 IL_000f: ldloc.1 IL_0010: conv.r8 IL_0011: add IL_0012: stloc.0 00007ffa`6c62132a c4e17057c9 vxorps xmm1,xmm1,xmm1 00007ffa`6c62132f c4e1732ac8 vcvtsi2sd xmm1,xmm1,eax 00007ffa`6c621334 c4e17b58c1 vaddsd xmm0,xmm0,xmm1 IL_0013: ldloc.1 IL_0014: ldc.i4.1 IL_0015: add IL_0016: stloc.1 00007ffa`6c621339 ffc0 inc eax IL_0017: ldloc.1 IL_0018: ldc.i4.s 64 IL_001a: blt.s IL_000e 00007ffa`6c62133b 83f840 cmp eax,40h 00007ffa`6c62133e 7cea jl 00007ffa`6c62132a IL_001c: ldloc.0 IL_001d: ret 00007ffa`6c621340 c3 ret Mono 5.12.0 (Visual Studio), 64bit Sum sub $0x18,%rsp mov %rsi,(%rsp) xorpd %xmm0,%xmm0 movsd %xmm0,0x8(%rsp) xor %esi,%esi jmp 2e xchg %ax,%ax movsd 0x8(%rsp),%xmm0 cvtsi2sd %esi,%xmm1 addsd %xmm1,%xmm0 movsd %xmm0,0x8(%rsp) inc %esi cmp $0x40,%esi jl 18 movsd 0x8(%rsp),%xmm0 mov (%rsp),%rsi add $0x18,%rsp retq Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassembly"
  },
  "articles/samples/IntroDisassemblyAllJits.html": {
    "href": "articles/samples/IntroDisassemblyAllJits.html",
    "title": "Sample: IntroDisassemblyAllJits | BenchmarkDotNet",
    "keywords": "Sample: IntroDisassemblyAllJits You can use a single config to compare the generated assembly code for ALL JITs. But to allow benchmarking any target platform architecture the project which defines benchmarks has to target AnyCPU . <PropertyGroup> <PlatformTarget>AnyCPU</PlatformTarget> </PropertyGroup> Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(MultipleJits))] public class IntroDisassemblyAllJits { public class MultipleJits : ManualConfig { public MultipleJits() { AddJob(Job.ShortRun.WithPlatform(Platform.X86).WithRuntime(new MonoRuntime(name: \"Mono x86\", customPath: @\"C:\\Program Files (x86)\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithPlatform(Platform.X64).WithRuntime(new MonoRuntime(name: \"Mono x64\", customPath: @\"C:\\Program Files\\Mono\\bin\\mono.exe\"))); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X86).WithRuntime(ClrRuntime.Net461)); AddJob(Job.ShortRun.WithJit(Jit.LegacyJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net461)); AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(ClrRuntime.Net461)); // RyuJit for .NET Core 5.0 AddJob(Job.ShortRun.WithJit(Jit.RyuJit).WithPlatform(Platform.X64).WithRuntime(CoreRuntime.Core50)); AddDiagnoser(new DisassemblyDiagnoser(new DisassemblyDiagnoserConfig(maxDepth: 3, exportDiff: true))); } } private Increment increment = new Increment(); [Benchmark] public int CallVirtualMethod() => increment.OperateTwice(10); public abstract class Operation // abstract unary integer operation { public abstract int Operate(int input); public int OperateTwice(int input) => Operate(Operate(input)); // two virtual calls to Operate } public sealed class Increment : Operation // concrete, sealed operation: increment by fixed amount { public readonly int Amount; public Increment(int amount = 1) { Amount = amount; } public override int Operate(int input) => input + Amount; } } } Output The disassembly result can be obtained here . The file was too big to embed it in this doc page. Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyAllJits"
  },
  "articles/samples/IntroDisassemblyDry.html": {
    "href": "articles/samples/IntroDisassemblyDry.html",
    "title": "Sample: IntroDisassemblyDry | BenchmarkDotNet",
    "keywords": "Sample: IntroDisassemblyDry Getting only the Disassembly without running the benchmarks for a long time. Sometimes you might be interested only in the disassembly, not the results of the benchmarks. In that case you can use Job.Dry which runs the benchmark only once . Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(maxDepth: 3)] [DryJob] public class IntroDisassemblyDry { [Benchmark] public void Foo() { } } } Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyDry"
  },
  "articles/samples/IntroDisassemblyRyuJit.html": {
    "href": "articles/samples/IntroDisassemblyRyuJit.html",
    "title": "Sample: IntroDisassemblyRyuJit | BenchmarkDotNet",
    "keywords": "Sample: IntroDisassemblyRyuJit Source code using System.Linq; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DisassemblyDiagnoser(printSource: true)] [RyuJitX64Job] public class IntroDisassemblyRyuJit { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } } Output Links Diagnosers Disassembler The permanent link to this sample: Sample: IntroDisassemblyRyuJit"
  },
  "articles/samples/IntroEnvVars.html": {
    "href": "articles/samples/IntroEnvVars.html",
    "title": "Sample: IntroEnvVars | BenchmarkDotNet",
    "keywords": "Sample: IntroEnvVars You can configure custom environment variables for the process that is running your benchmarks. One reason for doing this might be checking out how different runtime knobs affect the performance of .NET Core. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [Config(typeof(ConfigWithCustomEnvVars))] public class IntroEnvVars { private class ConfigWithCustomEnvVars : ManualConfig { private const string JitNoInline = \"COMPlus_JitNoInline\"; public ConfigWithCustomEnvVars() { AddJob(Job.Default.WithRuntime(CoreRuntime.Core21).WithId(\"Inlining enabled\")); AddJob(Job.Default.WithRuntime(CoreRuntime.Core21) .WithEnvironmentVariables(new EnvironmentVariable(JitNoInline, \"1\")) .WithId(\"Inlining disabled\")); } } [Benchmark] public void Foo() { // Benchmark body } } } Links Customizing Runtime Configs Jobs The permanent link to this sample: Sample: IntroEnvVars"
  },
  "articles/samples/IntroEventPipeProfiler.html": {
    "href": "articles/samples/IntroEventPipeProfiler.html",
    "title": "Sample: EventPipeProfiler | BenchmarkDotNet",
    "keywords": "Sample: EventPipeProfiler The EventPipeProfiler can be enabled using the [EventPipeProfiler(...)] attribute. This attribute takes the following profiles: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [ShortRunJob] [EventPipeProfiler(EventPipeProfile.CpuSampling)] public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope . // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfiler.Sleep-20200406-090113.speedscope.json"
  },
  "articles/samples/IntroEventPipeProfilerAdvanced.html": {
    "href": "articles/samples/IntroEventPipeProfilerAdvanced.html",
    "title": "Sample: EventPipeProfilerAdvanced | BenchmarkDotNet",
    "keywords": "Sample: EventPipeProfilerAdvanced The most advanced and powerful way to use EventPipeProfiler is a custom configuration. As you can see the below configuration adds EventPipeProfiler that constructor can take the profile and/or a list of providers. Both EventPipeProfiler and dotnet trace use the Microsoft.Diagnostics.NETCore.Client package internally. So before you start using the custom configuration of this profiler, it is worth reading the documentation here and here where you can find more information about how to configure provider list. Source code using System.Buffers; using System.Diagnostics.Tracing; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Diagnosers; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using Microsoft.Diagnostics.NETCore.Client; using Microsoft.Diagnostics.Tracing.Parsers; namespace BenchmarkDotNet.Samples { [Config(typeof(CustomConfig))] public class IntroEventPipeProfilerAdvanced { private class CustomConfig : ManualConfig { public CustomConfig() { AddJob(Job.ShortRun.WithRuntime(CoreRuntime.Core50)); var providers = new[] { new EventPipeProvider(ClrTraceEventParser.ProviderName, EventLevel.Verbose, (long) (ClrTraceEventParser.Keywords.Exception | ClrTraceEventParser.Keywords.GC | ClrTraceEventParser.Keywords.Jit | ClrTraceEventParser.Keywords.JitTracing // for the inlining events | ClrTraceEventParser.Keywords.Loader | ClrTraceEventParser.Keywords.NGen)), new EventPipeProvider(\"System.Buffers.ArrayPoolEventSource\", EventLevel.Informational, long.MaxValue), }; AddDiagnoser(new EventPipeProfiler(providers: providers)); } } [Benchmark] public void RentAndReturn_Shared() { var pool = ArrayPool<byte>.Shared; byte[] array = pool.Rent(10000); pool.Return(array); } } } Output The output should contain information about the exported trace file which can be analyzed using SpeedScope . // * Diagnostic Output - EventPipeProfiler * Exported 1 trace file(s). Example: C:\\Work\\BenchmarkDotNet\\samples\\BenchmarkDotNet.Samples\\BenchmarkDotNet.Artifacts\\BenchmarkDotNet.Samples.IntroEventPipeProfilerAdvanced.RentAndReturn_Shared-20200406-090136.speedscope.json"
  },
  "articles/samples/IntroExport.html": {
    "href": "articles/samples/IntroExport.html",
    "title": "Sample: IntroExport | BenchmarkDotNet",
    "keywords": "Sample: IntroExport BenchmarkDotNet has a lot of predefined exporters. Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [ShortRunJob] [MediumRunJob] [KeepBenchmarkFiles] [AsciiDocExporter] [CsvExporter] [CsvMeasurementsExporter] [HtmlExporter] [PlainExporter] [RPlotExporter] [JsonExporterAttribute.Brief] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.Full] [JsonExporterAttribute.FullCompressed] [MarkdownExporterAttribute.Default] [MarkdownExporterAttribute.GitHub] [MarkdownExporterAttribute.StackOverflow] [MarkdownExporterAttribute.Atlassian] [XmlExporterAttribute.Brief] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.Full] [XmlExporterAttribute.FullCompressed] public class IntroExport { private Random random = new Random(42); [Benchmark(Baseline = true)] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep50Noisy() => Thread.Sleep(random.Next(100)); } } Links Exporters The permanent link to this sample: Sample: IntroExport"
  },
  "articles/samples/IntroExportJson.html": {
    "href": "articles/samples/IntroExportJson.html",
    "title": "Sample: IntroExportJson | BenchmarkDotNet",
    "keywords": "Sample: IntroExportJson BenchmarkDotNet has a set of json exporters. You can customize the following properties of these exporters: fileNameSuffix : a string which be placed in the end of target file name. indentJson = false / true : should we format json or not. excludeMeasurements = false / true : should we exclude detailed information about measurements or not (the final summary with statistics will be in the json file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters.Json; namespace BenchmarkDotNet.Samples { // *** Attribute style *** [DryJob] [JsonExporterAttribute.Brief] [JsonExporterAttribute.Full] [JsonExporterAttribute.BriefCompressed] [JsonExporterAttribute.FullCompressed] [JsonExporter(\"-custom\", indentJson: true, excludeMeasurements: true)] public class IntroExportJson { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } // *** Object style *** [Config(typeof(Config))] public class IntroJsonExportObjectStyle { private class Config : ManualConfig { public Config() { AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Brief); AddExporter(JsonExporter.Full); AddExporter(JsonExporter.BriefCompressed); AddExporter(JsonExporter.FullCompressed); AddExporter(JsonExporter.Custom(\"-custom\", indentJson: true, excludeMeasurements: true)); } } [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroJsonExport-report-brief.json : { \"Title\":\"IntroJsonExport\", \"HostEnvironmentInfo\":{ \"BenchmarkDotNetCaption\":\"BenchmarkDotNet-Dev.Core\", \"BenchmarkDotNetVersion\":\"0.9.9.0\", \"OsVersion\":\"Microsoft Windows NT 6.2.9200.0\", \"ProcessorName\":{ \"IsValueCreated\":true, \"Value\":\"Intel(R) Core(TM) i7-4702MQ CPU 2.20GHz\" }, \"ProcessorCount\":8, \"ClrVersion\":\"MS.NET 4.0.30319.42000\", \"Architecture\":\"64-bit\", \"HasAttachedDebugger\":false, \"HasRyuJit\":true, \"Configuration\":\"RELEASE\", \"JitModules\":\"clrjit-v4.6.1586.0\", \"DotNetCliVersion\":\"1.0.0-preview2-003121\", \"ChronometerFrequency\":2143474, \"HardwareTimerKind\":\"Tsc\" }, \"Benchmarks\":[ { \"ShortInfo\":\"IntroJsonExport_Sleep10\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep10\", \"MethodTitle\":\"Sleep10\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"TargetCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":10265993.7209375, \"LowerFence\":10255329.082734371, \"Q1\":10337369.528437499, \"Median\":10360382.6953125, \"Mean\":10362283.085796878, \"Q3\":10392063.158906251, \"UpperFence\":10474103.60460938, \"Max\":10436008.3209375, \"InterquartileRange\":54693.630468752235, \"Outliers\":[ ], \"StandardError\":10219.304338928456, \"Variance\":2088683623.4328396, \"StandardDeviation\":45702.118369205156, \"Skewness\":-0.1242777170069375, \"Kurtosis\":2.31980277935226, \"ConfidenceInterval\":{ \"Mean\":10362283.085796878, \"Error\":10219.304338928456, \"Level\":6, \"Margin\":20029.836504299772, \"Lower\":10342253.249292579, \"Upper\":10382312.922301177 }, \"Percentiles\":{ \"P0\":10265993.7209375, \"P25\":10338555.905625, \"P50\":10360382.6953125, \"P67\":10373496.555659376, \"P80\":10400703.4841875, \"P85\":10417280.326718749, \"P90\":10424125.595812501, \"P95\":10435620.51609375, \"P100\":10436008.3209375 } } },{ \"ShortInfo\":\"IntroJsonExport_Sleep20\", \"Namespace\":\"BenchmarkDotNet.Samples.Intro\", \"Type\":\"IntroJsonExport\", \"Method\":\"Sleep20\", \"MethodTitle\":\"Sleep20\", \"Parameters\":\"\", \"Properties\":{ \"Mode\":\"Throughput\", \"Platform\":\"Host\", \"Jit\":\"Host\", \"Runtime\":\"Host\", \"GcMode\":\"Host\", \"WarmupCount\":\"Auto\", \"TargetCount\":\"Auto\", \"LaunchCount\":\"Auto\", \"IterationTime\":\"Auto\", \"Affinity\":\"Auto\" }, \"Statistics\":{ \"N\":20, \"Min\":20258672.37, \"LowerFence\":20206333.269843742, \"Q1\":20325342.761249997, \"Median\":20362636.192500003, \"Mean\":20360791.931687497, \"Q3\":20404682.4221875, \"UpperFence\":20523691.913593754, \"Max\":20422396.073125, \"InterquartileRange\":79339.66093750298, \"Outliers\":[ ], \"StandardError\":10728.817907277158, \"Variance\":2302150673.7502208, \"StandardDeviation\":47980.732317777525, \"Skewness\":-0.50826238372439869, \"Kurtosis\":2.11050327966268, \"ConfidenceInterval\":{ \"Mean\":20360791.931687497, \"Error\":10728.817907277158, \"Level\":6, \"Margin\":21028.48309826323, \"Lower\":20339763.448589232, \"Upper\":20381820.414785761 }, \"Percentiles\":{ \"P0\":20258672.37, \"P25\":20327638.975312497, \"P50\":20362636.192500003, \"P67\":20391669.3762875, \"P80\":20406370.68625, \"P85\":20412542.034406248, \"P90\":20414412.5376875, \"P95\":20416606.697718751, \"P100\":20422396.073125 } } } ] } Links Exporters The permanent link to this sample: Sample: IntroExportJson"
  },
  "articles/samples/IntroExportXml.html": {
    "href": "articles/samples/IntroExportXml.html",
    "title": "Sample: IntroExportXml | BenchmarkDotNet",
    "keywords": "Sample: IntroExportXml BenchmarkDotNet has a set of XML exporters. You can customize the following properties of these exporters: fileNameSuffix : a string which be placed in the end of target file name. indentXml = false / true : should we format xml or not. excludeMeasurements = false / true : should we exclude detailed information about measurements or not (the final summary with statistics will be in the XML file anyway). Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [DryJob] [XmlExporterAttribute.Brief] [XmlExporterAttribute.Full] [XmlExporterAttribute.BriefCompressed] [XmlExporterAttribute.FullCompressed] [XmlExporter(\"-custom\", indentXml: true, excludeMeasurements: true)] public class IntroExportXml { [Benchmark] public void Sleep10() => Thread.Sleep(10); [Benchmark] public void Sleep20() => Thread.Sleep(20); } } Output Example of IntroXmlExport-report-brief.xml : <?xml version=\"1.0\" encoding=\"utf-8\"?> <Summary> <Title>IntroXmlExport</Title> <HostEnvironmentInfo> <BenchmarkDotNetCaption>BenchmarkDotNet</BenchmarkDotNetCaption> <BenchmarkDotNetVersion>0.10.9.20170805-develop</BenchmarkDotNetVersion> <OsVersion>Windows 10 Redstone 2 (10.0.15063)</OsVersion> <ProcessorName>Intel Core i7-3770K CPU 3.50GHz (Ivy Bridge)</ProcessorName> <ProcessorCount>8</ProcessorCount> <RuntimeVersion>.NET Framework 4.7 (CLR 4.0.30319.42000)</RuntimeVersion> <Architecture>64bit</Architecture> <HasAttachedDebugger>False</HasAttachedDebugger> <HasRyuJit>True</HasRyuJit> <Configuration>RELEASE</Configuration> <JitModules>clrjit-v4.7.2101.1</JitModules> <DotNetSdkVersion>1.0.4</DotNetSdkVersion> <ChronometerFrequency> <Hertz>3410220</Hertz> </ChronometerFrequency> <HardwareTimerKind>Tsc</HardwareTimerKind> </HostEnvironmentInfo> <Benchmarks> <Benchmark> <DisplayInfo>IntroXmlExport.Sleep10: DefaultJob</DisplayInfo> <Namespace>BenchmarkDotNet.Samples.Intro</Namespace> <Type>IntroXmlExport</Type> <Method>Sleep10</Method> <MethodTitle>Sleep10</MethodTitle> <Statistics> <N>15</N> <Min>10989865.8785938</Min> <LowerFence>10989836.0967969</LowerFence> <Q1>10990942.6053125</Q1> <Median>10991249.5870313</Median> <Mean>10991270.0524583</Mean> <Q3>10991680.2776563</Q3> <UpperFence>10992786.7861719</UpperFence> <Max>10992115.5501563</Max> <InterquartileRange>737.672343749553</InterquartileRange> <StandardError>148.484545262958</StandardError> <Variance>330714.902729213</Variance> <StandardDeviation>575.07817097262</StandardDeviation> <Skewness>-0.67759778074187</Skewness> <Kurtosis>3.14296703520386</Kurtosis> <ConfidenceInterval> <N>15</N> <Mean>10991270.0524583</Mean> <StandardError>148.484545262958</StandardError> <Level>L999</Level> <Margin>614.793505974065</Margin> <Lower>10990655.2589524</Lower> <Upper>10991884.8459643</Upper> </ConfidenceInterval> <Percentiles> <P0>10989865.8785938</P0> <P25>10991027.3689063</P25> <P50>10991249.5870313</P50> <P67>10991489.490875</P67> <P80>10991696.7722187</P80> <P85>10991754.5031875</P85> <P90>10991933.1939688</P90> <P95>10992067.441125</P95> <P100>10992115.5501563</P100> </Percentiles> </Statistics> </Benchmark> </Benchmarks> </Summary> Links Exporters The permanent link to this sample: Sample: IntroExportXml"
  },
  "articles/samples/IntroFilters.html": {
    "href": "articles/samples/IntroFilters.html",
    "title": "Sample: IntroFilters | BenchmarkDotNet",
    "keywords": "Sample: IntroFilters You can either use one of the predefined Filter types or create a custom type which implements IFilter interface. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Filters; namespace BenchmarkDotNet.Samples { [DryJob] [Config(typeof(Config))] public class IntroFilters { private class Config : ManualConfig { // We will benchmark ONLY method with // names (which contains \"A\" OR \"1\") AND (have length < 3) public Config() { // benchmark with names which contains \"A\" OR \"1\" AddFilter(new DisjunctionFilter( new NameFilter(name => name.Contains(\"A\")), new NameFilter(name => name.Contains(\"1\")) )); // benchmark with names with length < 3 AddFilter(new NameFilter(name => name.Length < 3)); } } [Benchmark] public void A1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A2() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void A3() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void B2() => Thread.Sleep(10); [Benchmark] public void B3() => Thread.Sleep(10); [Benchmark] public void C1() => Thread.Sleep(10); // Will be benchmarked [Benchmark] public void C2() => Thread.Sleep(10); [Benchmark] public void C3() => Thread.Sleep(10); [Benchmark] public void Aaa() => Thread.Sleep(10); } } Links Filters The permanent link to this sample: Sample: IntroFilters"
  },
  "articles/samples/IntroFluentConfigBuilder.html": {
    "href": "articles/samples/IntroFluentConfigBuilder.html",
    "title": "Sample: IntroFluentConfigBuilder | BenchmarkDotNet",
    "keywords": "Sample: IntroFluentConfigBuilder There is no need to create new Config type, you can simply use fluent interface. Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using BenchmarkDotNet.Validators; namespace BenchmarkDotNet.Samples { public class Algo_Md5VsSha256 { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public Algo_Md5VsSha256() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } public class IntroFluentConfigBuilder { public static void Run() { BenchmarkRunner .Run<Algo_Md5VsSha256>( DefaultConfig.Instance .AddJob(Job.Default.WithRuntime(ClrRuntime.Net461)) .AddJob(Job.Default.WithRuntime(CoreRuntime.Core21)) .AddValidator(ExecutionValidator.FailOnError)); } } } Links Configs The permanent link to this sample: Sample: IntroFluentConfigBuilder"
  },
  "articles/samples/IntroGcMode.html": {
    "href": "articles/samples/IntroGcMode.html",
    "title": "Sample: IntroGcMode | BenchmarkDotNet",
    "keywords": "Sample: IntroGcMode Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroGcMode { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(true).WithId(\"ServerForce\")); AddJob(Job.MediumRun.WithGcServer(true).WithGcForce(false).WithId(\"Server\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(true).WithId(\"Workstation\")); AddJob(Job.MediumRun.WithGcServer(false).WithGcForce(false).WithId(\"WorkstationForce\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Jobs The permanent link to this sample: Sample: IntroGcMode"
  },
  "articles/samples/IntroGenericTypeArguments.html": {
    "href": "articles/samples/IntroGenericTypeArguments.html",
    "title": "Sample: IntroGenericTypeArguments | BenchmarkDotNet",
    "keywords": "Sample: IntroGenericTypeArguments Source code using System; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [GenericTypeArguments(typeof(int))] [GenericTypeArguments(typeof(char))] public class IntroGenericTypeArguments<T> { [Benchmark] public T Create() => Activator.CreateInstance<T>(); } } Links The permanent link to this sample: Sample: IntroGenericTypeArguments"
  },
  "articles/samples/IntroHardwareCounters.html": {
    "href": "articles/samples/IntroHardwareCounters.html",
    "title": "Sample: IntroHardwareCounters | BenchmarkDotNet",
    "keywords": "Sample: IntroHardwareCounters This diagnoser is not enabled in explicit way as the other diagnosers. You need to specify [HardwareCounters] and we choose the right diagnoser in the runtime. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnosers; namespace BenchmarkDotNet.Samples { [HardwareCounters( HardwareCounter.BranchMispredictions, HardwareCounter.BranchInstructions)] public class IntroHardwareCounters { private const int N = 32767; private readonly int[] sorted, unsorted; public IntroHardwareCounters() { var random = new Random(0); unsorted = new int[N]; sorted = new int[N]; for (int i = 0; i < N; i++) sorted[i] = unsorted[i] = random.Next(256); Array.Sort(sorted); } private static int Branch(int[] data) { int sum = 0; for (int i = 0; i < N; i++) if (data[i] >= 128) sum += data[i]; return sum; } private static int Branchless(int[] data) { int sum = 0; for (int i = 0; i < N; i++) { int t = (data[i] - 128) >> 31; sum += ~t & data[i]; } return sum; } [Benchmark] public int SortedBranch() => Branch(sorted); [Benchmark] public int UnsortedBranch() => Branch(unsorted); [Benchmark] public int SortedBranchless() => Branchless(sorted); [Benchmark] public int UnsortedBranchless() => Branchless(unsorted); } } Output Method Mean Mispredict rate BranchInstructions/Op BranchMispredictions/Op SortedBranch 21.4539 us 0,04% 70121 24 UnsortedBranch 136.1139 us 23,70% 68788 16301 SortedBranchless 28.6705 us 0,06% 35711 22 UnsortedBranchless 28.9336 us 0,05% 35578 17 Links Diagnosers The permanent link to this sample: Sample: IntroHardwareCounters"
  },
  "articles/samples/IntroInliningDiagnoser.html": {
    "href": "articles/samples/IntroInliningDiagnoser.html",
    "title": "Sample: IntroInliningDiagnoser | BenchmarkDotNet",
    "keywords": "Sample: IntroInliningDiagnoser This sample shows how to add InliningDiagnoser with events from only one namespace (BenchmarkDotNet.Samples). Source code using BenchmarkDotNet.Attributes; using System.Runtime.CompilerServices; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.InliningDiagnoser(logFailuresOnly: false, allowedNamespaces: new[] { \"BenchmarkDotNet.Samples\" })] public class IntroInliningDiagnoser { [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) { j = i + AddThree(i); } return j + ReturnFive() + AddThree(ReturnFive()); } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; private int ReturnFive() { return 5; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private int AddThree(int a) { return a + 3; } } }"
  },
  "articles/samples/IntroInProcess.html": {
    "href": "articles/samples/IntroInProcess.html",
    "title": "Sample: IntroInProcess | BenchmarkDotNet",
    "keywords": "Sample: IntroInProcess InProcessEmitToolchain is our toolchain which does not generate any new executable. It emits IL on the fly and runs it from within the process itself. It can be useful if want to run the benchmarks very fast or if you want to run them for framework which we don't support. An example could be a local build of CoreCLR. Usage [InProcessAttribute] public class TypeWithBenchmarks { } Source code using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcess { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun .WithLaunchCount(1) .WithId(\"OutOfProc\")); AddJob(Job.MediumRun .WithLaunchCount(1) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: Sample: IntroInProcess"
  },
  "articles/samples/IntroInProcessWrongEnv.html": {
    "href": "articles/samples/IntroInProcessWrongEnv.html",
    "title": "Sample: IntroInProcessWrongEnv | BenchmarkDotNet",
    "keywords": "Sample: IntroInProcessWrongEnv Source code using System; using System.Runtime.CompilerServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Toolchains.InProcess; using BenchmarkDotNet.Toolchains.InProcess.Emit; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [MemoryDiagnoser] public class IntroInProcessWrongEnv { private class Config : ManualConfig { public Config() { var wrongPlatform = Environment.Is64BitProcess ? Platform.X64 : Platform.X86; AddJob(Job.MediumRun .WithLaunchCount(1) .WithPlatform(wrongPlatform) .WithToolchain(InProcessEmitToolchain.Instance) .WithId(\"InProcess\")); AddValidator(InProcessValidator.DontFailOnError); } } [Benchmark(Description = \"new byte[10kB]\")] public byte[] Allocate() { return new byte[10000]; } [Benchmark(Description = \"stackalloc byte[10kB]\")] public unsafe void AllocateWithStackalloc() { var array = stackalloc byte[10000]; Consume(array); } [MethodImpl(MethodImplOptions.NoInlining)] private static unsafe void Consume(byte* input) { } } } Output Links Toolchains The permanent link to this sample: Sample: IntroInProcessWrongEnv"
  },
  "articles/samples/IntroJobBaseline.html": {
    "href": "articles/samples/IntroJobBaseline.html",
    "title": "Sample: IntroJobBaseline | BenchmarkDotNet",
    "keywords": "Sample: IntroJobBaseline If you want to compare several runtime configuration, you can mark one of your jobs with baseline = true . Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(runtimeMoniker: RuntimeMoniker.Net461, baseline: true)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Mono)] [SimpleJob(runtimeMoniker: RuntimeMoniker.Net50)] public class IntroJobBaseline { [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Output BenchmarkDotNet=v0.10.12, OS=Windows 10 Redstone 3 [1709, Fall Creators Update] (10.0.16299.192) Processor=Intel Core i7-6700HQ CPU 2.60GHz (Skylake), ProcessorCount=8 Frequency=2531249 Hz, Resolution=395.0619 ns, Timer=TSC .NET Core SDK=2.0.3 [Host] : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Job-MXFYPZ : .NET Framework 4.7 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.2600.0 Core : .NET Core 2.0.3 (Framework 4.6.25815.02), 64bit RyuJIT Mono : Mono 5.4.0 (Visual Studio), 64bit Method | Runtime | Mean | Error | StdDev | Ratio | RatioSD | ---------- |-------- |---------:|----------:|----------:|------:|--------:| SplitJoin | Clr | 19.42 us | 0.2447 us | 0.1910 us | 1.00 | 0.00 | SplitJoin | Core | 13.00 us | 0.2183 us | 0.1935 us | 0.67 | 0.01 | SplitJoin | Mono | 39.14 us | 0.7763 us | 1.3596 us | 2.02 | 0.07 | Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroJobBaseline"
  },
  "articles/samples/IntroJoin.html": {
    "href": "articles/samples/IntroJoin.html",
    "title": "Sample: IntroJoin | BenchmarkDotNet",
    "keywords": "Sample: IntroJoin If you are using BenchmarkSwitcher and want to run all the benchmarks with a category from all types and join them into one summary table, use the --join option (or BenchmarkSwitcher.RunAllJoined ): Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { // Run BenchmarkSwitcher with arguments: \"--join --category=IntroJoinA\" [DryJob] public class IntroJoin1 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } [DryJob] public class IntroJoin2 { [Benchmark] [BenchmarkCategory(\"IntroJoinA\")] public void A() => Thread.Sleep(10); [Benchmark] [BenchmarkCategory(\"IntroJoinB\")] public void B() => Thread.Sleep(10); } } Command line --join --allCategories=IntroJoinA Output | Type | Method | Mean | Error | |----------- |------- |---------:|------:| | IntroJoin1 | A | 10.99 ms | NA | | IntroJoin2 | A | 12.50 ms | NA | Links Filters The permanent link to this sample: Sample: IntroJoin"
  },
  "articles/samples/IntroMonitoring.html": {
    "href": "articles/samples/IntroMonitoring.html",
    "title": "Sample: IntroMonitoring | BenchmarkDotNet",
    "keywords": "Sample: IntroMonitoring If a benchmark method takes at least 100ms, you can also use the Monitoring strategy. In this case, the pilot stage will be omitted, by default you get 1 iteration = 1 operation (or you can manually set amount of operation in an iteration). Also you can use [IterationSetup] and [IterationCleanup] in this case: it shouldn't affect time measurements (but it can affect results of MemoryDiagnoser). It's a perfect mode for benchmarks which doesn't have a steady state and the performance distribution is tricky: Monitoring will help you to collect a set of measurements and get statistics. Usage [SimpleJob(RunStrategy.Monitoring, launchCount: 10, warmupCount: 0, targetCount: 100)] public class MyBenchmarkClass Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, targetCount: 10, id: \"MonitoringJob\")] [MinColumn, Q1Column, Q3Column, MaxColumn] public class IntroMonitoring { private Random random = new Random(42); [Benchmark] public void Foo() { Thread.Sleep(random.Next(10) * 10); } } } Output Result 1: 1 op, 61552600.00 ns, 61.5526 ms/op Result 2: 1 op, 10141700.00 ns, 10.1417 ms/op Result 3: 1 op, 10482900.00 ns, 10.4829 ms/op Result 4: 1 op, 50410900.00 ns, 50.4109 ms/op Result 5: 1 op, 10421400.00 ns, 10.4214 ms/op Result 6: 1 op, 20556100.00 ns, 20.5561 ms/op Result 7: 1 op, 70473200.00 ns, 70.4732 ms/op Result 8: 1 op, 50581700.00 ns, 50.5817 ms/op Result 9: 1 op, 10559000.00 ns, 10.5590 ms/op Result 10: 1 op, 70496300.00 ns, 70.4963 ms/op Method Mean Error StdDev Min Q1 Q3 Max Foo 36.57 ms 40.03 ms 26.47 ms 10.14 ms 10.48 ms 61.55 ms 70.50 ms Links Choosing RunStrategy The permanent link to this sample: Sample: IntroMonitoring"
  },
  "articles/samples/IntroMultimodal.html": {
    "href": "articles/samples/IntroMultimodal.html",
    "title": "Sample: IntroMultimodal | BenchmarkDotNet",
    "keywords": "Sample: IntroMultimodal Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [MValueColumn] [SimpleJob(RunStrategy.Throughput, 1, 0, -1, 1, \"MyJob\")] public class IntroMultimodal { private readonly Random rnd = new Random(42); private void Multimodal(int n) => Thread.Sleep((rnd.Next(n) + 1) * 100); [Benchmark] public void Unimodal() => Multimodal(1); [Benchmark] public void Bimodal() => Multimodal(2); [Benchmark] public void Trimodal() => Multimodal(3); [Benchmark] public void Quadrimodal() => Multimodal(4); } } Output Method | Mean | Error | StdDev | Median | MValue | ------------ |---------:|-----------:|------------:|---------:|-------:| Unimodal | 100.5 ms | 0.0713 ms | 0.0667 ms | 100.5 ms | 2.000 | Bimodal | 144.5 ms | 16.9165 ms | 49.8787 ms | 100.6 ms | 3.571 | Trimodal | 182.5 ms | 27.4285 ms | 80.8734 ms | 200.5 ms | 4.651 | Quadrimodal | 226.6 ms | 37.2269 ms | 109.7644 ms | 200.7 ms | 5.882 | // * Warnings * MultimodalDistribution IntroMultimodal.Bimodal: MainJob -> It seems that the distribution is bimodal (mValue = 3.57) IntroMultimodal.Trimodal: MainJob -> It seems that the distribution is multimodal (mValue = 4.65) IntroMultimodal.Quadrimodal: MainJob -> It seems that the distribution is multimodal (mValue = 5.88) Links Statistics The permanent link to this sample: Sample: IntroMultimodal"
  },
  "articles/samples/IntroNativeMemory.html": {
    "href": "articles/samples/IntroNativeMemory.html",
    "title": "Sample: IntroNativeMemory | BenchmarkDotNet",
    "keywords": "Sample: IntroNativeMemory The NativeMemoryProfiler uses EtwProfiler to profile the code using ETW and adds the extra columns Allocated native memory and Native memory leak to the benchmark results table. Source code using System; using System.Drawing; using System.Runtime.InteropServices; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Diagnostics.Windows.Configs; namespace BenchmarkDotNet.Samples { [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } } Output Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B Profiling memory leaks The BenchmarkDotNet repeats benchmarking function many times. Sometimes it can cause a memory overflow. In this case, the BenchmarkDotNet shows the message: OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. In this case, you should try to reduce the number of invocation, by adding [ShortRunJob] attribute or using Job.Short for custom configuration. Links Diagnosers The permanent link to this sample: Sample: IntroNativeMemory"
  },
  "articles/samples/IntroNuGet.html": {
    "href": "articles/samples/IntroNuGet.html",
    "title": "Sample: IntroNuGet | BenchmarkDotNet",
    "keywords": "Sample: IntroNuGet You can set specific versions of NuGet dependencies for each job. It allows comparing different versions of the same package (if there are no breaking changes in API). Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Newtonsoft.Json; namespace BenchmarkDotNet.Samples { /// <summary> /// Benchmarks between various versions of a NuGet package /// </summary> /// <remarks> /// Only supported with the CsProjCoreToolchain toolchain /// </remarks> [Config(typeof(Config))] public class IntroNuGet { // Specify jobs with different versions of the same NuGet package to benchmark. // The NuGet versions referenced on these jobs must be greater or equal to the // same NuGet version referenced in this benchmark project. // Example: This benchmark project references Newtonsoft.Json 9.0.1 private class Config : ManualConfig { public Config() { var baseJob = Job.MediumRun; AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\")); AddJob(baseJob.WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\")); } } [Benchmark] public void SerializeAnonymousObject() => JsonConvert.SerializeObject( new { hello = \"world\", price = 1.99, now = DateTime.UtcNow }); } } Output Method Job NuGetReferences Mean Error StdDev SerializeAnonymousObject 10.0.1 Newtonsoft.Json 10.0.1 2.926 us 0.0795 us 0.0283 us SerializeAnonymousObject 10.0.2 Newtonsoft.Json 10.0.2 2.877 us 0.5928 us 0.2114 us SerializeAnonymousObject 10.0.3 Newtonsoft.Json 10.0.3 2.706 us 0.1251 us 0.0446 us SerializeAnonymousObject 11.0.1 Newtonsoft.Json 11.0.1 2.778 us 0.5037 us 0.1796 us SerializeAnonymousObject 11.0.2 Newtonsoft.Json 11.0.2 2.644 us 0.0609 us 0.0217 us SerializeAnonymousObject 9.0.1 Newtonsoft.Json 9.0.1 2.722 us 0.3552 us 0.1267 us Links The permanent link to this sample: Sample: IntroNuGet"
  },
  "articles/samples/IntroOrderAttr.html": {
    "href": "articles/samples/IntroOrderAttr.html",
    "title": "Sample: IntroOrderAttr | BenchmarkDotNet",
    "keywords": "Sample: IntroOrderAttr Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [Orderer(SummaryOrderPolicy.FastestToSlowest, MethodOrderPolicy.Declared)] [DryJob] public class IntroOrderAttr { [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Slow() => Thread.Sleep(X * 100); [Benchmark] public void Fast() => Thread.Sleep(X * 50); } } Links Orderers The permanent link to this sample: Sample: IntroOrderAttr"
  },
  "articles/samples/IntroOrderManual.html": {
    "href": "articles/samples/IntroOrderManual.html",
    "title": "Sample: IntroOrderManual | BenchmarkDotNet",
    "keywords": "Sample: IntroOrderManual Source code using System.Collections.Generic; using System.Collections.Immutable; using System.Linq; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Order; using BenchmarkDotNet.Reports; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] [DryJob] [RankColumn] public class IntroOrderManual { private class Config : ManualConfig { public Config() => Orderer = new FastestToSlowestOrderer(); private class FastestToSlowestOrderer : IOrderer { public IEnumerable<BenchmarkCase> GetExecutionOrder(ImmutableArray<BenchmarkCase> benchmarksCase) => from benchmark in benchmarksCase orderby benchmark.Parameters[\"X\"] descending, benchmark.Descriptor.WorkloadMethodDisplayInfo select benchmark; public IEnumerable<BenchmarkCase> GetSummaryOrder(ImmutableArray<BenchmarkCase> benchmarksCase, Summary summary) => from benchmark in benchmarksCase orderby summary[benchmark].ResultStatistics.Mean select benchmark; public string GetHighlightGroupKey(BenchmarkCase benchmarkCase) => null; public string GetLogicalGroupKey(ImmutableArray<BenchmarkCase> allBenchmarksCases, BenchmarkCase benchmarkCase) => benchmarkCase.Job.DisplayInfo + \"_\" + benchmarkCase.Parameters.DisplayInfo; public IEnumerable<IGrouping<string, BenchmarkCase>> GetLogicalGroupOrder(IEnumerable<IGrouping<string, BenchmarkCase>> logicalGroups) => logicalGroups.OrderBy(it => it.Key); public bool SeparateLogicalGroups => true; } } [Params(1, 2, 3)] public int X { get; set; } [Benchmark] public void Fast() => Thread.Sleep(X * 50); [Benchmark] public void Slow() => Thread.Sleep(X * 100); } } Links Orderers The permanent link to this sample: Sample: IntroOrderManual"
  },
  "articles/samples/IntroOutliers.html": {
    "href": "articles/samples/IntroOutliers.html",
    "title": "Sample: IntroOutliers | BenchmarkDotNet",
    "keywords": "Sample: IntroOutliers Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroOutliers { private class Config : ManualConfig { public Config() { var jobBase = Job.Default.WithWarmupCount(0).WithIterationCount(10).WithInvocationCount(1).WithUnrollFactor(1); AddJob(jobBase.WithOutlierMode(OutlierMode.DontRemove).WithId(\"DontRemoveOutliers\")); AddJob(jobBase.WithOutlierMode(OutlierMode.RemoveUpper).WithId(\"RemoveUpperOutliers\")); } } private int counter; [Benchmark] public void Foo() { counter++; int noise = counter % 10 == 0 ? 500 : 0; Thread.Sleep(100 + noise); } } } Output Method | Job | OutlierMode | Mean | Error | StdDev | ------- |-------------------- |------------ |---------:|------------:|------------:| Foo | DontRemoveOutliers | DontRemove | 150.5 ms | 239.1911 ms | 158.2101 ms | Foo | RemoveUpperOutliers | RemoveUpper | 100.5 ms | 0.1931 ms | 0.1149 ms | // * Hints * Outliers IntroOutliers.Foo: DontRemoveOutliers -> 1 outlier was detected IntroOutliers.Foo: RemoveUpperOutliers -> 1 outlier was removed Links Statistics The permanent link to this sample: Sample: IntroOutliers"
  },
  "articles/samples/IntroParams.html": {
    "href": "articles/samples/IntroParams.html",
    "title": "Sample: IntroParams | BenchmarkDotNet",
    "keywords": "Sample: IntroParams You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you can specify set of values. Every value must be a compile-time constant. As a result, you will get results for each combination of params values. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParams { [Params(100, 200)] public int A { get; set; } [Params(10, 20)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | A | B | Mean | Error | StdDev | |---------- |---- |--- |---------:|--------:|--------:| | Benchmark | 100 | 10 | 115.3 ms | 0.13 ms | 0.12 ms | | Benchmark | 100 | 20 | 125.4 ms | 0.14 ms | 0.12 ms | | Benchmark | 200 | 10 | 215.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 200 | 20 | 225.4 ms | 0.17 ms | 0.16 ms | Links Parameterization The permanent link to this sample: Sample: IntroParams"
  },
  "articles/samples/IntroParamsAllValues.html": {
    "href": "articles/samples/IntroParamsAllValues.html",
    "title": "Sample: IntroParamsAllValues | BenchmarkDotNet",
    "keywords": "Sample: IntroParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T> , where T is an enum or boolean Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [DryJob] public class IntroParamsAllValues { public enum CustomEnum { One = 1, Two, Three } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( (int)E * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } } Output Method | E | B | Mean | Error | ---------- |------ |------ |---------:|------:| Benchmark | One | ? | 101.4 ms | NA | Benchmark | One | False | 111.1 ms | NA | Benchmark | One | True | 122.0 ms | NA | Benchmark | Two | ? | 201.3 ms | NA | Benchmark | Two | False | 212.1 ms | NA | Benchmark | Two | True | 221.3 ms | NA | Benchmark | Three | ? | 301.4 ms | NA | Benchmark | Three | False | 311.5 ms | NA | Benchmark | Three | True | 320.8 ms | NA | Links Parameterization The permanent link to this sample: Sample: IntroParamsAllValues"
  },
  "articles/samples/IntroParamsPriority.html": {
    "href": "articles/samples/IntroParamsPriority.html",
    "title": "Sample: IntroParamsPriority | BenchmarkDotNet",
    "keywords": "Sample: IntroParamsPriority In order to sort columns of parameters in the results table you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue] , lower priorites will appear earlier in the column order. The default priority is set to 0 . Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.4 ms | 0.12 ms | 0.11 ms | Links Priority BaseClass PriorityAttribute.cs Parameterization The permanent link to this sample: Sample: IntroParamsPriority"
  },
  "articles/samples/IntroParamsSource.html": {
    "href": "articles/samples/IntroParamsSource.html",
    "title": "Sample: IntroParamsSource | BenchmarkDotNet",
    "keywords": "Sample: IntroParamsSource In case you want to use a lot of values, you should use [ParamsSource] You can mark one or several fields or properties in your class by the [Params] attribute. In this attribute, you have to specify the name of public method/property which is going to provide the values (something that implements IEnumerable ). The source must be within benchmarked type! Source code using System.Collections.Generic; using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroParamsSource { // property with public setter [ParamsSource(nameof(ValuesForA))] public int A { get; set; } // public field [ParamsSource(nameof(ValuesForB))] public int B; // public property public IEnumerable<int> ValuesForA => new[] { 100, 200 }; // public static method public static IEnumerable<int> ValuesForB() => new[] { 10, 20 }; [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } } Output | Method | B | A | Mean | Error | StdDev | |---------- |--- |---- |---------:|--------:|--------:| | Benchmark | 10 | 100 | 115.5 ms | 0.17 ms | 0.16 ms | | Benchmark | 10 | 200 | 215.6 ms | 0.15 ms | 0.14 ms | | Benchmark | 20 | 100 | 125.5 ms | 0.19 ms | 0.18 ms | | Benchmark | 20 | 200 | 225.5 ms | 0.23 ms | 0.22 ms | Remarks A remark about IParam. You don't need to use IParam anymore since 0.11.0 . Just use complex types as you wish and override ToString method to change the display names used in the results. Links Parameterization The permanent link to this sample: Sample: IntroParamsSource"
  },
  "articles/samples/IntroPercentiles.html": {
    "href": "articles/samples/IntroPercentiles.html",
    "title": "Sample: IntroPercentiles | BenchmarkDotNet",
    "keywords": "Sample: IntroPercentiles The percentile represents a higher boundary for specified percentage of the measurements. For example, 95th percentile = 500ms means that 95% of all samples are not slower than 500ms. This metric is not very useful in microbenchmarks, as the values from consequent runs have a very narrow distribution. However, real-world scenarios often have so-called long tail distribution (due to IO delays, locks, memory access latency and so on), so the average execution time cannot be trusted. The percentiles allow to include the tail of distribution into the comparison. However, it requires some preparations steps. At first, you should have enough runs to count percentiles from. The TargetCount in the config should be set to 10-20 runs at least. Second, the count of iterations for each run should not be very high, or the peak timings will be averaged. The IterationTime = 25 works fine for most cases; for long-running benchmarks the Mode = Mode.SingleRun will be the best choice. However, feel free to experiment with the config values. Third, if you want to be sure that measurements are repeatable, set the LaunchCount to 3 or higher. And last, don't forget to include the columns into the config. They are not included by default (as said above, these are not too useful for most of the benchmarks). There're predefined StatisticColumn.P0 .. StatisticColumn.P100 for absolute timing percentiles. Example Run the IntroPercentiles sample. It contains three benchmark methods. First delays for 20 ms constantly. The second has random delays for 10..30 ms. And the third delays for 10ms 85 times of 100 and delays for 40ms 15 times of 100. Here's the output from the benchmark (some columns removed for brevity): Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.3813 ms 0.2051 ms 1.00 20.0272 ms 20.3813 ms 20.4895 ms 20.4954 ms 20.5869 ms 21.1471 ms RandomDelays 19.8055 ms 5.7556 ms 0.97 10.0793 ms 19.8055 ms 25.4173 ms 26.5187 ms 29.0313 ms 29.4550 ms RareDelays 10.3385 ms 11.4828 ms 0.51 10.0157 ms 10.3385 ms 10.5211 ms 40.0560 ms 40.3992 ms 40.4674 ms Also, it's very easy to screw the results with incorrect setup. For example, the same code being run with new Job { TargetCount = 5, IterationTime = 500 } completely hides the peak values: Method Median StdDev Ratio P0 P50 P80 P85 P95 P100 ConstantDelays 20.2692 ms 0.0308 ms 1.00 20.1986 ms 20.2692 ms 20.2843 ms 20.2968 ms 20.3097 ms 20.3122 ms RandomDelays 18.9965 ms 0.8601 ms 0.94 18.1339 ms 18.9965 ms 19.8126 ms 19.8278 ms 20.4485 ms 20.9466 ms RareDelays 14.0912 ms 2.8619 ms 0.70 10.2606 ms 14.0912 ms 15.7653 ms 17.3862 ms 18.6728 ms 18.6940 ms Source code using System; using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { // Using percentiles for adequate timings representation [Config(typeof(Config))] [SimpleJob(RunStrategy.ColdStart, launchCount: 4, warmupCount: 3, targetCount: 20, id: \"MyJob\")] public class IntroPercentiles { // To share between runs. // DO NOT do this in production code. The System.Random IS NOT thread safe. private static readonly Random Rnd = new Random(); private class Config : ManualConfig { public Config() { AddColumn( StatisticColumn.P0, StatisticColumn.P25, StatisticColumn.P50, StatisticColumn.P67, StatisticColumn.P80, StatisticColumn.P85, StatisticColumn.P90, StatisticColumn.P95, StatisticColumn.P100); } } [Benchmark(Baseline = true)] public void ConstantDelays() => Thread.Sleep(20); [Benchmark] public void RandomDelays() => Thread.Sleep(10 + (int) (20 * Rnd.NextDouble())); [Benchmark] public void RareDelays() { int rndTime = 10; // Bigger delays for 15% of the runs if (Rnd.NextDouble() > 0.85) { rndTime += 30; } Thread.Sleep(rndTime); } } } Links Statistics The permanent link to this sample: Sample: IntroPercentiles"
  },
  "articles/samples/IntroPowerPlan.html": {
    "href": "articles/samples/IntroPowerPlan.html",
    "title": "Sample: IntroPowerPlan | BenchmarkDotNet",
    "keywords": "Sample: IntroPowerPlan This sample shows how we can manipulate with power plans. In BenchmarkDotNet we could change power plan in two ways. The first one is to set one from the list: PowerSaver, guid: a1841308-3541-4fab-bc81-f71556f20b4a Balanced, guid: 381b4222-f694-41f0-9685-ff5bb260df2e High-Performance, guid: 8c5e7fda-e8bf-4a96-9a85-a6e23a8c635c (the default one) Ultimate Performance, guid: e9a42b02-d5df-448d-aa00-03f14749eb61 UserPowerPlan (a current power plan set in computer) The second one rely on guid string. We could easily found currently set guids with cmd command powercfg /list If we set power plans in two ways at the same time, the second one will be used. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using System; namespace BenchmarkDotNet.Samples { [Config(typeof(Config))] public class IntroPowerPlan { private class Config : ManualConfig { public Config() { AddJob(Job.MediumRun.WithPowerPlan(new Guid(\"e9a42b02-d5df-448d-aa00-03f14749eb61\"))); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.UltimatePerformance)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.Balanced)); AddJob(Job.MediumRun.WithPowerPlan(PowerPlan.PowerSaver)); } } [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) { j = i; } return j; } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } } Links Power Plans The permanent link to this sample: Sample: IntroPowerPlan"
  },
  "articles/samples/IntroRankColumn.html": {
    "href": "articles/samples/IntroRankColumn.html",
    "title": "Sample: IntroRankColumn | BenchmarkDotNet",
    "keywords": "Sample: IntroRankColumn Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Mathematics; using BenchmarkDotNet.Order; namespace BenchmarkDotNet.Samples { [ShortRunJob] [Orderer(SummaryOrderPolicy.FastestToSlowest)] [RankColumn(NumeralSystem.Arabic)] [RankColumn(NumeralSystem.Roman)] [RankColumn(NumeralSystem.Stars)] public class IntroRankColumn { [Params(1, 2)] public int Factor; [Benchmark] public void Foo() => Thread.Sleep(Factor * 100); [Benchmark] public void Bar() => Thread.Sleep(Factor * 200); } } Output Method | Factor | Mean | Error | StdDev | Rank | Rank | Rank | ------- |------- |---------:|---------:|----------:|-----:|-----:|-----:| Foo | 1 | 100.8 ms | 2.250 ms | 0.1272 ms | 1 | I | * | Foo | 2 | 200.8 ms | 4.674 ms | 0.2641 ms | 2 | II | ** | Bar | 1 | 200.9 ms | 2.012 ms | 0.1137 ms | 2 | II | ** | Bar | 2 | 400.7 ms | 4.509 ms | 0.2548 ms | 3 | III | *** | Links Statistics The permanent link to this sample: Sample: IntroRankColumn"
  },
  "articles/samples/IntroRatioSD.html": {
    "href": "articles/samples/IntroRatioSD.html",
    "title": "Sample: IntroRatioSD | BenchmarkDotNet",
    "keywords": "Sample: IntroRatioSD The ratio of two benchmarks is not a single number, it's a distribution. In most simple cases, the range of the ratio distribution is narrow, and BenchmarkDotNet displays a single column Ratio with the mean value. However, it also adds the RatioSD column (the standard deviation of the ratio distribution) in complex situations. In the below example, the baseline benchmark is spoiled by a single outlier Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; using Perfolizer.Mathematics.OutlierDetection; namespace BenchmarkDotNet.Samples { // Don't remove outliers [Outliers(OutlierMode.DontRemove)] // Skip jitting, pilot, warmup; measure 10 iterations [SimpleJob(RunStrategy.Monitoring, targetCount: 10, invocationCount: 1)] public class IntroRatioSD { private int counter; [GlobalSetup] public void Setup() => counter = 0; [Benchmark(Baseline = true)] public void Base() { Thread.Sleep(100); if (++counter % 7 == 0) Thread.Sleep(5000); // Emulate outlier } [Benchmark] public void Slow() => Thread.Sleep(200); [Benchmark] public void Fast() => Thread.Sleep(50); } } Output Here are statistics details for the baseline benchmark: Mean = 600.6054 ms, StdErr = 500.0012 ms (83.25%); N = 10, StdDev = 1,581.1428 ms Min = 100.2728 ms, Q1 = 100.3127 ms, Median = 100.4478 ms, Q3 = 100.5011 ms, Max = 5,100.6163 ms IQR = 0.1884 ms, LowerFence = 100.0301 ms, UpperFence = 100.7837 ms ConfidenceInterval = [-1,789.8568 ms; 2,991.0677 ms] (CI 99.9%), Margin = 2,390.4622 ms (398.01% of Mean) Skewness = 2.28, Kurtosis = 6.57, MValue = 2 -------------------- Histogram -------------------- [-541.891 ms ; 743.427 ms) | @@@@@@@@@ [ 743.427 ms ; 2027.754 ms) | [2027.754 ms ; 3312.082 ms) | [3312.082 ms ; 4458.453 ms) | [4458.453 ms ; 5742.780 ms) | @ --------------------------------------------------- As you can see, a single outlier significantly affected the metrics. Because of this, BenchmarkDotNet adds the Median and the RatioSD columns in the summary table: Method | Mean | Error | StdDev | Median | Ratio | RatioSD | ------- |----------:|--------------:|--------------:|----------:|------:|--------:| Base | 600.61 ms | 2,390.4622 ms | 1,581.1428 ms | 100.45 ms | 1.00 | 0.00 | Slow | 200.50 ms | 0.4473 ms | 0.2959 ms | 200.42 ms | 1.80 | 0.62 | Fast | 50.54 ms | 0.3435 ms | 0.2272 ms | 50.48 ms | 0.45 | 0.16 | Let's look at the Base and Slow benchmarks. The Mean values are 600 and 200 milliseconds; the \"Scaled Mean\" value is 0.3. The Median values are 100 and 200 milliseconds; the \"Scaled Median\" value is 2. Both values are misleading. BenchmarkDotNet evaluates the ratio distribution and displays the mean (1.80) and the standard deviation (0.62). Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroRatioSD"
  },
  "articles/samples/IntroRatioStyle.html": {
    "href": "articles/samples/IntroRatioStyle.html",
    "title": "Sample: IntroRatioStyle | BenchmarkDotNet",
    "keywords": "Sample: IntroRatioStyle Using RatioStyle , we can override the style of the \"Ratio\" column in SummaryStyle . Here are the possible values: Value : default value that shows the ration value between the current benchmark and the baseline benchmark (e.g., 0.15 or 1.15 ) Percentage : express the ration in percentage (e.g., -85% or +15% ) Trend : shows how much the current benchmark is faster or slower than the base benchmark (e.g., 6.63x faster or 1.15x slower ) Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Reports; namespace BenchmarkDotNet.Samples { [ShortRunJob, Config(typeof(Config))] public class IntroRatioStyle { [Benchmark(Baseline = true)] public void Baseline() => Thread.Sleep(1000); [Benchmark] public void Bar() => Thread.Sleep(150); [Benchmark] public void Foo() => Thread.Sleep(1150); private class Config : ManualConfig { public Config() { SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend); } } } } Output With the given RatioStyle.Trend , we have the following table: | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|-------------:|--------:| | Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms | baseline | | | Bar | 150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster | 0.00x | | Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower | 0.00x | With the default RatioStyle.Value , we get the following table: | Method | Mean | Error | StdDev | Ratio | |--------- |-----------:|--------:|--------:|------:| | Baseline | 1,000.3 ms | 2.71 ms | 0.15 ms | 1.00 | | Bar | 150.6 ms | 1.67 ms | 0.09 ms | 0.15 | | Foo | 1,150.6 ms | 7.41 ms | 0.41 ms | 1.15 | If we use RatioStyle.Percentage , we get the following table: | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|---------:|--------:| | Baseline | 1,000.3 ms | 4.69 ms | 0.26 ms | baseline | | | Bar | 150.7 ms | 1.42 ms | 0.08 ms | -85% | 0.1% | | Foo | 1,150.3 ms | 6.13 ms | 0.34 ms | +15% | 0.0% | Links Benchmark and Job Baselines The permanent link to this sample: Sample: IntroRatioStyle"
  },
  "articles/samples/IntroSetupCleanupGlobal.html": {
    "href": "articles/samples/IntroSetupCleanupGlobal.html",
    "title": "Sample: IntroSetupCleanupGlobal | BenchmarkDotNet",
    "keywords": "Sample: IntroSetupCleanupGlobal A method which is marked by the [GlobalSetup] attribute will be executed only once per a benchmarked method after initialization of benchmark parameters and before all the benchmark method invocations. A method which is marked by the [GlobalCleanup] attribute will be executed only once per a benchmarked method after all the benchmark method invocations. If you are using some unmanaged resources (e.g., which were created in the GlobalSetup method), they can be disposed in the GlobalCleanup method. Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroSetupCleanupGlobal { [Params(10, 100, 1000)] public int N; private int[] data; [GlobalSetup] public void GlobalSetup() { data = new int[N]; // executed once per each N value } [Benchmark] public int Logic() { int res = 0; for (int i = 0; i < N; i++) res += data[i]; return res; } [GlobalCleanup] public void GlobalCleanup() { // Disposing logic } } } Links Setup And Cleanup The permanent link to this sample: Sample: IntroSetupCleanupGlobal"
  },
  "articles/samples/IntroSetupCleanupIteration.html": {
    "href": "articles/samples/IntroSetupCleanupIteration.html",
    "title": "Sample: IntroSetupCleanupIteration | BenchmarkDotNet",
    "keywords": "Sample: IntroSetupCleanupIteration A method which is marked by the [IterationSetup] attribute will be executed exactly once before each benchmark invocation (we have changed that in 0.11.0). It's not recommended to use this attribute in microbenchmarks because it can spoil the results. However, if you are writing a macrobenchmark (e.g. a benchmark which takes at least 100ms) and you want to prepare some data before each invocation, [IterationSetup] can be useful. A method which is marked by the [IterationCleanup] attribute will be executed exactly once after each invocation . This attribute has the same set of constraint with [IterationSetup] : it's not recommended to use [IterationCleanup] in microbenchmarks. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 1, warmupCount: 2, targetCount: 3)] public class IntroSetupCleanupIteration { private int setupCounter; private int cleanupCounter; [IterationSetup] public void IterationSetup() => Console.WriteLine($\"// IterationSetup ({++setupCounter})\"); [IterationCleanup] public void IterationCleanup() => Console.WriteLine($\"// IterationCleanup ({++cleanupCounter})\"); [GlobalSetup] public void GlobalSetup() => Console.WriteLine(\"// \" + \"GlobalSetup\"); [GlobalCleanup] public void GlobalCleanup() => Console.WriteLine(\"// \" + \"GlobalCleanup\"); [Benchmark] public void Benchmark() => Console.WriteLine(\"// \" + \"Benchmark\"); } } The order of method calls // GlobalSetup // IterationSetup (1) // IterationSetup Jitting // IterationCleanup (1) // IterationCleanup Jitting // IterationSetup (2) // MainWarmup1 // Benchmark // MainWarmup1 // IterationCleanup (2) // MainWarmup1 // IterationSetup (3) // MainWarmup2 // Benchmark // MainWarmup2 // IterationCleanup (3) // MainWarmup2 // IterationSetup (4) // MainTarget1 // Benchmark // MainTarget1 // IterationCleanup (4) // MainTarget1 // IterationSetup (5) // MainTarget2 // Benchmark // MainTarget2 // IterationCleanup (5) // MainTarget2 // IterationSetup (6) // MainTarget3 // Benchmark // MainTarget3 // IterationCleanup (6) // MainTarget3 // GlobalCleanup Links Setup And Cleanup The permanent link to this sample: Sample: IntroSetupCleanupIteration"
  },
  "articles/samples/IntroSetupCleanupTarget.html": {
    "href": "articles/samples/IntroSetupCleanupTarget.html",
    "title": "Sample: IntroSetupCleanupTarget | BenchmarkDotNet",
    "keywords": "Sample: IntroSetupCleanupTarget Sometimes it's useful to run setup or cleanups for specific benchmarks. All four setup and cleanup attributes have a Target property that allow the setup/cleanup method to be run for one or more specific benchmark methods. Source code using System; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Engines; namespace BenchmarkDotNet.Samples { [SimpleJob(RunStrategy.Monitoring, launchCount: 0, warmupCount: 0, targetCount: 1)] public class IntroSetupCleanupTarget { [GlobalSetup(Target = nameof(BenchmarkA))] public void GlobalSetupA() => Console.WriteLine(\"// \" + \"GlobalSetup A\"); [Benchmark] public void BenchmarkA() => Console.WriteLine(\"// \" + \"Benchmark A\"); [GlobalSetup(Targets = new[] { nameof(BenchmarkB), nameof(BenchmarkC) })] public void GlobalSetupB() => Console.WriteLine(\"// \" + \"GlobalSetup B\"); [Benchmark] public void BenchmarkB() => Console.WriteLine(\"// \" + \"Benchmark B\"); [Benchmark] public void BenchmarkC() => Console.WriteLine(\"// \" + \"Benchmark C\"); [Benchmark] public void BenchmarkD() => Console.WriteLine(\"// \" + \"Benchmark D\"); } } The order of method calls // GlobalSetup A // Benchmark A // GlobalSetup B // Benchmark B // GlobalSetup B // Benchmark C // Benchmark D Links Setup And Cleanup The permanent link to this sample: Sample: IntroSetupCleanupTarget"
  },
  "articles/samples/IntroStaThread.html": {
    "href": "articles/samples/IntroStaThread.html",
    "title": "Sample: IntroStaThread | BenchmarkDotNet",
    "keywords": "Sample: IntroStaThread If the code you want to benchmark requires [System.STAThread] then you need to apply this attribute to the benchmarked method. BenchmarkDotNet will generate executable with [STAThread] applied to it's Main method. Currently it does not work for .NET Core 2.0 due to this bug. Source code using System.Threading; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { public class IntroStaThread { [Benchmark, System.STAThread] public void CheckForSTA() { if (Thread.CurrentThread.GetApartmentState() != ApartmentState.STA) { throw new ThreadStateException( \"The current threads apartment state is not STA\"); } } } } Links Customizing Runtime The permanent link to this sample: Sample: IntroStaThread"
  },
  "articles/samples/IntroStatisticalTesting.html": {
    "href": "articles/samples/IntroStatisticalTesting.html",
    "title": "Sample: IntroStatisticalTesting | BenchmarkDotNet",
    "keywords": "Sample: IntroStatisticalTesting Source code using System.Threading; using BenchmarkDotNet.Attributes; using Perfolizer.Mathematics.SignificanceTesting; using Perfolizer.Mathematics.Thresholds; namespace BenchmarkDotNet.Samples { [StatisticalTestColumn(StatisticalTestKind.Welch, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn(StatisticalTestKind.MannWhitney, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn(StatisticalTestKind.Welch, ThresholdUnit.Ratio, 0.03, true)] [StatisticalTestColumn(StatisticalTestKind.MannWhitney, ThresholdUnit.Ratio, 0.03, true)] [SimpleJob(warmupCount: 0, targetCount: 5)] public class IntroStatisticalTesting { [Benchmark] public void Sleep50() => Thread.Sleep(50); [Benchmark] public void Sleep97() => Thread.Sleep(97); [Benchmark] public void Sleep99() => Thread.Sleep(99); [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100); [Benchmark] public void Sleep101() => Thread.Sleep(101); [Benchmark] public void Sleep103() => Thread.Sleep(103); [Benchmark] public void Sleep150() => Thread.Sleep(150); } } Output Method Mean Error StdDev Ratio Welch(1us)/p-values Welch(3%)/p-values MannWhitney(1us)/p-values MannWhitney(3%)/p-values Sleep50 53.13 ms 0.5901 ms 0.1532 ms 0.51 Faster: 1.0000/0.0000 Faster: 1.0000/0.0000 Faster: 1.0000/0.0040 Faster: 1.0000/0.0040 Sleep97 100.07 ms 0.9093 ms 0.2361 ms 0.97 Faster: 1.0000/0.0000 Same: 1.0000/0.1290 Faster: 1.0000/0.0040 Same: 1.0000/0.1111 Sleep99 102.23 ms 2.4462 ms 0.6353 ms 0.99 Faster: 0.9928/0.0072 Same: 1.0000/0.9994 Faster: 0.9960/0.0079 Same: 1.0000/1.0000 Sleep100 103.34 ms 0.8180 ms 0.2124 ms 1.00 Base: 0.5029/0.5029 Base: 1.0000/1.0000 Base: 0.7262/0.7262 Base: 1.0000/1.0000 Sleep101 103.73 ms 2.1591 ms 0.5607 ms 1.00 Same: 0.1041/0.8969 Same: 0.9999/1.0000 Same: 0.1111/0.9246 Same: 1.0000/1.0000 Sleep103 106.21 ms 1.2511 ms 0.3249 ms 1.03 Slower: 0.0000/1.0000 Same: 0.9447/1.0000 Slower: 0.0040/1.0000 Same: 0.9246/1.0000 Sleep150 153.16 ms 3.4929 ms 0.9071 ms 1.48 Slower: 0.0000/1.0000 Slower: 0.0000/1.0000 Slower: 0.0040/1.0000 Slower: 0.0040/1.0000 // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) Welch(1us)/p-values : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' Welch(3%)/p-values : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(3%)/p-values : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' 1 ms : 1 Millisecond (0.001 sec) ### Links * The permanent link to this sample: @BenchmarkDotNet.Samples.IntroStatisticalTesting ---"
  },
  "articles/samples/IntroStatisticsColumns.html": {
    "href": "articles/samples/IntroStatisticsColumns.html",
    "title": "Sample: IntroStatisticsColumns | BenchmarkDotNet",
    "keywords": "Sample: IntroStatisticsColumns Source code using System; using System.Security.Cryptography; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [MediumRunJob, SkewnessColumn, KurtosisColumn] public class IntroStatisticsColumns { private const int N = 10000; private readonly byte[] data; private readonly MD5 md5 = MD5.Create(); private readonly SHA256 sha256 = SHA256.Create(); public IntroStatisticsColumns() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark(Baseline = true)] public byte[] Md5A() => md5.ComputeHash(data); [Benchmark] public byte[] Md5B() => md5.ComputeHash(data); [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); } } Output Method Mean Error StdDev Skewness Kurtosis Ratio RatioSD Md5A 15.91 us 0.0807 us 0.1209 us 0.4067 1.646 1.00 0.00 Md5B 15.89 us 0.0709 us 0.1062 us 0.5893 2.141 1.00 0.01 Sha256 36.62 us 0.6390 us 0.9564 us 1.1363 4.014 2.30 0.06 Links Statistics The permanent link to this sample: Sample: IntroStatisticsColumns"
  },
  "articles/samples/IntroStopOnFirstError.html": {
    "href": "articles/samples/IntroStopOnFirstError.html",
    "title": "Sample: IntroStopOnFirstError | BenchmarkDotNet",
    "keywords": "Sample: IntroStopOnFirstError BenchmarkDotNet can be configured to stop on first error. You just have to add StopOnFirstError attribute to your class or use --stopOnFirstError command line argument. Source code using System; using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [StopOnFirstError] public class IntroStopOnFirstError { [Benchmark(Baseline = true)] public int FirstMethod() => throw new Exception(\"Example exception.\"); [Benchmark] public int SecondMethod() => 1; } } Links Configs How to use console arguments The permanent link to this sample: Sample: IntroStopOnFirstError"
  },
  "articles/samples/IntroTagColumn.html": {
    "href": "articles/samples/IntroTagColumn.html",
    "title": "Sample: IntroTagColumn | BenchmarkDotNet",
    "keywords": "Sample: IntroTagColumn In the following example, we introduce two new columns which contains a tag based on a benchmark method name. Source code using System.Threading; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Columns; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { // You can add custom tags per each method using Columns [Config(typeof(Config))] public class IntroTagColumn { private class Config : ManualConfig { public Config() { AddJob(Job.Dry); AddColumn(new TagColumn(\"Kind\", name => name.Substring(0, 3))); AddColumn(new TagColumn(\"Number\", name => name.Substring(3))); } } [Benchmark] public void Foo1() => Thread.Sleep(10); [Benchmark] public void Foo12() => Thread.Sleep(10); [Benchmark] public void Bar3() => Thread.Sleep(10); [Benchmark] public void Bar34() => Thread.Sleep(10); } } Output | Method | Mean | Kind | Number | | ------ | ---------- | ---- | ------ | | Bar34 | 10.3636 ms | Bar | 34 | | Bar3 | 10.4662 ms | Bar | 3 | | Foo12 | 10.1377 ms | Foo | 12 | | Foo1 | 10.2814 ms | Foo | 1 | Links Columns The permanent link to this sample: Sample: IntroTagColumn"
  },
  "articles/samples/IntroTailcall.html": {
    "href": "articles/samples/IntroTailcall.html",
    "title": "Sample: IntroTailcall | BenchmarkDotNet",
    "keywords": "Sample: IntroTailcall You need to use the TailcallDiagnoser attribute to configure it. The available options are: logFailuresOnly: Track only the methods that failed to get tail called. True by default. filterByNamespace : Track only the methods from declaring type's namespace. Set to false if you want to see all Jit tail events. True by default. Restrictions Windows only x64 Source code using BenchmarkDotNet.Attributes; namespace BenchmarkDotNet.Samples { [Diagnostics.Windows.Configs.TailCallDiagnoser] [LegacyJitX86Job, LegacyJitX64Job, RyuJitX64Job] public class IntroTailcall { [Benchmark] public long Calc() => FactorialWithoutTailing(7) - FactorialWithTailing(7); private static long FactorialWithoutTailing(int depth) => depth == 0 ? 1 : depth * FactorialWithoutTailing(depth - 1); private static long FactorialWithTailing(int pos, int depth) => pos == 0 ? depth : FactorialWithTailing(pos - 1, depth * pos); private static long FactorialWithTailing(int depth) => FactorialWithTailing(depth - 1, depth); } } Output // * Diagnostic Output - TailCallDiagnoser * -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX64(Jit=LegacyJit, Platform=X64, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: LegacyJitX86(Jit=LegacyJit, Platform=X86, Runtime=Clr) -------------------- -------------------- Jit_TailCalling.Calc: RyuJitX64(Jit=RyuJit, Platform=X64) -------------------- Caller: <null>.<null> - <null> Callee: BenchmarkDotNet.Samples.JIT.Jit_TailCalling.FactorialWithTailing - int64 (int32,int32) Tail prefix: False Tail call type: RecursiveLoop ------------------- Links Diagnosers The permanent link to this sample: Sample: IntroTailcall"
  },
  "articles/samples/IntroThreadingDiagnoser.html": {
    "href": "articles/samples/IntroThreadingDiagnoser.html",
    "title": "Sample: IntroThreadingDiagnoser | BenchmarkDotNet",
    "keywords": "Sample: IntroThreadingDiagnoser The ThreadingDiagnoser uses new APIs exposed in .NET Core 3.0 to report: Completed Work Items: The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions: The number of times there was contention upon trying to take a Monitor's lock (per single operation) Source code using BenchmarkDotNet.Attributes; using System.Threading; namespace BenchmarkDotNet.Samples { [ThreadingDiagnoser] // ENABLE the diagnoser public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } } Output Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - Links Diagnosers The permanent link to this sample: Sample: IntroThreadingDiagnoser"
  },
  "articles/samples/IntroUnicode.html": {
    "href": "articles/samples/IntroUnicode.html",
    "title": "Sample: IntroUnicode | BenchmarkDotNet",
    "keywords": "Sample: IntroUnicode Some of the BenchmarkDotNet exporters use Unicode symbols that are not ASCII-compatible (e.g., μ or ± ). Unfortunately, some terminals are not supported such symbols. That's why BenchmarkDotNet prints only ASCII characters by default ( μ will be replaced by u ). If you want to display Unicode symbols in your terminal, you should use [UnicodeConsoleLoggerAttribute] (see usage examples below). Warning This feature works only with terminal(s)|text editor(s) that support Unicode. On Windows, you may have some troubles with Unicode symbols if system default code page configured as non-English (in Control Panel + Regional and Language Options, Language for Non-Unicode Programs). Source code using System.Diagnostics; using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Loggers; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { // *** Attribute Style *** [UnicodeConsoleLogger] public class IntroUnicode { [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } // *** Object Style *** [Config(typeof(Config))] public class IntroUnicodeObjectStyle { private class Config : ManualConfig { public Config() => AddLogger(ConsoleLogger.Unicode); } [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } // *** Fluent Config *** public class IntroUnicodeFluentConfig { public static void Run() { BenchmarkRunner.Run<IntroUnicodeFluentConfig>( DefaultConfig.Instance .AddLogger(ConsoleLogger.Unicode)); } [Benchmark] public long Foo() { long waitUntil = Stopwatch.GetTimestamp() + 1000; while (Stopwatch.GetTimestamp() < waitUntil) { } return waitUntil; } } } Output Mean = 1.0265 μs, StdErr = 0.0005 μs (0.05%); N = 15, StdDev = 0.0018 μs Min = 1.0239 μs, Q1 = 1.0248 μs, Median = 1.0264 μs, Q3 = 1.0280 μs, Max = 1.0296 μs IQR = 0.0033 μs, LowerFence = 1.0199 μs, UpperFence = 1.0329 μs ConfidenceInterval = [1.0245 μs; 1.0285 μs] (CI 99.9%), Margin = 0.0020 μs (0.19% of Mean) Skewness = 0.12, Kurtosis = 1.56, MValue = 2 -------------------- Histogram -------------------- [1.023 μs ; 1.030 μs) | @@@@@@@@@@@@@@@ --------------------------------------------------- Method | Mean | Error | StdDev | ------- |---------:|----------:|----------:| Foo | 1.027 μs | 0.0020 μs | 0.0018 μs | Links @BenchmarkDotNet.Attributes.UnicodeConsoleLoggerAttribute The permanent link to this sample: Sample: IntroUnicode"
  },
  "articles/samples/IntroWasm.html": {
    "href": "articles/samples/IntroWasm.html",
    "title": "Sample: IntroWasm | BenchmarkDotNet",
    "keywords": "Sample: IntroWasm WasmToolchain uses a local Mono Runtime build to run the benchmarks compiled as WebAssembly using V8 JavaScript Engine. Source code using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; using System.IO; using BenchmarkDotNet.Toolchains; using BenchmarkDotNet.Toolchains.DotNetCli; using BenchmarkDotNet.Toolchains.MonoWasm; namespace BenchmarkDotNet.Samples { // *** Command Line Arguments *** public class IntroWasmCmdConfig { // the args must contain: // an information that we want to run benchmark as Wasm: // --runtimes Wasm // path to dotnet cli // --cli /home/adam/projects/runtime/dotnet.sh // path to main js: // --wasmMainJs /home/adam/projects/runtime/src/mono/wasm/runtime-test.js public static void Run(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(IntroWasmCmdConfig).Assembly).Run(args); [Benchmark] public void Foo() { // Benchmark body } } // *** Fluent Config *** public class IntroWasmFluentConfig { public static void Run() { // the Wasm Toolchain requires two mandatory arguments: const string mainJsPath = @\"/home/adam/projects/runtime/src/mono/wasm/runtime-test.js\"; const string cliPath = @\"/home/adam/projects/runtime/dotnet.sh\"; WasmRuntime runtime = new WasmRuntime(mainJs: new FileInfo(mainJsPath), msBuildMoniker: \"net5.0\"); NetCoreAppSettings netCoreAppSettings = new NetCoreAppSettings( targetFrameworkMoniker: \"net5.0\", runtimeFrameworkVersion: null, name: \"Wasm\", customDotNetCliPath: cliPath); IToolchain toolChain = WasmToolChain.From(netCoreAppSettings); BenchmarkRunner.Run<IntroCustomMonoFluentConfig>(DefaultConfig.Instance .AddJob(Job.ShortRun.WithRuntime(runtime).WithToolchain(toolChain))); } [Benchmark] public void Foo() { // Benchmark body } } } Links Toolchains The permanent link to this sample: Sample: IntroWasm"
  },
  "articles/samples/IntroXamarin.html": {
    "href": "articles/samples/IntroXamarin.html",
    "title": "Sample: IntroXamarin | BenchmarkDotNet",
    "keywords": "Sample: IntroXamarin To use BenchmarkDotNet with Xamarin, you will need to build a small UI for running Benchmarks and displaying the results so you can actually read them. Using Xamarin.Forms is a simple way to be able to run your benchmarks on iOS or Android. Other notes: Use Release builds when running actual benchmarks. Disable the linker via the Don't Link or None . Source code using BenchmarkDotNet.Analysers; using BenchmarkDotNet.Configs; using BenchmarkDotNet.Exporters; using BenchmarkDotNet.Loggers; using BenchmarkDotNet.Running; using System; using System.Linq; using System.Threading.Tasks; using Xamarin.Forms; namespace BenchmarkDotNet.Samples.Forms { public partial class MainPage : ContentPage { public MainPage() { InitializeComponent(); } async void Button_Clicked(object sender, EventArgs e) { SetIsRunning(true); try { var logger = new AccumulationLogger(); await Task.Run(() => { var config = default(IConfig); #if DEBUG config = new DebugInProcessConfig(); #endif var summary = BenchmarkRunner.Run<IntroBasic>(config); MarkdownExporter.Console.ExportToLog(summary, logger); ConclusionHelper.Print(logger, summary.BenchmarksCases .SelectMany(benchmark => benchmark.Config.GetCompositeAnalyser().Analyse(summary)) .Distinct() .ToList()); }); SetSummary(logger.GetLog()); } catch (Exception exc) { await DisplayAlert(\"Error\", exc.Message, \"Ok\"); } finally { SetIsRunning(false); } } void SetIsRunning(bool isRunning) { Indicator.IsRunning = isRunning; Run.IsVisible = Summary.IsVisible = !isRunning; } void SetSummary(string text) { Summary.Text = text; var size = Summary.Measure(double.MaxValue, double.MaxValue).Request; Summary.WidthRequest = size.Width; Summary.HeightRequest = size.Height; } } } Output Links Xamarin.Android linker settings Xamarin.iOS linker settings The permanent link to this sample: Sample: IntroXamarin"
  },
  "articles/team.html": {
    "href": "articles/team.html",
    "title": "Team | BenchmarkDotNet",
    "keywords": "Team This project is supported by the .NET Foundation . Maintainers: Andrey Akinshin (Project Lead), Adam Sitnik . Contributors: @mattwarren (Matt Warren) @alinasmirnova (Alina Smirnova) @ig-sinicyn @Ky7m (Igor Fesenko) @epeshk (Evgeny Peshkov) @redknightlois (Federico Andres Lois) @Teknikaali (Anssi Kettunen) @morgan-kn (Irina Ananyeva) @gigi81 (Luigi Grilli) @lukasz-pyrzyk (Łukasz Pyrzyk) @Rizzen (Mark) @FransBouma (Frans Bouma) @AmadeusW (Amadeusz Wieczorek) @lahma (Marko Lahma) @ppanyukov (Philip Panyukov) @roji (Shay Rojansky) @mtschneiders (Mateus Artur Schneiders) @mfilippov (Mikhail Filippov) @svick (Petr Onderka) @alexandrnikitin (Alexandr Nikitin) @Chrisgozd (Christopher Gozdziewski) @dmitry-ra (Dmitry Razumikhin) @ENikS (Eugene Sadovoi) @GeorgePlotnikov (George Plotnikov) @ltrzesniewski (Lucas Trzesniewski) @cdmihai (Mihai Codoban) @shoelzer (Steve Hoelzer) @krk (Kerem) @ipjohnson (Ian Johnson) @stevedesmond-ca (Steve Desmond) @aarondandy (Aaron Dandy) @AlekseiKudelia @aidmsu (Andrey Dorokhov) @arthrp (Arthur) @benjamin-hodgson (Benjamin Hodgson) @jawn (Bernard Vander Beken) @dfederm (David Federman) @davkean (David Kean) @DenisIstomin (Denis Istomin) @mijay (Dmitry Kononchuk) @eerhardt (Eric Erhardt) @onionhammer (Erik O'Leary) @ForNeVeR (Friedrich von Never) @IanKemp (Ian Kemp) @cloudRoutine (Jared Hester) @cincuranet (Jiri Cincura ↹) @JohanLarsson (Johan Larsson) @Matthew-Bonner (Matthew Bonner) @mmayr-at (Michael Mayr) @MishaHusiuk (MishaHusiuk) @NN--- (NN) @paulness (Paul Ness) @pentp (Pent Ploompuu) @RichLinnell (Rich Linnell) @rolshevsky (Rostislav Olshevsky) @russcam (Russ Cam) @goldshtn (Sasha Goldshtein) @ScottHutchinson (Scott Hutchinson) @smitpatel (Smit Patel) @afmorris (Tony Morris) @Tornhoof @vkkoshelev @factormystic @nietras All contributors on GitHub"
  },
  "changelog/full.html": {
    "href": "changelog/full.html",
    "title": "Full ChangeLog | BenchmarkDotNet",
    "keywords": "Full ChangeLog BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.1 is a service update with various bug fixes and improvements. Highlights S390x architecture support ( #1712 ) Various WASM toolchain improvements ( #1719 , #1722 , #1729 , #1742 , #1743 , #1744 , #1746 , #1757 , #1763 ) Support of CoreRT on 5.0.3XX SDK ( #1725 ) Using Utf8 for reading from standard input (fixes a nasty encoding-related bug) ( #1735 ) Adjusting WaitForExit timeouts ( #1745 ) Support for returning unmanaged types from benchmarks with InProcessToolchain ( #1750 ) Disabled Tiered JIT ( #1751 ) A MemoryDiagnoser bug fix ( #1762 ) Allow users to hide Gen X columns ( #1764 ) Copy GC settings from host process to the benchmark process ( #1765 ) Do not split surrogates in shortified parameter values ( #1705 ) Milestone details In the v0.13.1 scope, 3 issues were resolved and 22 pull requests were merged. This release includes 36 commits by 10 contributors. Resolved issues (3) #1703 Unable to run benchmark when ParamsSource refers to string with surrogate pairs #1713 System.NotSupportedException: Unknown Acknowledgment: ﻿Acknowledgment when running in a github action (assignee: @adamsitnik ) #1714 AwaitingTasksShouldNotInterfereAllocationResults is flaky (assignee: @adamsitnik ) Merged pull requests (22) #1705 do not split surrogates in ParameterInstance.ToDisplayText() (by @novak-as ) #1710 Fix typo (by @martincostello ) #1712 add S390x architecture support (by @adamsitnik ) #1719 Added UsingBrowserRuntimeWorkload (by @naricc ) #1722 Add AOT options to wasm runtime (by @naricc ) #1725 Add ValidateExecutableReferencesMatchSelfContained (by @kant2002 ) #1729 Naricc/validate executable references match self contained (by @naricc ) #1735 Use Utf8 not just for writing to standard output, but also for reading from standard input (by @adamsitnik ) #1742 Fix WasmAssembliesToBundle item is empty error (by @radekdoulik ) #1743 Add linker description for wasm AOT (by @radekdoulik ) #1744 Make mono/wasm run on Windows (by @radekdoulik ) #1745 Fix #1731. (by @cgranade ) #1746 Make PrepareForWasmBuild work with wasm workload (by @radekdoulik ) #1748 Fix typo in docs (by @Jlobblet ) #1750 Fix pointer-returning benchmarks support for InProcessToolchain (by @adamsitnik ) #1751 disable TieredJit so it's background allocations don't show up in allocated memory reported by MemoryDiagnoser tests (by @adamsitnik ) #1757 [wasm] Add WasmMainJSPath in interpreter projects (by @radekdoulik ) #1762 MemoryDiagnoser fix (by @adamsitnik ) #1763 Pr wasm set runtimesrcdir for interpreter (by @naricc ) #1764 Allow users to hide Gen X columns (by @adamsitnik ) #1765 Copy GC settings from host process (by @adamsitnik ) #1768 Fix typo in README (by @eugene-g ) Commits (36) fe1124 Postrelease update of v0.13.0 changelog (by @AndreyAkinshin ) 0388db Update build-and-pack.cmd (by @AndreyAkinshin ) 5c8469 Set release date for v0.13.0 (by @AndreyAkinshin ) 601a1a Fix typo (#1710) (by @martincostello ) 5bc925 do not split surrogates in ParameterInstance.ToDisplayText() (#1705) (by @novak-as ) 891e57 Add unicode testcases in ParameterInstanceTests.MaxParameterColumnWidthCanBeC... (by @AndreyAkinshin ) 5d2160 Update changelog files (by @AndreyAkinshin ) bbc4b4 add S390x architecture support (#1712) (by @adamsitnik ) bf54f0 Fix flakiness in ThreadingDiagnoserTests (by @AndreyAkinshin ) 6ffdb2 [WASM] Added UsingBrowserRuntimeWorkload (#1719) (by @naricc ) 5196e6 Add AOT options to wasm runtime (#1722) (by @naricc ) d97285 Add ValidateExecutableReferencesMatchSelfContained (#1725) (by @kant2002 ) cb23e1 Delete .BenchmarkDotNet.Samples.csproj.swp (#1726) (by @naricc ) 75f632 Set ValidateExecutableReferencesMatchSelfContained for Wasm (#1729) (by @naricc ) 9e7e50 Added false to Wasm cs proj. (#1734) (by @naricc ) e7ff4c Use Utf8 not just for witing to standard output, but also for reading from st... (by @adamsitnik ) 081563 Added UsingBrowserRuntimeWorkload false. (#1741) (by @naricc ) 2fefdb Fix WasmAssembliesToBundle item is empty error (#1742) (by @radekdoulik ) 6b475f Add linker description for wasm AOT (#1743) (by @radekdoulik ) acb6f2 Make mono/wasm run on Windows (#1744) (by @radekdoulik ) 4b3d19 Make PrepareForWasmBuild work with wasm workload (#1746) (by @radekdoulik ) 141ef7 handle processes that don't exit on time more gracefully, fixes #1731. (#1745) (by @cgranade ) c3fb7b Add support for returning unmanaged types from benchmarks (#1739) (by @kant2002 ) 6f453b [wasm] Allow unsafe code (#1752) (by @radekdoulik ) c2cee2 Fix the CI (by @radekdoulik ) 19cbef Fix typo in docs (#1748) (by @Jlobblet ) 1a94d4 [wasm] Add WasmMainJSPath in interpreter projects (#1757) (by @radekdoulik ) 37ec19 Get rid of warning (#1760) (by @radekdoulik ) 4bd433 use benchmark process runtime, not host process runtime when deciding whether... (by @adamsitnik ) 8cb701 Update OsBrandStringHelper (by @AndreyAkinshin ) 8f81b5 Copy GC settings from host process (#1765) (by @adamsitnik ) f37266 Allow users to hide Gen X columns (#1764) (by @adamsitnik ) f9a4c1 [WASM] set runtimesrcdir for interpreter (#1763) (by @naricc ) 9e674d Fix typo in README (by @eugene-g ) 708be4 Prepare v0.13.1 changelog (by @AndreyAkinshin ) a93681 Set library version: 0.13.1 (by @AndreyAkinshin ) Contributors (10) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Andrii Kurdiumov ( @kant2002 ) Chris Granade ( @cgranade ) Evgeny Grebenyuk ( @eugene-g ) John Blundell ( @Jlobblet ) Martin Costello ( @martincostello ) Nathan Ricci ( @naricc ) Oleksandr Novak ( @novak-as ) Radek Doulik ( @radekdoulik ) Thank you very much! Additional details Date: August 11, 2021 Milestone: v0.13.1 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.1 BenchmarkDotNet v0.13.0 It's been a year since our last release. BenchmarkDotNet has been downloaded more than seven million times from nuget.org . It's more than we could have ever possibly imagined! Some could say, that it's also more than we can handle ;) That is why we wanted to once again thank all the contributors who helped us with 0.13.0 release! Highlights In BenchmarkDotNet v0.13.0, we have supported various technologies: .NET 5 and .NET 6 target framework monikers .NET SDK installed via snap SingleFile deployment Xamarin applications WASM applications Mono AOT We have also introduced new features and improvements including: Memory randomization Method-specific job attributes Sortable parameter columns Customizable ratio column Improved CoreRun and CoreRT support Improved Hardware Counters support Of course, this release includes dozens of other improvements and bug fixes! Supported technologies .NET 5, .NET 6, SingleFile and snap At some point in time, netcoreapp5.0 moniker was changed to net5.0 , which required a fix on our side ( #1479 , btw we love this kind of changes). Moreover, .NET 5 introduced platform-specific TMFs (example: net5.0-windows10.0.19041.0 ) which also required some extra work: #1560 , #1691 . In #1523 support for .NET 6 was added. <TargetFrameworks>net5.0;net5.0-windows10.0.19041.0;net6.0<TargetFrameworks> In #1686 @am11 has implemented support for single file deployment (supported in .NET 5 onwards). Last, but not least in #1652 snap support has been implemented. adam@adsitnik-ubuntu:~/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples$ dotnet50 run -c Release -f net5.0 --filter BenchmarkDotNet.Samples.IntroColdStart.Foo // Validating benchmarks: // ***** BenchmarkRunner: Start ***** // ***** Found 1 benchmark(s) in total ***** // ***** Building 1 exe(s) in Parallel: Start ***** // start /snap/dotnet-sdk/112/dotnet restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 1.49s and exited with 0 // start /snap/dotnet-sdk/112/dotnet build -c Release --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 2.78s and exited with 0 // ***** Done, took 00:00:04 (4.37 sec) ***** // Found 1 benchmarks: // IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // ************************** // Benchmark: IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // *** Execute *** // Launch: 1 / 1 // Execute: /snap/dotnet-sdk/112/dotnet \"9a018ee4-0f33-46dd-9093-01d3bf31233b.dll\" --benchmarkName \"BenchmarkDotNet.Samples.IntroColdStart.Foo\" --job \"IterationCount=5, RunStrategy=ColdStart\" --benchmarkId 0 in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b/bin/Release/net5.0 Xamarin support Thanks to the contributions of the amazing @jonathanpeppers BenchmarkDotNet supports Xamarin! The examples can be found in our repo: iOS , Android . #1360 , #1429 , #1434 , #1509 WASM support Thanks to the work of @naricc you can now benchmark WASM using Mono Runtime! For more details, please refer to our docs . #1483 , #1498 , #1500 , #1501 , #1507 , #1592 , #1689 . Mono AOT support In another awesome contribution ( #1662 ) @naricc has implemented Mono AOT support. The new toolchain supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses LLVM on the back end). For more details, please go to our docs . New features and improvements Memory randomization In #1587 @adamsitnik has introduced a new, experimental feature called \"Memory Randomization\". This feature allows you to ask BenchmarkDotNet to randomize the memory alignment by allocating random-sized byte arrays between iterations and call [GlobalSetup] before every benchmark iteration and [GlobalCleanup] after every benchmark iteration. Sample benchmark: public class IntroMemoryRandomization { [Params(512 * 4)] public int Size; private int[] _array; private int[] _destination; [GlobalSetup] public void Setup() { _array = new int[Size]; _destination = new int[Size]; } [Benchmark] public void Array() => System.Array.Copy(_array, _destination, Size); } Without asking for the randomization, the objects are allocated in [GlobalSetup] and their unmodified addresses (and alignment) are used for all iterations (as long as they are not promoted to an older generation by the GC). This is typically the desired behavior, as it gives you very nice and flat distributions: dotnet run -c Release --filter IntroMemoryRandomization -------------------- Histogram -------------------- [502.859 ns ; 508.045 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- But if for some reason you are interested in getting a distribution that is better reflecting the \"real-life\" performance you can enable the randomization: dotnet run -c Release --filter IntroMemoryRandomization --memoryRandomization true -------------------- Histogram -------------------- [108.803 ns ; 213.537 ns) | @@@@@@@@@@@@@@@ [213.537 ns ; 315.458 ns) | [315.458 ns ; 446.853 ns) | @@@@@@@@@@@@@@@@@@@@ [446.853 ns ; 559.259 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- Method-specific job attributes From now, all attributes that derive from JobMutatorConfigBaseAttribute ( full list ) can be applied to methods. You no longer have to move a method to a separate type to customize config for it. [Benchmark] [WarmupCount(1)] public void SingleWarmupIteration() [Benchmark] [WarmupCount(9)] public void NineWarmupIterations() Sortable parameter columns In order to sort columns of parameters in the results table, you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue] , lower priorities will appear earlier in the column order. The default priority is set to 0 . public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } Method B A Mean Error StdDev Benchmark 10 100 115.4 ms 0.12 ms 0.11 ms This feature got implemented by @JohannesDeml in #1612 . Customizable ratio column Now it's possible to customize the format of the ratio column. [Config(typeof(Config))] public class IntroRatioStyle { [Benchmark(Baseline = true)] public void Baseline() => Thread.Sleep(1000); [Benchmark] public void Bar() => Thread.Sleep(150); [Benchmark] public void Foo() => Thread.Sleep(1150); private class Config : ManualConfig { public Config() { SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend); } } } | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|-------------:|--------:| | Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms | baseline | | | Bar | 150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster | 0.00x | | Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower | 0.00x | This feature was implemented in #731 . Improved CoreRun support BenchmarkDotNet was reporting invalid .NET Core version number when comparing performance using CoreRuns built from dotnet/corefx and dotnet/runtime . Fixed by @adamsitnik in #1580 In #1552 @stanciuadrian has implemented support for all GcMode characteristics for CoreRunToolchain . Previously the settings were just ignored, now they are being translated to corresponding COMPlus_* env vars. Improved CoreRT support CoreRT has moved from https://github.com/dotnet/corert/ to https://github.com/dotnet/runtimelab/tree/feature/NativeAOT and we had to update the default compiler version and nuget feed address. Moreover, there was a bug in CoreRtToolchain which was causing any additional native dependencies to not work. Big thanks to @MichalStrehovsky , @jkotas and @kant2002 for their help and support! #1606 , #1643 , #1679 Command-line argument support in BenchmarkRunner So far only BenchmarkSwitcher was capable of handling console line arguments. Thanks to @chan18 BenchmarkRunner supports them as well ( #1292 ): public class Program { public static void Main(string[] args) => BenchmarkRunner.Run(typeof(Program).Assembly, args: args); } New API: ManualConfig.CreateMinimumViable ManualConfig.CreateEmpty creates a completely empty config. Without adding a column provider and a logger to the config the users won't see any results being printed. In #1582 @adamsitnik has introduced a new method that creates minimum viable config: IConfig before = ManualConfig.CreateEmpty() .AddColumnProvider(DefaultColumnProviders.Instance) .AddLogger(ConsoleLogger.Default); IConfig after = ManualConfig.CreateMinimumViable(); Benchmarking NuGet packages from custom feeds In #1659 @workgroupengineering added the possibility to indicate the source of the tested nuget package and whether it is a pre-release version. IConfig config = DefaultConfig.Instance .AddJob(Job.Default .WithNuGet(\"BenchmarkDotNet\", \"0.13.0\", new Uri(\"https://api.nuget.org/v3/index.json\")) .WithId(\"0.13.0\")) .AddJob(Job.Default .WithNuGet(\"BenchmarkDotNet\", \"0.12.1.1534\", new Uri(\"https://ci.appveyor.com/nuget/benchmarkdotnet\"), prerelease: true) .WithId(\"0.12.1.1534\")); Deterministic benchmark builds BenchmarkDotNet is now always enforcing Deterministic builds ( #1489 ) and Optimizations enabled ( #1494 ) which is a must-have if you are using custom build configurations. MSBuild enforces optimizations only for configurations that are named Release (the comparison is case-insensitive). <ItemGroup Condition=\" '$(Configuration)' == 'X' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"1.0.0\" /> </ItemGroup> <ItemGroup Condition=\" '$(Configuration)' == 'Y' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"2.0.0\" /> </ItemGroup> var config = DefaultConfig.Instance .AddJob(Job.Default.WithCustomBuildConfiguration(\"X\").WithId(\"X\").AsBaseline()) .AddJob(Job.Default.WithCustomBuildConfiguration(\"Y\").WithId(\"Y\")); #1489 , #1494 Improved Hardware Counters support BenchmarkDotNet is being used by the .NET Team to ensure that .NET is not regressing. More than three thousand benchmarks (they can be found here ) are being executed multiple times a day on multiple hardware configs. Recently, .NET Team started to use InstructionsRetired to help to filter unstable benchmarks that report regressions despite not changing the number of instructions retired. This has exposed few bugs in Hardware Counters support in BenchmarkDotNet, which all got fixed by @adamsitnik in #1547 and #1550 . Moreover, we have removed the old PmcDiagnoser and extended EtwProfiler with the hardware counters support. It's just much more accurate and futureproof. For details, please go to #1548 . How stable was PmcDiagnoser (same benchmarks run twice in a row on the same machine): Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 845,746 Burgers_0 .NET Core 2.1 30,154,151 Burgers_0 .NET Framework 4.6.1 4,230,848 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 34,154,524 Burgers_0 .NET Core 2.1 246,534,203 Burgers_0 .NET Framework 4.6.1 2,607,686 How stable is EtwProfiler : Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,069,978,261 Burgers_0 .NET Core 2.1 3,676,000,000 Burgers_0 .NET Framework 4.6.1 3,468,866,667 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,066,810,000 Burgers_0 .NET Core 2.1 3,674,666,667 Burgers_0 .NET Framework 4.6.1 3,468,600,000 Moreover, in #1540 @WojciechNagorski has added the removal of temporary files created by EtwProfiler . Improved Troubleshooting We have the possibility to ask BDN to stop on the first error: --stopOnFirstError true . The problem was when the users had not asked for that, tried to run n benchmarks, all of them failed to build, and BDN was printing the same build error n times. In #1672 @adamsitnik has changed that, so when all the build fails, BDN stops after printing the first error. Moreover, we have also changed the default behavior for the failed builds of the boilerplate code. If the build fails, we don't remove the files. Previously we have required the users to pass --keepFiles to keep them. See #1567 for more details and don't forget about the Troubleshooting docs! Docs and Samples improvements Big thanks to @lukasz-pyrzyk , @fleckert , @MarecekF , @joostas , @michalgalecki , @WojciechNagorski , @MendelMonteiro , @kevinsalimi , @cedric-cf , @YohDeadfall , @jeffhandley and @JohannesDeml who have improved our docs and samples! #1463 , #1465 , #1508 , #1518 , #1554 , #1568 , #1601 , #1633 , #1645 , #1647 , #1657 , #1675 , #1676 , #1690 . Template improvements Projects created out of our official templates might have been unexpectedly packed when running dotnet pack on the entire solution. In #1584 @kendaleiv has explicitly disabled packing for the template. The template had netcoreapp3.0 TFM hardcoded. This got fixed by @https://github.com/ExceptionCaught in #1630 and #1632 . In #1667 @YohDeadfall has changed the default debug type from portable to pdbonly (required by DisassemblyDiagnoser ). Bug fixes Very long string [Arguments] and [Params] were causing BenchmarkDotNet to crash. Fixed by @adamsitnik in #1248 and #1545 . So far trace file names were containing full benchmark names and arguments. Now if the name is too long, the trace file name is a hash (consistent for multiple runs of the same benchmark). The same goes for passing benchmark name by the host process to the benchmark process via command-line arguments. LangVersion set to a non-numeric value like latest was crashing the build. Fixed by @martincostello in #1420 . Windows 10 November 201 9 was being recognized as 201 8 . Fixed by @kapsiR in #1437 . Assemblies loaded via streams were not supported. Fixed by @jeremyosterhoudt in #1443 . NativeMemoryProfiler was detecting small leaks that were false positives. Fixed by @WojciechNagorski in #1451 and #1600 . DisassemblyDiagnoser was crashing on Linux. Fixed by @damageboy in #1459 . Target framework moniker was being printed as toolchain name for Full .NET Framework benchmarks. Fixed by @svick in #1471 . [ParamsSource] returning IEnumerable<object[]> was not working properly when combined with [Arguments] . Fixed by @adamsitnik in #1478 . NullReferenceException in MultimodalDistributionAnalyzer . Fixed by @suslovk in #1488 . NotSupportedException was being thrown if there was an encoding mismatch between host and benchmark process. Diagnosed by @ChristophLindemann in #1487 , fixed by @lovettchris in #1491 . MissingMethodException was being thrown in projects that referenced a newer version of Iced . Fixed by @Symbai in #1497 and in #1502 . AppendTargetFrameworkToOutputPath set to false was not supported. Fixed by @adamsitnik in #1563 A locking finalizer could have hanged benchmark process which would just print // AfterAll and never quit. Fixed by @adamsitnik in #1571 . To prevent other hangs from happening, a timeout of 250ms was added. If the process does not quit after running the benchmarks and waiting 250ms , it's being force killed. In some cases, JsonExporter was reporting NaN for some of the Statistics. This was breaking non-.NET JSON deserializers. Fixed by @marcnet80 in #1581 . UnitType.Size metrics were not using the provided number format. Fixed by @jodydonetti in #1569 and #1618 . MaxColumnWidth setting was not used for type names. Fixed by @JohannesDeml in #1609 . Current culture was not respected when formatting Ratio column values. Fixed by @JohannesDeml in #1610 . BenchmarkDotNet was redirecting Standard Error of the benchmark process, which was causing deadlocks for benchmarks that were writing to it. Fixed by @adamstinik in #1631 DisassemblyDiagnoser was failing to disassemble multiline source code. @YohDeadfall fixed that in #1674 . In #1644 @adamstinik has fixed the inconsistency between benchmark filter and hint. Removal of the dotnet global tool In #1006 (0.11.4) we have introduced a new dotnet global tool. By looking at the number of reported bugs we got to the conclusion that the tool has not passed the test of time. Why? Because it was based entirely on dynamic assembly loading which is very hard to get right in .NET and the fact that we support all existing .NET Runtimes (.NET, .NET Core, Mono, CoreRT) made it even harder (if not impossible). We have removed it and the old versions are no longer supported . For more details, please refer to #1572 . Milestone details In the v0.13.0 scope, 53 issues were resolved and 94 pull requests were merged. This release includes 111 commits by 37 contributors. Resolved issues (53) #721 Add possibility to customize BaselinedScaledColumn with provided func (assignee: @AndreyAkinshin ) #1136 benchmark / beforeEverything fails when running in docker-win #1242 bug JSON Exporter exports NaN for some properties. This fails most JSON parsers (assignee: @marcnet80 ) #1247 Support benchmarks with very long string arguments (assignee: @adamsitnik ) #1288 Fix Hardware Counters diagnoser (assignee: @adamsitnik ) #1290 BenchmarkRunner should support parsing console line arguments (assignee: @chan18 ) #1333 Getting \"Unknown Processor\" Again #1427 NativeMemoryProfiler reports false positive leak (assignee: @WojciechNagorski ) #1431 System.IO.FileNotFoundException with EtwProfiler #1433 Benchmarks work in .NET 4.7.2 but not .NET Core 3.1 #1436 Wrong OsBrandString for Windows 10 1909 #1448 NRE in MultimodalDistributionAnalyzer #1452 Setting LangVersion to Latest Causes an Error #1464 DisassemblyDiagnoserConfig.ExportDiff needs better description #1472 Add support of Wasm to Benchmark Dotnet (assignee: @naricc ) #1474 docs: Getting started guide #1480 BenchmarkRunner not working from VSTS agent (assignee: @lovettchris ) #1487 Benchmarks do not execute (as service process / VSTS agent) on non US systems #1493 Using WithCustomBuildConfiguration leads to always running with RyuJIT Debug (assignee: @adamsitnik ) #1495 [GcServer(true)] is ignored with --corerun #1496 System.MissingMethodException: Method not found: 'Iced.Intel.MasmFormatter.get_MasmOptions()'. #1512 Template has hardcoded netcoreapp3.0 TFM (assignee: @ExceptionCaught ) #1532 Auto-generated project has invalid XML #1535 Can't benchmark library that targets 'net5.0-windows' framework (assignee: @adamsitnik ) #1537 Failed to run benchmarks on .net 5 RC1 and Preview LangVersion #1539 Inconsistency between benchmark filter and hint (assignee: @adamsitnik ) #1544 [EtwProfiler] Merge operation failed return code 0x3 (assignee: @adamsitnik ) #1546 Sometimes Hardware Counters per Op are reported as NaNs (assignee: @adamsitnik ) #1549 InstructionPointerExporter has been broken for a while (assignee: @adamsitnik ) #1559 [Docs] Update Console Args doc (assignee: @kevinsalimi ) #1561 NativeMemoryProfiler doesn't report allocations in v0.12.1.1432 Nightly (assignee: @WojciechNagorski ) #1564 error MSB4086: A numeric comparison was attempted on \"$(LangVersion)\" (assignee: @adamsitnik ) #1565 More consistent formatting of results #1566 BDN should not delete temporary build directories for failed builds (assignee: @adamsitnik ) #1570 Benchmark runs failing when using .NET 5 RC2 SDK installed via snap (assignee: @adamsitnik ) #1576 Missing/misleading version number with corerun #1585 Non-optimized dependency #1591 Wasm Benchmark Runs Failing with Target Framework Error (assignee: @naricc ) #1598 VB Net Framework project throws exception from command line tool #1605 CoreRT / NativeAOT version (assignee: @adamsitnik ) #1607 Exporter approval tests has recently become unstable (assignee: @marcnet80 ) #1613 EventPipeProfiler generating invalid SpeedScope files. #1616 BenchmarkDotNet fail in WPF project with .NET 5.0-windows target #1620 NullReferenceException in v0.12.1 #1623 Can I run Full Framework benchmarks without having a Console App? (assignee: @adamsitnik ) #1628 Installation uses legacy/archaic dotnetcore 2.1.503 (assignee: @adamsitnik ) #1629 Writing to Console.Error in benchmarked code causes a deadlock (assignee: @adamsitnik ) #1654 Update for 0.12.2 #1670 dotnet benchmark cli tool errors with .net5.0 assemblies (assignee: @adamsitnik ) #1673 Source code provider incorrectly handles multiline source code #1685 Support for SingleFile && SelfContained apps #1692 Bug running wasm benchmarks - Broken Pipe in writeline #1693 Estimate Date for Supporting .NET 6 (assignee: @adamsitnik ) Merged pull requests (94) #1097 Allow for Config per method, introduce OS and OSArchitecture filters (by @adamsitnik ) #1248 Support very long string as benchmark arguments (by @adamsitnik ) #1292 passed args to benchmark runner (by @chan18 ) #1360 Basic BenchmarkDotNet support for Xamarin (by @jonathanpeppers ) #1420 Fix MSB4086 if LangVersion is a keyword (by @martincostello ) #1426 Fix typo in log message (by @martincostello ) #1429 [xamarin] fix Mono runtime version detection (by @jonathanpeppers ) #1434 [samples] UI tweaks to Xamarin samples (by @jonathanpeppers ) #1437 Fix wrongly reported os brand string for Windows 10 1909 (by @kapsiR ) #1443 Handle assemblies loaded via a stream (by @jeremyosterhoudt ) #1451 Fix native memory profiler (by @WojciechNagorski ) #1454 always print full information about non-optimized dependencies (by @adamsitnik ) #1458 Don't try to parse blank lines (by @TysonMN ) #1459 Upgrades ClrMD to a version that will not crash on Linux :( (by @damageboy ) #1463 Updated Disassembler docs (by @lukasz-pyrzyk ) #1465 Improved doc description of the ExportDiff property (by @lukasz-pyrzyk ) #1471 Clearly display names for .Net Framework (by @svick ) #1478 ParamsSource returning IEnumerable<object[]> fixes (by @adamsitnik ) #1479 net5.0 does not contain \"core\" word but it's a .NET Core moniker (by @adamsitnik ) #1483 Add Wasm Tool Chain (by @naricc ) #1488 Safe access to CultureInfo (by @suslovk ) #1489 enforce Deterministic builds for auto-generated .NET Core projects (by @adamsitnik ) #1490 be less strict about verifying the Acknowledgment (by @adamsitnik ) #1491 set process output encoding to utf8 so BenchmarkRunnerDotNet works in self hosted VSTS agent. (by @lovettchris ) #1492 allow the users to specify Platform via console args (by @adamsitnik ) #1494 enforce Optimizations when using Custom Build Configurations (by @adamsitnik ) #1497 Update to latest Iced 1.7.0 (by @Symbai ) #1498 Pedantic WASM improvements (by @adamsitnik ) #1500 Wasm: samples, docs and a bug fix (by @adamsitnik ) #1501 Add Custom Runtime Pack option (by @naricc ) #1502 Update to latest Iced (by @Symbai ) #1503 Update MeasurementsStatistics.cs (by @skynode ) #1507 Change mono-config.js format in the Wasm Tool Chain for ICU support (by @naricc ) #1508 fixed typo (by @fleckert ) #1509 [xamarin] fix for DebugConfig and read-only file system (by @jonathanpeppers ) #1518 FactorialWithTailing - incorrect implementation (by @MarecekF ) #1523 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (by @adamsitnik ) #1540 Remove unneeded files after etw profiler (by @WojciechNagorski ) #1545 Fix Merge operation failed for EtwProfiler (by @adamsitnik ) #1547 hardware counters: don't try to exclude non-existing overhead for long running benchmarks (by @adamsitnik ) #1548 Remove the old PmcDiagnoser, EtwProfiler is much more accurate (by @adamsitnik ) #1550 Bring instruction pointer exporter back to live (by @adamsitnik ) #1552 Enable supported GcMode characteristics with corerun (by @stanciuadrian ) #1554 Documentation: add --maxWidth description (by @joostas ) #1556 Simplify code: remove sort before adding to HashSet (by @stanciuadrian ) #1560 Add support for Platform-specific TFMs introduced in .NET 5 (by @adamsitnik ) #1563 ensure that the auto-generated project alwas has tfm in the output path (by @adamsitnik ) #1567 Dont remove artifacts when build fails (by @adamsitnik ) #1568 Update getting-started.md (by @michalgalecki ) #1569 Respect size number format in MetricColumn (by @jodydonetti ) #1571 Dispose parameters, kill benchmarking process when it hangs after printing the results (by @adamsitnik ) #1572 Remove the dotnet global tool (by @adamsitnik ) #1573 Don't run the benchmark once per iteration if only the first ivocation lasts longer than IterationTime (by @adamsitnik ) #1580 use Environment.Version to determine .NET 5+ versions (by @adamsitnik ) #1581 Json exporter fix (by @marcnet80 ) #1582 introduce ManualConfig.CreateMinimumViable() method (by @adamsitnik ) #1584 Prevent dotnet pack from packaging benchmark projects (by @kendaleiv ) #1587 Memory Randomization (by @adamsitnik ) #1590 Update message to not suggest an obsolete API (by @martincostello ) #1592 Add wasmnet50 wasmnet60 monikers (by @naricc ) #1600 fix issue #1561 (by @WojciechNagorski ) #1601 Update README.md (by @WojciechNagorski ) #1606 CoreRT feed and version update (by @adamsitnik ) #1609 Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (by @JohannesDeml ) #1610 Fix add missing culuture info to ToString in RatioStyle (by @JohannesDeml ) #1612 Sorting parameter columns with parameter priority (by @JohannesDeml ) #1618 Json indentation level fix (by @marcnet80 ) #1630 Update framework symbol on dotnet new template #1512 (by @ExceptionCaught ) #1631 don't redirect Standard Error, as we don't read it and writing to it by benchmark can cause deadlocks (by @adamsitnik ) #1632 update console app templating (by @ExceptionCaught ) #1633 Update etwprofiler.md (by @MendelMonteiro ) #1635 Install local SDK without sudo on Unix (by @am11 ) #1637 .NET Core 2.1 -> .NET 5.0 (by @adamsitnik ) #1643 Remove CoreRT workaround (by @MichalStrehovsky ) #1644 Filter hint improvements (by @adamsitnik ) #1645 Update Console Args doc #1559 (by @kevinsalimi ) #1647 Update API in documentation #1602 (by @kevinsalimi ) #1652 Basic snap support (by @adamsitnik ) #1657 1655 doc with options obsolete usage of with (by @cedric-cf ) #1659 feat: Allowed to indicate the source of nuget package and whether it is a pre-release version. (by @workgroupengineering ) #1662 Add tool chain for Netcore Mono AOT. (by @naricc ) #1667 Changed default debug type to pdbonly (by @YohDeadfall ) #1672 when all builds fail, BDN should stop after printing first error (by @adamsitnik ) #1674 Fixed smart pointer for multiline source code (by @YohDeadfall ) #1675 Updated disassembler contribution docs (by @YohDeadfall ) #1676 Fix a docs typo (by @jeffhandley ) #1679 Fix location for NativeAOT publish files (by @kant2002 ) #1686 Resolve assembly location for SingleFile (by @am11 ) #1689 Dont redirect standard input for WASM (by @naricc ) #1690 Fix change runtime target to Core50 (by @JohannesDeml ) #1691 don't remove OS version number from the platform-specifc TFM (by @adamsitnik ) #1697 0.13.0 release notes (by @adamsitnik ) #1698 Update \"View results\" from \"Getting started\" (by @rstm-sf ) #1707 Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm template (by @naricc ) Commits (111) 117c37 Postrelease update of v0.12.1 changelog (by @AndreyAkinshin ) 742f44 Fix typo (by @AndreyAkinshin ) 82b15e Fix MSB4086 if LangVersion is a keyword (#1420) (by @martincostello ) 9c0f52 Xamarin Support (#1360) (by @jonathanpeppers ) e37c02 Fix typo in log message (#1426) (by @martincostello ) ccdf22 [xamarin] fix Mono runtime version detection (#1429) (by @jonathanpeppers ) d95493 [samples] UI tweaks to Xamarin samples (#1434) (by @jonathanpeppers ) d07604 Fix wrongly reported os brand string for Windows 10 1909 (#1437) (by @kapsiR ) 1efd5e Handle assemblies loaded via a stream (#1443) (by @jeremyosterhoudt ) 502ad7 Update OsBrandStringHelper.cs (by @AndreyAkinshin ) 67971e Update OsBrandStringTests.cs (by @AndreyAkinshin ) ceef31 don't try to parse blank lines #1456 (#1458) (by @TysonMN ) 9a3469 Upgrades ClrMD to a version that will not crash on Linux :( (#1459) (by @damageboy ) bd1c93 Updated Disassembler settings (#1463) (by @lukasz-pyrzyk ) 35f50f Improved doc description of the ExportDiff property (#1465) (by @lukasz-pyrzyk ) dbbab9 Clearly display names for .Net Framework (#1471) (by @svick ) 044591 ParamsSource returning IEnumerable<object[]> fixes (#1478) (by @adamsitnik ) 703d54 Safe access to CultureInfo (by @suslovk ) a4dd37 Update to latest Iced (#1497) (by @Symbai ) 092889 Add Wasm Tool Chain (#1483) (by @naricc ) 01455d set process output encoding to utf8 (#1491) (by @lovettchris ) fa7da4 net5.0 does not contain \"core\" word but it's a .NET Core moniker (#1479) (by @adamsitnik ) 254da4 enforce Optimizations when using Custom Build Configurations (#1494) (by @adamsitnik ) 765d52 allow the users to specify Platform via console args (#1492) (by @adamsitnik ) 908b09 always print full information about non-optimized dependencies (#1454) (by @adamsitnik ) 1ff50a Pedantic WASM improvements (#1498) (by @adamsitnik ) d57c4c enforce Deterministic builds for auto-generated .NET Core projects (#1489) (by @adamsitnik ) 59080c Support very long string as benchmark arguments (#1248) (by @adamsitnik ) 9c5663 Wasm: samples, docs and a bug fix (#1500) (by @adamsitnik ) 13ee8b Add Custom Runtime Pack option to WasmToolchain (#1501) (by @naricc ) b356ac Update to latest Iced (#1502) (by @Symbai ) 797ced fixed typo (#1508) (by @fleckert ) ef0ac7 Change mono-config.js format in the Wasm Tool Chain for ICU support (#1507) (by @naricc ) eb20d3 Update README (by @AndreyAkinshin ) 92474e make MeasurementsStatistics a readonly ref struct (#1503) (by @skynode ) 64cc94 [xamarin] fix for DebugConfig and read-only file system (#1509) (by @jonathanpeppers ) c8af03 FactorialWithTailing - fix incorrect sample implementation (#1518) (by @MarecekF ) c9f158 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (#1523) (by @adamsitnik ) e4d37d Fix native memory profiler (#1451) (by @WojciechNagorski ) 10abc4 Remove unneeded files after etw profiler (#1540) (by @WojciechNagorski ) e8d085 Documentation: add --maxWidth description (#1554) (by @joostas ) c6cd54 Update CorrectionsSuggester.cs (#1556) (by @stanciuadrian ) be769f Enable supported GcMode characteristics with corerun (#1552) (by @stanciuadrian ) 0a004a Update getting-started.md (#1568) (by @michalgalecki ) cd0bda Respect size number format in MetricColumn (#1569), fixes #1565 (by @jodydonetti ) 349e90 Introduce RatioStyle, fix #721 (by @AndreyAkinshin ) 718031 hardware counters: don't try to exclude non-existing overhead for long runnin... (by @adamsitnik ) fbd52c remove the old PmcDiagnoser, EtwProfiler is much more accurate (#1548) (by @adamsitnik ) 152414 Bring instruction pointer exporter back to live (#1550) (by @adamsitnik ) c6d6fb Fix Merge operation failed for EtwProfiler (#1545) (by @adamsitnik ) 769090 Add support for Platform-specific TFMs introduced in .NET 5 (#1560) (by @adamsitnik ) 8de321 ensure that the auto-generated project alwas has target framework moniker in ... (by @adamsitnik ) 0f9bb3 Dont remove artifacts when build fails (#1567) (by @adamsitnik ) b4bda1 Dispose parameters, kill benchmarking process when it hangs after printing th... (by @adamsitnik ) c209b1 Remove the dotnet global tool (#1572) (by @adamsitnik ) 178b6a Don't run the benchmark once per iteration if only the first ivocation lasts ... (by @adamsitnik ) 8b2214 use Environment.Version to determine .NET 5+ versions (#1580) (by @adamsitnik ) d5c158 Prevent dotnet pack from packaging benchmark projects (#1584) (by @kendaleiv ) 8149c3 Json exporter fix for double.NaN (#1581), fixes #1242 (by @marcnet80 ) c63fe8 Update message to not suggest an obsolete API (#1590) (by @martincostello ) 0de41c Added wasmnet50 wasmnet60 monikers. (#1592) (by @naricc ) 992719 fix issue #1561 (#1600) (by @WojciechNagorski ) 81c234 Update README.md (#1601) (by @WojciechNagorski ) 641ffd Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (#1609) (by @JohannesDeml ) e72ddf Fix add missing culuture info to ToString in RatioStyle (#1610) (by @JohannesDeml ) d17926 Json indentation level fix (#1618) (by @marcnet80 ) 40f6e5 Update framework symbol on dotnet new template #1512 (#1630) (by @ExceptionCaught ) ffc8dd use .AddDiagnoser instead of the obsolete .With in the EtwProfiler doc sample... (by @MendelMonteiro ) 5d421c Install local SDK without sudo on Unix (#1635) (by @am11 ) d71a7e update console app templating (#1632) (by @ExceptionCaught ) aef9cb Sorting parameter columns with parameter priority (#1612) (by @JohannesDeml ) d5f7b9 Memory Randomization (#1587) (by @adamsitnik ) 5b2167 don't redirect Standard Error, as we don't read it and writing to it by bench... (by @adamsitnik ) a7af81 introduce ManualConfig.CreateMinimumViable() method (#1582) (by @adamsitnik ) 852bb8 .NET Core 2.1 -> .NET 5.0 (#1637) (by @adamsitnik ) e01312 Support latest Windows and macOS versions in OsBrandStringHelper (by @AndreyAkinshin ) 502dc9 CoreRT feed and version update (#1606) (by @adamsitnik ) 9f5d70 Remove CoreRT workaround (#1643) (by @MichalStrehovsky ) 6a151f passed args to benchmark runner (#1292) (by @chan18 ) bf63b3 Update Console Args doc, fixes #1559 (#1645) (by @kevinsalimi ) 970d28 Update API in documentation, fixes #1602 (#1647) (by @kevinsalimi ) d758f6 Allow for Config per method, introduce OS and OSArchitecture filters (#1097) (by @adamsitnik ) b4e2b6 1655 doc with options obsolete usage of with (#1657) (by @cedric-cf ) 8c28c8 add basic snap support (#1652) (by @adamsitnik ) e1c8cb Filter hint improvements (#1644) (by @adamsitnik ) 349f9d feat: Allowed to indicate the source of nuget package and whether it is a pre... (by @workgroupengineering ) 4a917d Add tool chain for Netcore Mono AOT. (#1662) (by @naricc ) 314a27 [Templates] Changed default debug type to pdbonly (#1667) (by @YohDeadfall ) 2616cd Updated disassembler contribution docs (#1675) (by @YohDeadfall ) 02b907 Fix a typo (#1676) (by @jeffhandley ) b67cfb Fix location for NativeAOT publish files (#1679) (by @kant2002 ) 63e28c when all builds fail, BDN should stop after printing first error (#1672) (by @adamsitnik ) becc13 Dont redirect standard input for WASM (#1689) (by @naricc ) b97bf6 Fix change runtime target to Core50 (#1690) (by @JohannesDeml ) 0321a3 Fixed smart pointer for multiline source code (#1674) (by @YohDeadfall ) 7265c1 Resolve assembly location for SingleFile (#1686) (by @am11 ) 626dcb don't remove OS version number from the platform-specifc TFM (#1691) (by @adamsitnik ) 95608d 0.13.0 release notes (#1697) (by @adamsitnik ) 4b5a65 Remove Allocated column from the \"View results\" doc page (#1698) (by @rstm-sf ) b0683f Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm templa... (by @naricc ) 09afe7 Windows 21H1 support in OsBrandStringHelper (by @AndreyAkinshin ) 77b58d Update old changelogs (by @AndreyAkinshin ) 2f4b79 Improve AsyncBenchmarksTests.TaskReturningMethodsAreAwaited (by @AndreyAkinshin ) a79339 Disable CoreRtToolchain.Core50 in ThreadingDiagnoserTests.GetToolchains on Unix (by @AndreyAkinshin ) 18e292 Update README (by @AndreyAkinshin ) 09a204 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 85db95 Bump Cake version: 0.37.0->1.1.0 (by @AndreyAkinshin ) 5c74d5 Bump docfx version: 2.51->2.57.2 (by @AndreyAkinshin ) 2a2c0c Update copyright year (2021) (by @AndreyAkinshin ) 396060 Prepare v0.13.0 changelog (by @AndreyAkinshin ) 6dcf43 Set library version: 0.13.0 (by @AndreyAkinshin ) Contributors (37) Adam Sitnik ( @adamsitnik ) Adeel Mujahid ( @am11 ) Adrian Stanciu ( @stanciuadrian ) Andrey Akinshin ( @AndreyAkinshin ) Andrii Kurdiumov ( @kant2002 ) Cédric Charière Fiedler ( @cedric-cf ) chan18 ( @chan18 ) Chris Lovett ( @lovettchris ) damageboy ( @damageboy ) Dexter ( @skynode ) Florian Eckert ( @fleckert ) Jeff Handley ( @jeffhandley ) jeremyosterhoudt ( @jeremyosterhoudt ) Jody Donetti ( @jodydonetti ) Johannes Deml ( @JohannesDeml ) Jonathan Peppers ( @jonathanpeppers ) Jonathon Wei ( @ExceptionCaught ) Justas ( @joostas ) kapsiR ( @kapsiR ) Ken Dale ( @kendaleiv ) Kevin Salimi ( @kevinsalimi ) Konstantin ( @suslovk ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) marcnet80 ( @marcnet80 ) MarecekF ( @MarecekF ) Martin Costello ( @martincostello ) Mendel Monteiro-Beckerman ( @MendelMonteiro ) Michał Gałecki ( @michalgalecki ) Michal Strehovský ( @MichalStrehovsky ) Nathan Ricci ( @naricc ) Petr Onderka ( @svick ) Rustam Sayfutdinov ( @rstm-sf ) Symbai ( @Symbai ) Tyson Williams ( @TysonMN ) Wojciech Nagórski ( @WojciechNagorski ) workgroupengineering ( @workgroupengineering ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: May 19, 2021 Milestone: v0.13.0 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.0 BenchmarkDotNet v0.12.1 Highlights .NET 5 support As you probably know, .NET Core 5 was officially rebranded to .NET 5. The new version of BenchmarkDotNet supports the new runtime after rebranding. #1399 465ebf Perfolizer adoption The internal statistical engine of BenchmarkDotNet became mature enough to be transformed into an independent project. Meet perfolizer — a toolkit for performance analysis! While BenchmarkDotNet focuses on obtaining reliable measurements, perfolizer focuses on the decent analysis of measured data. You still can use all the statistical algorithms from BenchmarkDotNet, but you can also install perfolizer as a standalone NuGet package . You can find more details in the official announcement . #1386 54a061 Cross-platform disassembler Now the DisassemblyDiagnoser is cross-platform! The disassembling logic was also improved, now it handles runtime helper methods and references to method tables properly. Internally, it uses the Iced library for formatting assembly code. Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! #1332 #899 #1316 #1364 294320 EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! Just mark your class with the [EventPipeProfiler(...)] attribute and get a .speedscope.json file that you can browse in SpeedScope . Special thanks to @WojciechNagorski for the implementation! #1321 #1315 c648ff New fluent API We continue to improve our API and make it easier for reading and writing. Special thanks to @WojciechNagorski for the implementation! #1273 #1234 640d88 Ref readonly support Now you can use ref readonly in benchmark signatures. Special thanks to @adamsitnik for the implementation! #1389 #1388 9ac777 Cross-platform disassembler Just mark your benchmark class with the [DisassemblyDiagnoser] attribute and you will get the disassembly listings for all the benchmarks. The formatting looks pretty nice thanks to Iced . It works like a charm on Windows, Linux, and macOS. [DisassemblyDiagnoser] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumLocal() mov rax,[rcx+8] xor edx,edx xor ecx,ecx mov r8d,[rax+8] test r8d,r8d jle short M00_L01 M00_L00: movsxd r9,ecx add edx,[rax+r9*4+10] inc ecx cmp r8d,ecx jg short M00_L00 M00_L01: mov eax,edx ret ; Total bytes of code 35 .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumField() sub rsp,28 xor eax,eax xor edx,edx mov rcx,[rcx+8] cmp dword ptr [rcx+8],0 jle short M00_L01 M00_L00: mov r8,rcx cmp edx,[r8+8] jae short M00_L02 movsxd r9,edx add eax,[r8+r9*4+10] inc edx cmp [rcx+8],edx jg short M00_L00 M00_L01: add rsp,28 ret M00_L02: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 53 Now we handle runtime helper methods and references to method tables properly. Example: Before: ; MicroBenchmarks.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20h mov rsi,rcx cmp edx,7FFFFFFFh jne M00_L00 call MicroBenchmarks.WithCallsAfter.Static() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Instance() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Recursive() mov rcx,rsi mov rax,qword ptr [rsi] mov rax,qword ptr [rax+40h] call qword ptr [rax+20h] mov rcx,rsi mov edx,1 mov rax,7FF8F4217050h add rsp,20h pop rsi jmp rax M00_L00: mov rcx,offset System_Private_CoreLib+0xa31d48 call coreclr!MetaDataGetDispenser+0x322a0 mov rsi,rax mov ecx,0ACFAh mov rdx,7FF8F42F4680h call coreclr!MetaDataGetDispenser+0x17140 mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call coreclr!coreclr_shutdown_2+0x39f0 int 3 add byte ptr [rax],al sbb dword ptr [00007ff9`26284e30],eax add dword ptr [rax+40h],esp add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax-70BC4CCh],ah ; Total bytes of code 157 After: ; BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20 mov rsi,rcx cmp edx,7FFFFFFF jne M00_L00 call BenchmarkDotNet.Samples.WithCallsAfter.Static() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Instance() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Recursive() mov rcx,rsi mov rax,[rsi] mov rax,[rax+40] call qword ptr [rax+20] mov rcx,rsi mov edx,1 mov rax BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Boolean) add rsp,20 pop rsi jmp rax M00_L00: mov rcx MT_System.InvalidOperationException call CORINFO_HELP_NEWSFAST mov rsi,rax mov ecx,12D mov rdx,7FF954FF83F0 call CORINFO_HELP_STRCNS mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call CORINFO_HELP_THROW int 3 ; Total bytes of code 134 See also: Cross-runtime .NET disassembly with BenchmarkDotNet . Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! If you want to use the new profiler, you should just mark your benchmark class with the [EventPipeProfiler(...)] attribute: [EventPipeProfiler(EventPipeProfile.CpuSampling)] // <-- Enables new profiler public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } Once the benchmark run is finished, you get a .speedscope.json file that can be opened in SpeedScope : The new profiler supports several modes: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Please see Wojciech Nagórski's blog post for all the details. Special thanks to @WojciechNagorski for the implementation! New fluent API We continue to improve our API and make it easier for reading and writing. The old API is still existing, but it is marked as obsolete and will be removed in the further library versions. The most significant changes: Changes in Job configuration Changes in IConfig/ManualConfig Full fluent API Special thanks to @WojciechNagorski for the implementation! Ref readonly support Now you can use ref readonly in benchmark signatures. Here is an example: public class RefReadonlyBenchmark { static readonly int[] array = { 1 }; [Benchmark] public ref readonly int RefReadonly() => ref RefReadonlyMethod(); static ref readonly int RefReadonlyMethod() => ref array[0]; } Special thanks to @adamsitnik for the implementation! Milestone details In the v0.12.1 scope, 31 issues were resolved and 42 pull requests were merged. This release includes 85 commits by 19 contributors. Resolved issues (31) #641 RPlotExporter hanging (assignee: @m-mccormick ) #899 Tiered compilation and disassembler (assignee: @adamsitnik ) #1023 Out of process benchmarks fail with ASP.NET Core SDK reference #1211 Binding Redirect Issues When Using Xml Serializers #1234 Strong type fluent API proposal (assignee: @WojciechNagorski ) #1238 RunAllJoined Causing Exception (assignee: @gsomix ) #1262 Params attribute doesn`t work in F# if you specify more than one enum value in constructor (assignee: @gsomix ) #1295 Custom format/culture for report output values (for CSV, and maybe HTML, MD) #1305 Copy UserSecrets from benchmark project #1311 Spelling nit (assignee: @AndreyAkinshin ) #1312 Add an option to pass environment variables to the default job #1315 Implement cross platform EventPipeProfiler diagnoser (assignee: @WojciechNagorski ) #1316 Implement Unix Disassembler for .NET Core (assignee: @adamsitnik ) #1318 use of NugetReference[] causes System.MissingMethodException: No parameterless constructor defined for this object. (assignee: @adamsitnik ) #1323 DisassemblyDiagnoser index outside array bounds (assignee: @AndreyAkinshin ) #1325 Surface native code size benchmarked code (assignee: @adamsitnik ) #1326 BDN does not build using dotnet sdk from the command line in Linux #1339 Generated code and StyleCop.Analyzers (assignee: @adamsitnik ) #1348 Different display text for arrays depending on a value source (assignee: @YohDeadfall ) #1350 Warn the user if command line arguments were not passed to the BenchmarkSwitcher #1353 Show Length when param type is an array #1361 SimpleJobAttribute with RunStrategy and RuntimeMoniker #1363 Wrong assembly binding redirects for Microsoft.Data.SqlClient.resources ; using in Netcore3.0 project (assignee: @adamsitnik ) #1364 Bug: Benchmark class with Console.WriteLine(1) fails for DisassemblyDiagnoser with 'Sequence contains no matching element' (assignee: @adamsitnik ) #1369 Parameter column doesn't seem to respect culture info (assignee: @Tyrrrz ) #1379 Unix CI builds are red (assignee: @AndreyAkinshin ) #1385 Make BaselineCustomColumn.GetValue public #1388 'ref readonly' return is not supported (assignee: @adamsitnik ) #1396 MacOS Azure Pipeline build is broken (assignee: @AndreyAkinshin ) #1413 Plot with only one \"default\" Job (assignee: @AndreyAkinshin ) #1416 EventPipeProfiler Documentation (assignee: @WojciechNagorski ) Merged pull requests (42) #1258 Task add style cope and fxcop analyzers (by @WojciechNagorski ) #1263 Configuration compatibility validation (by @gsomix ) #1266 Add EnumParam preserving type information (by @gsomix ) #1273 New fluent API (by @WojciechNagorski ) #1287 EdPeltChangePointDetector improvements (by @jeanbern ) #1300 Update link of \" official benchmarking guide\" to use the new recommended link (by @eriawan ) #1301 Improve BenchmarkDotNet.Templates (by @AndreyAkinshin ) #1302 CultureInfo Refactoring (by @AndreyAkinshin ) #1307 Fix project file order (by @vilinski ) #1309 Copy UserSecrets from benchmark project (by @kant2002 ) #1313 add possibility to specify env vars via console line arguments (by @adamsitnik ) #1321 The EventPipeProfiler cross-platform profiler (by @WojciechNagorski ) #1327 Add package-refs to reference assemblies for linux build (by @damageboy ) #1329 Show information about docker (by @WojciechNagorski ) #1331 Use 24-hour time in joined summary file name (by @jroessel ) #1332 Improved and Cross platform disassembler (by @adamsitnik ) #1335 Attribute improvements (by @WojciechNagorski ) #1340 Improvement of csproj finding (by @WojciechNagorski ) #1349 Fixed display text for array parameters and arguments (by @YohDeadfall ) #1357 add the header at the top of the generated file to avoid static analysis tools from analyzing it, (by @adamsitnik ) #1359 Warn if command line arguments were not passed to the BenchmarkSwitcher (by @suslovk ) #1365 Use DirtyAssemblyResolveHelper only for Full .NET Framework (by @adamsitnik ) #1366 add missing SimpleJobAttribute ctor (by @adamsitnik ) #1367 Await non-generic ValueTask returning method (by @mayuki ) #1372 Use CultureInfo when formatting parameter values (by @Tyrrrz ) #1373 fixes #641 (by @m-mccormick ) #1375 don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once again just to gather JIT info, the overhead is very small (by @adamsitnik ) #1376 update TraceEvent to 2.0.49 to get TailCalls working again (by @adamsitnik ) #1380 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (by @AndreyAkinshin ) #1381 Minor event pipe profiler improvements (by @adamsitnik ) #1384 Fix build after styleCop (by @WojciechNagorski ) #1386 Switch to perfolizer (by @AndreyAkinshin ) #1387 Make BaselineCustomColumn expose \"GetValue\" as a public API (by @damageboy ) #1389 Ref readonly support (by @adamsitnik ) #1394 Align homepage example with README (by @dahlbyk ) #1397 Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (by @AndreyAkinshin ) #1399 React to .NET 5 branding changes (by @jkotas ) #1407 Improve warnings for small operations number (by @CodeFuller ) #1410 Updating Document - Fixing a small grammar mistake (by @abhinavgalodha ) #1417 Fix --profiler option description. (by @WojciechNagorski ) #1418 EventPipeProfiler documentation (by @WojciechNagorski ) #1419 Small fix in EventPipeProfiler documentation (by @WojciechNagorski ) Commits (85) 396d4b #1262: Add EnumParam preserving type information (by @gsomix ) 718b77 #1262: Add tests (by @gsomix ) 33ec90 EdPeltChangePointDetector improvements (by @jeanbern ) 7e3efc Postrelease update of v0.12.0 changelog (by @AndreyAkinshin ) 8677b0 Update css in documentation (by @AndreyAkinshin ) 919b7f Fix link to IntroThreadingDiagnoser in diagnoser.md (by @AndreyAkinshin ) 4d15ea Update README.md (by @AndreyAkinshin ) f2d081 Update link of \" official benchmarking guide\" to use the new recommended link... (by @eriawan ) 05df0e Documentation: update article about command-line tool (by @AndreyAkinshin ) d69505 Improve BenchmarkDotNet.Templates (#1301) (by @AndreyAkinshin ) e23755 Speed up some integration tests (by @AndreyAkinshin ) 3d96bf Update NuGet package descriptions (by @AndreyAkinshin ) 351dae Update README.md (by @AndreyAkinshin ) 5f07f4 Add Windows 10 brand string for 19H1 (by @AndreyAkinshin ) fd92ff Update README.md (by @AndreyAkinshin ) 5af5c5 Update README.md (by @AndreyAkinshin ) 1b923f Fix project file order (#1307) (by @vilinski ) 57b01f Copy UserSecrets from benchmark project (#1309) (by @kant2002 ) 2415fd Fix some typos, fix #1311 (by @AndreyAkinshin ) e92d6d add possibility to specify env vars via console line arguments (#1313) (by @adamsitnik ) b7054c WithNuGet should accept NuGetReferenceList, not IReadOnlyCollection<NuGetRefe... (by @adamsitnik ) bb437b Remove curly braces for single statements (by @AndreyAkinshin ) 76c675 Improve code readability (by @AndreyAkinshin ) 8486e1 Merge pull request #1287 from jeanbern/patch-1 (by @AndreyAkinshin ) d6bf40 Update README.md (by @AndreyAkinshin ) 728c40 Support empty lines in disassembler/GetSmartPrefix, fix #1323 (by @AndreyAkinshin ) 0c48c2 CultureInfo Refactoring (#1302) (by @AndreyAkinshin ) 099550 Switch to using ms ref aseemblies for build (#1327) (by @damageboy ) 55842b Merge pull request #1266 from gsomix/feature/1262-fsharp-enums (by @AndreyAkinshin ) 35d358 Show information about docker (#1329) (by @WojciechNagorski ) b6283c Use 24-hour time in joined summary file name (#1331) (by @jroessel ) 640d88 New fluent API (#1273), fixes #1234 (by @WojciechNagorski ) a3f76b Update README (by @AndreyAkinshin ) 4a9697 Update copyright year (by @AndreyAkinshin ) 5e7f01 add the header at the top of the generated file to avoid s... (by @adamsitnik ) 07b512 Await non-generic ValueTask returning method (#1367) (by @mayuki ) 479177 Display array length for array parameters and arguments (#1349), fixes #1348 ... (by @YohDeadfall ) 3b8d2c Warn if command line arguments were not passed to the BenchmarkSwitcher (#135... (by @suslovk ) 87d85a Use CultureInfo when formatting parameter values (#1372) (by @Tyrrrz ) 310b5a add missing SimpleJobAttribute ctor, fixes #1361 (#1366) (by @adamsitnik ) 6a1458 change the way RPlotExporter reads the R script output, fixes #641 (#1373) (by @m-mccormick ) ff4c3d Attribute improvements (#1335) (by @WojciechNagorski ) 29eafb Improvement of csproj finding (#1340) (by @WojciechNagorski ) be2168 Use DirtyAssemblyResolveHelper only for Full .NET Framework (#1365) (by @adamsitnik ) 664ab6 update TraceEvent to 2.0.49 to get TailCalls working again (#1376) (by @adamsitnik ) b788bc don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once ... (by @adamsitnik ) 8ad2a9 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (#1380) (by @AndreyAkinshin ) 474047 Task add style cope and fxcop analyzers (#1258) (by @WojciechNagorski ) c648ff The EventPipeProfiler cross-platform profiler (#1321) (by @WojciechNagorski ) 19169a Add brand strings for latest Windows versions (by @AndreyAkinshin ) 532f84 Update README (by @AndreyAkinshin ) 3defd7 Minor event pipe profiler improvements (#1381) (by @adamsitnik ) 294320 Improved and Cross platform disassembler (#1332) (by @adamsitnik ) 1d63d6 Fix build after styleCop (#1384) (by @WojciechNagorski ) b3ba08 Make BaselineCustomColumn expose \"GetValue\" as a public API (#1387) (by @damageboy ) 54a061 Switch to perfolizer (by @AndreyAkinshin ) 9ac777 Ref readonly support (#1389) (by @adamsitnik ) c3286f Update CodeAnnotations.cs (by @AndreyAkinshin ) 3223c9 Code cleanup (by @AndreyAkinshin ) c19e54 Implement configurations compatibility validation (#1263), Closes #1238 (by @gsomix ) df434e Align homepage example with README (#1394) (by @dahlbyk ) 9a251a Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (#1397) (by @AndreyAkinshin ) 465ebf React to .NET 5 branding changes (#1399) (by @jkotas ) 6cca72 Updating a small grammar mistake (#1410) (by @abhinavgalodha ) 27b32e Improve warnings for small operations number (#1407) (by @CodeFuller ) 2d365b Fix --profiler option description. (#1417) (by @WojciechNagorski ) 7902cd Add macOS Catalina support in OsBrandStringHelper (by @AndreyAkinshin ) fd4c32 Update README (by @AndreyAkinshin ) 6e13ba Resolving JobId in DefaultCharacteristicPresenter, fix #1413 (by @AndreyAkinshin ) 35ebd2 Better job id generation in SimpleJobAttribute (by @AndreyAkinshin ) bf4778 Use ASCII mode for Measurement presentation in terminal (by @AndreyAkinshin ) f6b81f Display result path in RPlotExporter (by @AndreyAkinshin ) 30b269 Disable plot printing in BuildPlots.R (by @AndreyAkinshin ) 27887d Disable Rplots.pdf generation in BuildPlots.R (by @AndreyAkinshin ) 338e40 Specify uid for how-to-run.md (by @AndreyAkinshin ) f6dcd3 Add BenchmarkDotNet.Annotations in API documentation (by @AndreyAkinshin ) b503fd Bump DocFX version from 2.46 to 2.51 (by @AndreyAkinshin ) f457e7 Prepare v0.12.1 changelog (by @AndreyAkinshin ) 53d090 Fix documentation.md (by @AndreyAkinshin ) e72897 Add v0.12.1 highlights (by @AndreyAkinshin ) 2de040 Bump perfolizer version from 0.2.0 to 0.2.1 (by @AndreyAkinshin ) 76a070 EventPipeProfiler documentation (#1418) (by @WojciechNagorski ) 928fb1 EventPipeProfiler doc improvements (#1419) (by @WojciechNagorski ) 12798e Update documentation (by @AndreyAkinshin ) 384d47 Set library version: 0.12.1 (by @AndreyAkinshin ) Contributors (19) Abhinav Galodha ( @abhinavgalodha ) Adam Sitnik ( @adamsitnik ) Alexey Golub ( @Tyrrrz ) Andreas Vilinski ( @vilinski ) Andrey Akinshin ( @AndreyAkinshin ) Andrii Kurdiumov ( @kant2002 ) CodeFuller ( @CodeFuller ) damageboy ( @damageboy ) Eriawan Kusumawardhono ( @eriawan ) Evgeniy Andreev ( @gsomix ) Jan Kotas ( @jkotas ) Jean-Bernard Pellerin ( @jeanbern ) Johannes Rössel [yWorks] ( @jroessel ) Keith Dahlby ( @dahlbyk ) Konstantin ( @suslovk ) Matt McCormick ( @m-mccormick ) Mayuki Sawatari ( @mayuki ) Wojciech Nagórski ( @WojciechNagorski ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: April 6, 2020 Milestone: v0.12.1 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.1 BenchmarkDotNet v0.12.0 It's been several months since our last release, but we have been working hard and have some new features for you! Highlights Features and major improvements Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48) , [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48) , Job.Default.With(CoreRuntime.Core31) jobs in a manual config. You can find more details below. #1188 , #1186 , #1236 Official templates for BenchmarkDotNet-based projects With the help of the BenchmarkDotNet.Templates NuGet package, you can easily create new projects from the command line via dotnet new benchmark . This command has a lot of useful options, so you can customize your new project as you want. #1044 New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. #457 , #1131 , #1208 , #1214 , #1218 , #1219 New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items (the number of work items that have been processed in ThreadPool per single operation) and Lock Contentions (the number of times there was contention upon trying to take a Monitor's lock per single operation). Internally, it uses new APIs exposed in .NET Core 3.0. #1154 , #1227 Improved MemoryDiagnoser Now MemoryDiagnoser includes memory allocated by all threads that were live during benchmark execution: a new GC API was exposed in .NET Core 3.0 preview6+. It allows to get the number of allocated bytes for all threads. #1155 , #1153 , #723 LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported! #1241 , #1245 Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! #1148 , #1158 Minor summary and exporter improvements Improved presentation of the current architecture in the environment information In the previous version of BenchmarkDotNet, the reports always contained \"64bit\" or \"32bit\" which did not tell if it was ARM or not. Now it prints the full architecture name ( x64 , x86 , ARM , or ARM64 ). For example, instead of .NET Framework 4.8 (4.8.3815.0), 64bit RyuJIT you will get .NET Framework 4.8 (4.8.3815.0), X64 RyuJIT or .NET Framework 4.8 (4.8.3815.0), ARM64 RyuJIT . #1213 Simplified reports for Full .NET Framework version Previous version: .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 . Current version: .NET Framework 4.7.2 (4.7.3362.0), 64bit RyuJIT . #1114 , #1111 More reliable CPU info on Windows We added a workaround to for a bug in wmic that uses \\r\\r\\n as a line separator. #1144 , #1145 Better naming for generated plots When [RPlotExporter] is used, BenchmarkDotNet generates a lot of useful plots in the BenchmarkDotNet.Artifacts folder. The naming of the plot files was improved: benchmarks without Params doesn't include a double dash ( -- ) in their names anymore. 1183 , 1212 Better density plot precision The previous version of BenchmarkDotNet used the rule-of-thumb bandwidth selector in RPlotExporter density plots. It was fine for unimodal distributions, but sometimes it produced misleading plots for multimodal distributions. Now, RPlotExporter uses the Sheather&Jones bandwidth selector that significantly improves the presentation of the density plots for complex distributions. 58fde64 Better alignment in HtmlExporter Now BenchmarkDotNet aligns the content exported by HtmlExporter to the right. #1189 dfa074 Better precision calculation in SummaryTable 4e9eb43 Better summary analysis BenchmarkDotNet warns the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed. #1161 , #600 Make log file datetime format 24-hour #1149 Improve AskUser prompt message The error messages will surround * by quotes on Linux and macOS. #1147 Minor API improvements ED-PELT algorithm for changepoint detection is now available You can find details in this blog post . f89091 Improved OutlierMode API BenchmarkDotNet performs measurement postprocessing that may remove some of the outlier values (it can be useful to remove upper outliers that we get because of the natural CPU noise). In the previous version, naming for the OutlierMode values was pretty confusing: None/OnlyUpper/OnlyLower/All . Now, these values were renamed to DontRemove/RemoveUpper/RemoveLower/RemoveAll . For example, if you want to remove all the outliers, you can annotate your benchmark with the [Outliers(OutlierMode.RemoveAll)] attribute. The old names still exist (to make sure that the changes are backward compatible), but they are marked as obsolete, and they will be removed in the future versions of the library. #1199 , 0e4b8e Add the possibility to pass Config to BenchmarkSwitcher.RunAll and RunAllJoined #1194 , ae23bd Improved command line experience When user uses --packages $path , the $path will be sent to the dotnet build command as well. 1187 Extend the list of supported power plans. Now it supports \"ultimate\", \"balanced\", and \"power saver\" plans. #1132 , #1139 Make it possible to not enforce power plan on Windows. 1578c5c Guid support in benchmark arguments Now you can use Guid instances as benchmark arguments. 04ec20b Make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a single argument to mimic MemberData behaviour. ec296dc Make FullNameProvider public So it can be reused by the dotnet/performance repository. 6d71308 Extend Summary with LogFilePath #1135 , 6e6559 Allow namespace filtering for InliningDiagnoser #1106 , #1130 Option to configure MaxParameterColumnWidth #1269 , 4ec888 Other improvements Misc improvements in the documentation #1175 , #1173 , #1180 , #1203 , #1204 , #1206 , #1209 , #1219 , #1225 , #1279 Copy PreserveCompilationContext MSBuild setting from the project that defines benchmarks #1152 , 063d1a Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler #1179 , a106b1 Consume CoreRT from the new NuGet feed Because CoreRT no longer publishes to MyGet. #1129 Breaking changes: The [ClrJob] , [CoreJob] and [CoreRtJob] attributes got obsoleted and replaced by a [SimpleJob] which requires the user to provide target framework moniker in an explicit way. (See the \"Advanced multiple target frameworks support\" section for details.) #1188 , #1182 , #1115 , #1056 , #993 , The old InProcessToolchain is now obsolete. It's recommended to use InProcessEmitToolchain . If you want to use the old one on purpose, you have to use InProcessNoEmitToolchain . #1123 Bug fixes: Invalid arg passing in StreamLogger constructor. The append arg was not passed to the StreamWriter .ctor. #1185 Improve the output path of .etl files produced by EtwProfiler . EtwProfiler was throwing NRE for users who were using [ClrJob] and [CoreJob] attributes. #1156 , #1072 Flush custom loggers at the end of benchmark session. #1134 Make ids for tag columns unique - when using multiple TagColumns only one TagColumn was printed in the results. #1146 Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48) , [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48) , Job.Default.With(CoreRuntime.Core31) jobs in a manual config. Now let's discuss how to use it in detail. If you want to test multiple frameworks, your project file MUST target all of them and you MUST install the corresponding SDKs : <TargetFrameworks>netcoreapp3.0;netcoreapp2.1;net48</TargetFrameworks> If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks using the same framework as the host process (it corresponds to RuntimeMoniker.HostProcess ): dotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1 dotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0 dotnet run -c Release -f net48 # is going to run the benchmarks using .NET 4.8 mono $pathToExe # is going to run the benchmarks using Mono from your PATH To run the benchmarks for multiple runtimes with a single command from the command line, you need to specify the runtime moniker names via --runtimes|-r console argument: dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0 dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48 # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8 What is going to happen if you provide multiple Full .NET Framework monikers? Let's say: dotnet run -c Release -f net461 net472 net48 Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on the target version they were compiled for. You can read more about this here and here . This is .NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool . Note: Console arguments support works only if you pass the args to BenchmarkSwitcher : class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args); // crucial to make it work } You can achieve the same thing using [SimpleJobAttribute] : using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(RuntimeMoniker.Net48)] [SimpleJob(RuntimeMoniker.Mono)] [SimpleJob(RuntimeMoniker.NetCoreApp21)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] public class TheClassWithBenchmarks Or using a custom config: using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { class Program { static void Main(string[] args) { var config = DefaultConfig.Instance .With(Job.Default.With(CoreRuntime.Core21)) .With(Job.Default.With(CoreRuntime.Core30)) .With(Job.Default.With(ClrRuntime.Net48)) .With(Job.Default.With(MonoRuntime.Default)); BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); } } } The recommended way of running the benchmarks for multiple runtimes is to use the --runtimes console line argument. By using the console line argument, you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark, other people can run it even if they don't have the exact same framework version installed. Official templates for BenchmarkDotNet-based projects Since v0.12.0, BenchmarkDotNet provides project templates to setup your benchmarks easily. The template exists for each major .NET language ( C# , F# and VB ) with equivalent features and structure. The templates require the .NET Core SDK . Once installed, run the following command to install the templates: dotnet new -i BenchmarkDotNet.Templates If you want to uninstall all BenchmarkDotNet templates: dotnet new -u BenchmarkDotNet.Templates The template is a NuGet package distributed over nuget.org: BenchmarkDotNet.Templates . To create a new C# benchmark library project from the template, run: dotnet new benchmark If you'd like to create F# or VB project, you can specify project language with -lang option: dotnet new benchmark -lang F# dotnet new benchmark -lang VB The template projects have five additional options - all of them are optional. By default, a class library project targeting netstandard2.0 is created. You can specify -f or --frameworks to change target to one or more frameworks: dotnet new benchmark -f netstandard2.0;net472 The option --console-app creates a console app project targeting netcoreapp3.0 with an entry point: dotnet new benchmark --console-app This lets you run the benchmarks from a console ( dotnet run ) or from your favorite IDE. The option -f or --frameworks will be ignored when --console-app is set. The option -b or --benchmarkName sets the name of the benchmark class: dotnet new benchmark -b Md5VsSha256 BenchmarkDotNet lets you create a dedicated configuration class (see Configs ) to customize the execution of your benchmarks. To create a benchmark project with a configuration class, use the option -c or --config : dotnet new benchmark -c The option --no-restore if specified, skips the automatic NuGet restore after the project is created: dotnet new benchmark --no-restore Use the -h or --help option to display all possible arguments with a description and the default values: dotnet new benchmark --help The version of the template NuGet package is synced with the BenchmarkDotNet package. For instance, the template version 0.12.0 is referencing BenchmarkDotnet 0.12.0 - there is no floating version behavior. For more info about the dotnet new CLI, please read the documentation . New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. Consider the following benchmark: [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } It will produce the summary table like this one: Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B As you can see, we have two additional columns Allocated native memory and Native memory leak that contain some very useful numbers! New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items : The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions : The number of times there was contention upon trying to take a Monitor's lock (per single operation) Internally, it uses new APIs exposed in .NET Core 3.0. It can be activated with the help of the [ThreadingDiagnoser] attribute: [ThreadingDiagnoser] public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } The above example will print a summary table like this one: Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported: Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! That's how it looks: Milestone details In the v0.12.0 scope, 44 issues were resolved and 56 pull requests were merged. This release includes 110 commits by 24 contributors. Resolved issues (44) #198 [Feature request] No logger for benchmark run? (assignee: @CodeTherapist ) #311 How to debug benchmarks that fail with exception on file system access operations (assignee: @adamsitnik ) #457 Track Native Memory Allocations and more informations with our ETW Memory Diagnoser #600 Scaling issue #723 MemoryDiagnoser should include memory allocated by all Threads that were live during benchmark execution (assignee: @adamsitnik ) #995 Running benchmark fails when targeting netcoreapp2.2 (assignee: @adamsitnik ) #1028 Add new template for \"dotnet new benchmark\" (assignee: @CodeTherapist ) #1072 EtwProfiler exports trace file only for a single runtime when Runtimes are controlled via attributes (assignee: @adamsitnik ) #1106 Allow user defined namespace filter for InliningDiagnoser #1111 Change the format of printed Full .NET Framework Version (assignee: @adamsitnik ) #1115 Running using dotnet benchmark uses wrong core runtime #1132 The power management feature extension #1134 StreamLogger is not properly flushed on shutdown (assignee: @AndreyAkinshin ) #1135 The default file logger and summary title are out of sync (assignee: @adamsitnik ) #1137 [Discussion] Improve search experience in the documentation #1144 Incorrect CPU info for .NET Core applications #1146 Only the first of multiple custom columns is included in the summary table (assignee: @AndreyAkinshin ) #1147 Update benchmark switcher instructions to work on Linux (assignee: @AndreyAkinshin ) #1149 Ambiguous hour component in log file name timestamp (assignee: @AndreyAkinshin ) #1152 Failed to test Roslyn. (assignee: @adamsitnik ) #1153 Use GC.GetTotalAllocatedBytes when available in MemoryDiagnoser (assignee: @adamsitnik ) #1154 Add a ConcurrencyDiagnoser? (assignee: @adamsitnik ) #1156 Crash when BenchmarkDotNet.Diagnostics.Windows.Session.GetFilePath throws NRE (assignee: @adamsitnik ) #1158 🔍 Improving search on docs with Algolia's DocSearch #1162 Incorrect value of BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.Default #1168 Consider using default value instead of hardcoded '-' in MetricColumn.GetValue() #1179 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler (assignee: @adamsitnik ) #1181 Log shows a wrong name for plot images #1182 Benchingmarking .NET 4.8 Causes Errors #1183 Plots of benchmarks without params have a double dash (--) in the name #1186 Add support for --runtimes net48 (assignee: @adamsitnik ) #1187 When user uses --packages $path, the $path should be sent to dotnet build command as well (assignee: @adamsitnik ) #1194 RunAll with ToolChains (assignee: @adamsitnik ) #1195 LatestCoreRtVersionIsSupported fails on Mac Os #1202 BenchmarkDotNet Not Recognizing CPU #1220 [Docs] RScript / R_HOME setup #1235 NativeMemoryProfiler exception (assignee: @WojciechNagorski ) #1236 Rework new API for target runtimes (assignee: @adamsitnik ) #1241 Can BenchmarkDotNet be enabled for LINQPad 6? (assignee: @adamsitnik ) #1269 Unable to show full param string in the report (assignee: @adamsitnik ) #1280 Improvement in memory statistics (assignee: @WojciechNagorski ) #1285 Issue with .Net Core version 3.0 #1289 How to config to not save .log files? #1291 MemoryDiagnoser reports weird results for .NET Core 3.0 Merged pull requests (56) #1044 Add \"dotnet new\" benchmark project template (by @CodeTherapist ) #1114 simplify the reported Full .NET Framework version, fixes 1111 (by @adamsitnik ) #1123 + InProcessNoEmitToolchain (obsoletes the InProcessToolchain) (by @ig-sinicyn ) #1129 Consume CoreRT from the new NuGet feed (by @MichalStrehovsky ) #1130 allow namespace filtering for InliningDiagnoser (#1106) (by @MarekM25 ) #1131 NativeMemoryDiagnoser (by @WojciechNagorski ) #1139 Power-Management extension (#1132) (by @MarekM25 ) #1145 Added workaround to fix incorrect CPU info when using wmic (by @YohDeadfall ) #1148 Improve search experience in the documentation (by @s-pace ) #1155 Use new .NET Core 3.0 API to get the total number of allocated bytes for all threads (by @adamsitnik ) #1161 Warn the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed (by @mhmd-azeez ) #1163 Make netcoreapp2.1 default (by @adamsitnik ) #1169 Fix: broken link in readme.md (by @Ant-hem ) #1173 Updated index.md and fixed Relative performance url (by @sergey-litvinov ) #1175 Added information about what a Gen X column means (by @jigargandhi ) #1180 Update docstring for IterationSetup/IterationCleanup (by @billwert ) #1185 Invalid arg passing in StreamLogger constructor (by @ig-sinicyn ) #1188 Enforce the users to provide full target framework moniker when using attributes to define multiple runtime jobs (by @adamsitnik ) #1189 Update HtmlExporter.cs (by @chuuddo ) #1196 Update Mac Os for Travis CI (by @WojciechNagorski ) #1199 Rename OutlierMode values (by @AndreyAkinshin ) #1201 print benchmark process id to the output (better profiler user story) (by @adamsitnik ) #1203 Easier introduction of new benchmarks (by @Scooletz ) #1204 Fix casing typo (by @antondahlin ) #1206 add *.fsproj to the list of supported project types (by @JaggerJo ) #1208 Support of --profiler NativeMemory command line argument (by @WojciechNagorski ) #1209 Sorting examples list and adding missing pages (by @WojciechNagorski ) #1212 Plots with a double dash (--) in the names (#1183) (by @marcnet80 ) #1213 print full architecture name (by @adamsitnik ) #1214 Add documentation to NativeMemoryDiagnoser (by @WojciechNagorski ) #1217 Log shows a wrong name for plot images #1181 (by @marcnet80 ) #1218 NativeMemoryProfiler -add count of allocated object (by @WojciechNagorski ) #1219 Add links to blogs. (by @WojciechNagorski ) #1222 Enhance rscript location (by @tebeco ) #1225 Documentation: Fix some typos in the documentation (by @MSeifert04 ) #1227 Threading Diagnoser (by @adamsitnik ) #1228 Support IEnumerable as benchmark argument (by @adamsitnik ) #1230 further runtime detection improvements (by @adamsitnik ) #1231 Fix iteration cleanup bug (by @adamsitnik ) #1232 Fixed dots at the end (not used in other places) (by @cincuranet ) #1233 try to read .NET Core version from all available information (by @adamsitnik ) #1237 The null ArtifactsPath value causes exception for all EtwProfiler (by @WojciechNagorski ) #1239 Add using statement to sample snippet (by @b8adamson ) #1240 Amend SummaryStyle to support visualization of '0' in reports (by @sleemer ) #1245 LINQPad 6 support using InProcessEmitToolchain (by @adamsitnik ) #1252 Add possibility to disable the log file (by @CodeTherapist ) #1255 Update Build Tools to use .NET Core SDK to 3.0.100 (by @CodeTherapist ) #1257 Task remove unused nuget packages (by @WojciechNagorski ) #1259 Task remove trailing whitespace (by @WojciechNagorski ) #1260 Fix ca1825 rule - Avoid zero-length array allocations (by @WojciechNagorski ) #1261 Fix CA2000 - Add missing using (by @WojciechNagorski ) #1265 make it possible to configure MaxParamterColumnWidth (by @adamsitnik ) #1268 Fix compilation error with post v3.3.1 Roslyn (by @stanciuadrian ) #1277 change the runtimes API (by @adamsitnik ) #1279 Improve documentation for version 0.12.0 (by @WojciechNagorski ) #1281 Print GC and threading stats only if needed (by @WojciechNagorski ) Commits (110) 881c6d Postrelease update of v0.11.5 changelog (by @AndreyAkinshin ) a2bddf Fix release date for v0.11.5 in changelog (by @AndreyAkinshin ) c0c91a Consume CoreRT from the new NuGet feed (#1129) (by @MichalStrehovsky ) 40dcab allow namespace filtering for InliningDiagnoser (#1106) (#1130), fixes #1106 (by @MarekM25 ) 12fdbe + InProcessNoEmitToolchain (#1123) (by @ig-sinicyn ) 62d6af Bump docfx version to 2.42.1 (by @AndreyAkinshin ) 40901c Add sitemap generation in docfx.json (see #1137) (by @AndreyAkinshin ) 04ec20 add Guid support to code templates (by @adamsitnik ) 4e9eb4 Better precision calculation in SummaryTable (by @AndreyAkinshin ) df6f91 Added workaround to fix incorrect CPU info when using wmic (#1145) (by @YohDeadfall ) 9065c7 Make ids for tag columns unique, fixes #1146 (by @AndreyAkinshin ) 527c95 Improve AskUser prompt message, fixes #1147 (by @AndreyAkinshin ) 45253c Flush custom loggers at the end of benchmark session, fix #1134 (by @AndreyAkinshin ) 21175b Make log file datetime format 24-hour, fix #1149 (by @AndreyAkinshin ) 0dfa37 Power-Management extension (#1132) (#1139) (by @MarekM25 ) f54055 Use new .NET Core 3.0 API to get the total number of allocated bytes for all ... (by @adamsitnik ) aa17ec improve the output path of .etl files produced by EtwProfiler, fixes #1156, f... (by @adamsitnik ) ec296d make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a... (by @adamsitnik ) 96f162 write \"Setup power plan\" in a separate line (by @adamsitnik ) 063d1a copy PreserveCompilationContext MSBuild setting from the project that defines... (by @adamsitnik ) 1578c5 make it possible to not enforce power plan, move the revert to finally, simpl... (by @adamsitnik ) 0513a7 remove the test that requires a manual update every time we add a new charact... (by @adamsitnik ) 6e6559 extend Summary with LogFilePath, fixes #1135 (by @adamsitnik ) 6d7130 make FullNameProvider public so it can be reused by the dotnet/performance re... (by @adamsitnik ) 6f91ea Drop netcoreapp2.0 TFM in sample and test projects (see #1141) (by @AndreyAkinshin ) bfe676 Warn the user when benchmark baseline value is too close to zero and the colu... (by @mhmd-azeez ) 4282b1 Update year in LICENSE.md (by @AndreyAkinshin ) 29d01b Improve search experience in the documentation (#1148) (by Sylvain Pace) ddf1b8 Fixed: broken link in readme.md (by @Ant-hem ) fc35f7 simplify the reported Full .NET Framework version, fixes 1111 (#1114) (by @adamsitnik ) 0a4550 Updated index.md and fixed Relative performance (#1173) (by @sergey-litvinov ) a106b1 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers... (by @adamsitnik ) c022e7 Update docstring for IterationSetup/IteraitonCleanup (by @billwert ) 31cb34 Invalid arg passing in StreamLogger constructor (#1185) (by @ig-sinicyn ) fc8867 Make netcoreapp2.1 default (#1163) (by @adamsitnik ) 0f210c Add support for --runtimes net48, fixes #1186 (by @adamsitnik ) 48a9de When user uses --packages $path, the $path should be sent to dotnet build com... (by @adamsitnik ) dfa074 Update HtmlExporter.cs (#1189) (by @chuuddo ) 8b018d doc update: InProc toolchain supports Arguments now, we use Median instead of... (by @adamsitnik ) ae23bd add the possibility to pass config to BenchmarkSwitcher.RunAll and RunAllJoin... (by @adamsitnik ) 94b788 Update Mac Os for Travis CI (#1196), fixes #1195 (by @WojciechNagorski ) 58fde6 Use Sheather&Jones bandwidth selector for density plots in RPlotExporter (by @AndreyAkinshin ) 0e4b8e Rename OutlierMode values (#1199) (by @AndreyAkinshin ) 863c65 Added information about what a Gen X column means (#1175) (by @jigargandhi ) 70c5b3 print benchmark process id to the output (better profiler user story) (#1201) (by @adamsitnik ) 55cba0 Easier introduction of new benchmarks (#1203) (by @Scooletz ) 31bb6f Fix casing typo (#1204) (by @antondahlin ) e92abf NativeMemoryDiagnoser (#1131), fixes #457 (by @WojciechNagorski ) d04a01 update list of supported project types (#1206) (by @JaggerJo ) 5db67b Sorting examples list and add missing pagges (#1209) (by @WojciechNagorski ) 6620cd print full architecture name (#1213) (by @adamsitnik ) 705bc3 Add documentation to NativeMemoryDiagnouser (#1214) (by @WojciechNagorski ) 9caa05 Support of --profiler NativeMemory command line argument (#1208) (by @WojciechNagorski ) 5d7c78 Plots with a double dash (--) in the names (#1183) (#1212) (by @marcnet80 ) d0d883 Extend NativeMemoryProfiler with the number of allocated objects (#1218) (by @WojciechNagorski ) 09aba3 Add links to blogs. (#1219) (by @WojciechNagorski ) a200af Enforce the users to provide full target framework moniker when using attribu... (by @adamsitnik ) f8ef67 add release notes for 0.11.6 (by @adamsitnik ) 88ea5a Documentation: Fix some typos in the documentation (#1225) (by @MSeifert04 ) ea0468 Support IEnumerable as benchmark argument (#1228) (by @adamsitnik ) 4080ab Threading Diagnoser (#1227) (by @adamsitnik ) b6d0e0 further runtime detection improvements (#1230), (by @adamsitnik ) bc9624 Fix iteration cleanup bug (#1231) (by @adamsitnik ) cfccac Fixed dots at the end (not used in other places) (#1232) (by @cincuranet ) 61feb7 try to read .NET Core version from all available information (#1233) (by @adamsitnik ) c06ab7 Add using statement to sample snippet (#1239) (by @b8adamson ) af9608 The null ArtifactsPath value causes exception for all EtwProfiler (#1237) (by @WojciechNagorski ) 5f337d chore(tests): extract helper methods to MockFactory (by @sleemer ) 03e9ce feat(CsvExproter): print '0' instead of '-' in the CSV report (by @sleemer ) 06f0e7 Improuve link visibility for R installation (by @tebeco ) a2d9e3 adding example of R_HOME value in the doc to understand it construction (by @tebeco ) ce5ac8 Enhanced RScript detection, with a Fallback to the PATH if R_HOME points to a... (by @tebeco ) b86845 not necessary to set rscriptPath to null since it's re-affected right after (by @tebeco ) ee97ca Change access modifier to private, was not intended to be public (by @tebeco ) 609eec Log shows a wrong name for plot images #1181 (by @marcnet80 ) 76096e Add \"dotnet new\" benchmark project template (#1044) (by @CodeTherapist ) b7cbdf Update year in license (docs) (by @AndreyAkinshin ) 29919d Remove extra spaces in template *proj files (by @AndreyAkinshin ) 80ccfd Add some readonly modifiers (by @AndreyAkinshin ) d6a697 Improve MannWhitneyTest precision for small samples (by @AndreyAkinshin ) 9ba645 Fix CurrentRuntimeIsProperlyRecognized for NETFRAMEWORK case on Linux/macOS (by @AndreyAkinshin ) 24fda9 LINQPad 6 support using InProcessEmitToolchain (#1245) (by @adamsitnik ) e01e0d Fix typos in attribute messages (by @AndreyAkinshin ) 56a71f Add possibility to disable the log file (#1252) (by @CodeTherapist ) 3c4ec9 remove unused nuget packages (#1257) (by @WojciechNagorski ) 61cc56 Add missing using (#1261) (by @WojciechNagorski ) cd88ed Fix ca1825 rule - Avoid zero-length array allocations (#1260) (by @WojciechNagorski ) 2ba303 Task remove trailing whitespace (#1259) (by @WojciechNagorski ) e1c4aa Fix compilation error with post v3.3.1 Roslyn (#1268) (by @stanciuadrian ) 4ec888 make it possible to configure MaxParamterColumnWidth (#1265), fixes #1269 (by @adamsitnik ) 51f53a CombinedDisassemblyExporter output should be aligned to left, not right (by @adamsitnik ) f89091 Add EdPeltChangePointDetector (by @AndreyAkinshin ) da63e8 change the runtimes API (#1277) (by @adamsitnik ) 5333d5 Change next version number from 0.11.6 to 0.12.0 (by @AndreyAkinshin ) 52cc45 NativeMemoryProfiler instead of NativeMemoryDiagnoser (#1279) (by @WojciechNagorski ) f86e13 Print GC and threading stats if needed (#1281) (by @WojciechNagorski ) a08062 Rename some obsolete TargetFrameworkMoniker names to RuntimeMoniker (by @AndreyAkinshin ) 7fdee8 Fix JitOptimizationsValidatorIsMandatoryByDefault in DEBUG mode (by @AndreyAkinshin ) f2639e Move ImmutableConfigTests from IntegrationTests to regular unit tests (by @AndreyAkinshin ) 4f6a6b Fix diagnoser tests in ImmutableConfigTests (by @AndreyAkinshin ) 0768b7 Fix some typos in identifiers (by @AndreyAkinshin ) 28bb7c Bump DocFX version from 2.42.1 to 2.46 (by @AndreyAkinshin ) af9ff5 Fix mistakes in old changelogs (by @AndreyAkinshin ) c5aa4f Prepare v0.12.0 changelog (by @AndreyAkinshin ) cb1575 Add BenchmarkDotNet.Templates in build-and-pack.cmd (by @AndreyAkinshin ) bc7cb8 Improve v0.12.0 release notes (by @AndreyAkinshin ) c5ac2f Fix bug in BaselineCustomAnalyzer (by @AndreyAkinshin ) d75b1b Add .NET Core 2.2 and .NET Core 3.0 support in BenchmarkDotNet.Tool (by @AndreyAkinshin ) d582b5 Revert previous commit because of the CI Error (by @AndreyAkinshin ) 7bdf6e Set library version: 0.12.0 (by @AndreyAkinshin ) Contributors (24) Adam Sitnik ( @adamsitnik ) Adrian Stanciu ( @stanciuadrian ) Andrey Akinshin ( @AndreyAkinshin ) Antoine Hémery ( @Ant-hem ) Anton Dahlin ( @antondahlin ) b8adamson ( @b8adamson ) Bill Wert ( @billwert ) Code Therapist ( @CodeTherapist ) ig-sinicyn ( @ig-sinicyn ) Ilya Chudin ( @chuuddo ) Jigar ( @jigargandhi ) Jiri Cincura ↹ ( @cincuranet ) Josua Jäger ( @JaggerJo ) marcnet80 ( @marcnet80 ) Marek Moraczyński ( @MarekM25 ) Michael Seifert ( @MSeifert04 ) Michal Strehovský ( @MichalStrehovsky ) Muhammad Azeez ( @mhmd-azeez ) Sergey Litvinov ( @sergey-litvinov ) Szymon Kulec ( @Scooletz ) TeBeCo ( @tebeco ) Vlad Kovalev ( @sleemer ) Wojciech Nagórski ( @WojciechNagorski ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: October 24, 2019 Milestone: v0.12.0 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.0 BenchmarkDotNet v0.11.5 Highlights Features and noticeable improvements Power plan management Now BenchmarkDotNet executes all benchmarks with enabled High-Performance power plan (configurable, Windows-only). You can find some details below. #68 #952 Better Environment Variables API Now we have some additional extension methods which allow defining environment variables in user jobs. In the previous version, users always had to set an array of environment variables like this: job.With(new[] { new EnvironmentVariable(\"a\", \"b\") }) . Now it's possible to define an environment variable like job.With(new EnvironmentVariable(\"a\", \"b\")) or job.WithEnvironmentVariable(\"a\", \"b\") . Also, it's possible to clear the list of environment variables via job.WithoutEnvironmentVariables() . #1069 #1080 Better outlier messages The previous version of BenchmarkDotNet printed information about detected or removed outliers like this: \"3 outliers were detected\". It was nice, but it didn't provide additional information about these outliers (users had to read the full log to find the outliers values). Now BenchmarkDotNet prints additional information about outlier values like this: \"3 outliers were detected (2.50 us..2.70 us)\". e983cd31 Support modern CPU architecture names In the environment information section, BenchmarkDotNet prints not only the processor brand string, but also its architecture (e.g., \"Intel Core i7-4770K CPU 3.50GHz (Haswell)\"). However, it failed to recognize some recent processors. Now it's able to detect the architecture for modern Intel processors correctly (Kaby Lake, Kaby Lake R, Kaby Lake G, Amber Lake Y, Coffee Lake, Cannon Lake, Whiskey Lake). 995e053d Introduce BenchmarkDotNet.Annotations Currently, BenchmarkDotNet targets .NET Standard 2.0. It makes some users unhappy because they want to define benchmarks in projects with lower target framework. We decided to start working on the BenchmarkDotNet.Annotations NuGet package which targets .NET Standard 1.0 and contains classes that users need to define their benchmarks. However, it's not easy to refactor the full source code base and move all relevant public APIs to this package. In v0.11.5, we did the first step and moved some of these APIs to BenchmarkDotNet.Annotations . We want to continue moving classes to this package and get full-featured annotation package in the future. #1084 #1096 Use InProcessEmitToolchain by default in InProcess benchmarks In BenchmarkDotNet 0.11.4, we introduced InProcessEmitToolchain . It's a new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments] , [ArgumentsSource] , passing the arguments by out , ref and returning stack-only types like Span<T> . However, in v0.11.4, it can be activated only if InProcessEmitToolchain is declared explicitly. Now it's enabled by default when [InProcessAttribute] is used. #1093 Introduce an option which prevents overwriting results Currently, BenchmarkDotNet overwrites results each time when the benchmarks are executed. It allows avoiding tons of obsolete files in the BenchmarkDotNet.Artifacts folder. However, the behavior doesn't fit all use cases: sometimes users want to keep results for old benchmark runs. Now we have a special option for it. The option can be activated via --noOverwrite console line argument or DontOverwriteResults extension method for IConfig #1074 #1083 Other improvements and bug fixes Diagnostics and validation Better benchmark declaration error processing In the previous version, BenchmarkDotNet threw an exception when some benchmark methods had an invalid declaration (e.g., invalid signature or invalid access modifiers). Now it prints a nice error message without ugly stack traces. #1107 Better error message for users who want to debug benchmarks #1073 Don't show the same validation error multiple times Now each error will be printed only once. #1079 Restrict MemoryDiagnoserAttribute usage to class Now it's impossible to accidentally mark a method with this attribute. #1119 #1122 Export Better indentation in disassembly listings Now DissassemblyDiagnoser correctly process source code which contains tab as the indentation symbol #1110 Fix incorrect indentation for StackOverflow exporter Previously, StackOverflow exporter doesn't have a proper indent for job runtimes in the environment information. Now it's fixed. #826 #1104 Fix StackOverflowException in XmlExporter.Full #1086 #1090 Shortify MemoryDiagnoser column titles Now we use the following column titles: \"Allocated\" instead of \"Allocated Memory/Op\", \"Gen 0\" instead of \"Gen 0/1k Op\". The full description of each column can be found in the legend section below the summary table. #1081 Benchmark generation and execution Fixed broken Orderers The previous version has a nasty bug with custom orderers. Now it's fixed. #1070 #1109 Better overhead evaluation In the previous version, BenchmarkDotNet evaluated the benchmark overhead as a mean value of all overhead iteration. It was fine in most cases, but in some cases, the mean value can be spoiled by outliers. Now BenchmarkDotNet uses the median value. #1116 Respect CopyLocalLockFileAssemblies Now BenchmarkDotNet respect the CopyLocalLockFileAssemblies value and copies it to the generated benchmark project. #1068 #1108 Disable CodeAnalysisRuleSet for generated benchmarks Previously, generated benchmarks may fail if the CodeAnalysisRuleSet is defined in Directory.Build.Props . #1082 Supported undefined enum values #1020 #1071 Other minor improvements and bug fixes Power plans In #952 , power plan management was implemented. It resolves a pretty old issue #68 which was created more than three years ago. Now BenchmarkDotNet forces OS to execute a benchmark on the High-Performance power plan. You can disable this feature by modifying PowerPlanMode property. Here is an example where we are playing with this value: [Config(typeof(Config))] public class IntroPowerPlan { private class Config : ManualConfig { public Config() { Add(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance)); Add(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan)); } } [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) j = i; return j; } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } And here is an example of the summary table on plugged-off laptop: Method | PowerPlan | Mean | Error | StdDev | -------------- |---------------- |---------:|----------:|----------:| IterationTest | HighPerformance | 40.80 us | 0.4168 us | 0.6109 us | SplitJoin | HighPerformance | 13.24 us | 0.2514 us | 0.3763 us | IterationTest | UserPowerPlan | 79.72 us | 2.5623 us | 3.8352 us | SplitJoin | UserPowerPlan | 24.54 us | 2.1062 us | 3.1525 us | As you can see, the power plan produces a noticeable effect on the benchmark results. This feature is available on Windows only. Milestone details In the v0.11.5 scope, 16 issues were resolved and 16 pull requests were merged. This release includes 44 commits by 12 contributors. Resolved issues (16) #68 Power management #826 MarkdownExporter.StackOverflow fails to indent jobs' runtime descriptions (assignee: @alinasmirnova ) #976 System.NotSupportedException: Line must start with GC (assignee: @adamsitnik ) #1020 Errors using undefined enum values as benchmark arguments (assignee: @adamsitnik ) #1068 The csproj setting CopyLocalLockFileAssemblies is ignored #1070 System.InvalidOperationException: Sequence contains more than one matching element after 0.11.4 (assignee: @AndreyAkinshin ) #1071 Enum flags results into compiler errors (assignee: @adamsitnik ) #1073 The error message for users who want to Debug benchmarks is not clear (assignee: @adamsitnik ) #1074 Results should be exported to a file with unique name #1079 Dont display the same Validation Error many times (assignee: @adamsitnik ) #1086 XmlExporter.Full fails with StackOverflowException #1107 Unhandled Exception: System.InvalidOperationException: Benchmark method '' has incorrect signature. Method shouldn't have any arguments. (assignee: @AndreyAkinshin ) #1109 Issue with DefaultOrderer #1110 DisassemblyDiagnoser assumes indentation uses spaces (assignee: @AndreyAkinshin ) #1116 Use Median instead of Mean whe deducing Overhead (assignee: @AndreyAkinshin ) #1119 MemoryDiagnoserAttribute on methods (assignee: @Rizzen ) Merged pull requests (16) #952 Implemented power-management, add docs (#68) (by @MarekM25 ) #1080 Improved Environment Variables API, resolves #1069 (by @AndreyAkinshin ) #1081 Shortify MemoryDiagnoser column titles (by @AndreyAkinshin ) #1082 Make it so that the code analysis settings are disabled. (by @glennawatson ) #1083 make it possible to Don't Overwrite Results, fixes #1074 (by @adamsitnik ) #1084 introduce BenchmarkDotNet.Annotations (by @adamsitnik ) #1088 Typo (by @Stromberg90 ) #1090 XmlExporter.Full fails (by @daveMueller ) #1093 make InProcessEmitToolchain the default one (by @adamsitnik ) #1096 move more simple Attributes to BenchmarkDotNet.Annotations (by @adamsitnik ) #1104 fix #826 (by @alinasmirnova ) #1105 Just spell check (by @sungam3r ) #1108 Fix #1068 - Copy value of CopyLocalLockFileAssemblies (by @WojciechNagorski ) #1112 Fixed event wire-up before Session acquisition (by @jzabroski ) #1122 Restrict MemoryDiagnoserAttribute usage to class (by @Rizzen ) #1126 Styling in docfx fashion (by @robertmuehsig ) Commits (44) 0a63e4 Postrelease update of v0.11.4 changelog (by @AndreyAkinshin ) f94616 Fix namespace for JobTests (by @AndreyAkinshin ) 995e05 Support modern CPUs in ProcessorBrandStringHelper (by @AndreyAkinshin ) f946ba Repair custom orderers, fixes #1070 (by @AndreyAkinshin ) 1d3783 allow passing Enum Flags and undefined enum values as benchmarks arguments/pa... (by @adamsitnik ) dfe9ca make sure that we can pass undefined enum values and the bug never comes back... (by @adamsitnik ) 76b467 improve the error message when users try to run the benchmarks in Debug, fixe... (by @adamsitnik ) 98d9f8 Dont display the same Validation Error many times, fixes #1079 (by @adamsitnik ) 03981c fix the unit test that I broke when I was fixing #1071 (by @adamsitnik ) 877aba Throw exception about private benchmark method (by @AndreyAkinshin ) e983cd Print some outlier values in OutliersAnalyser (by @AndreyAkinshin ) b5d324 Shortify MemoryDiagnoser column titles (#1081) (by @AndreyAkinshin ) c5c4c4 handle undefined negative enum values, #1020 (thanks @TylerBrinkley) (by @adamsitnik ) 2f273c Improved Environment Variables API, resolves #1069 (#1080) (by @AndreyAkinshin ) ff2847 Implement FrequencyTests.ParseTest (by @AndreyAkinshin ) 5e25da Make it so that the code analysis settings are disabled for compiled builds (... (by @glennawatson ) db701e make it possible to Don't Overwrite Results, fixes #1074 (#1083) (by @adamsitnik ) a12d8c introduce BenchmarkDotNet.Annotations (#1084) (by @adamsitnik ) dcc40a Typo (#1088) (by @Stromberg90 ) 2c392a XmlExporter.Full fails #1090 (by @daveMueller ) 8968bb make InProcessEmitToolchain the default one (#1093) (by @adamsitnik ) 4c9136 move more simple Attributes to BenchmarkDotNet.Annotations (#1096) (by @adamsitnik ) 6f524f Added extra output lines for jobs in test (by @alinasmirnova ) 27ed8a Logger with prefix works correctly with multiline input (by @alinasmirnova ) a846b8 just spell check (#1105) (by @sungam3r ) a2da9a Reverted reporter change (by @alinasmirnova ) e1c9b9 Merge pull request #1104 from alinasmirnova/master (by @AndreyAkinshin ) e45adc Fix #1068 - Copy value of CopyLocalLockFileAssemblies (#1108) (by @WojciechNagorski ) 2f823c don't fail with exception if user has written something to output in GlobalCl... (by @adamsitnik ) 8bc2cc Fixed event wire-up before Session acquisition (#1112) (by @jzabroski ) db3a8f Better handling of benchmark with incorrect signature, fixes #1107 (by @AndreyAkinshin ) 8a8e01 Fix GlobalSetupAttributeMethodsMustHaveNoParameters (by @AndreyAkinshin ) 52eca7 Better disasm indentation, fixes #1110 (by @AndreyAkinshin ) d9901b Use Median instead of Mean for overhead calculations, fixes #1116 (by @AndreyAkinshin ) 1c1913 add dotnet/performance to the list of users (by @adamsitnik ) e1d4d2 Restrict MemoryDiagnoserAttribute usage to class (#1122), fixes #1119 (by @Rizzen ) 8aa6ad Implemented power-management, add docs (#68) (#952) (by @MarekM25 ) 9c6cad Improve ApplyUserPowerPlan message (by @AndreyAkinshin ) d12414 Initial v0.11.5 changelog (by @AndreyAkinshin ) 1babcb styling in docfx fashion (by @robertmuehsig ) fb1286 Add netstandard2.0 target framework in BenchmarkDotNet.Annotations (by @AndreyAkinshin ) b7118e Add BenchmarkDotNet.Annotations in build-and-pack.cmd (by @AndreyAkinshin ) 8721a9 Prepare v0.11.5 changelog (by @AndreyAkinshin ) 31ea3d Set library version: 0.11.5 (by @AndreyAkinshin ) Contributors (12) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) David Müller ( @daveMueller ) Glenn ( @glennawatson ) Ivan Maximov ( @sungam3r ) John Zabroski ( @jzabroski ) Marek Moraczyński ( @MarekM25 ) Mark Tkachenko ( @Rizzen ) Robert Muehsig ( @robertmuehsig ) Strømberg ( @Stromberg90 ) Wojciech Nagórski ( @WojciechNagorski ) Thank you very much! Additional details Date: April 2, 2019 Milestone: v0.11.5 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.11.5 BenchmarkDotNet v0.11.4 It's been few months since our last release, but we have been working hard and have some new features for you! Highlights Features BenchmarkDotNet as a global tool : a new global tool which allows you to run benchmarks from given library. Now you can run benchmarks from the command line via dotnet benchmark . You can find more information about it in the documentation #1006 #213 InProcessEmitToolchain : new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments] , [ArgumentsSource] , passing the arguments by out , ref and returning stack-only types like Span<T> . #919 , #921 #843 ARM support : BenchmarkDotNet supports now ARM and ARM64. #780 , #979 #385 Mono AOT support : a new toolchain which allows running benchmarks using AOT version of Mono #940 NuGet symbol server support : BenchmarkDotNet publishes now the symbols to NuGet.org symbol server and you can easily debug it. #967 #968 Experimental support for .NET Core 3.0 WPF benchmarks #1066 For a working example please go to https://github.com/dotMorten/WPFBenchmarkTests Improvements: CoreRT Toolchain improvements - thanks to help from CoreRT Team we were able to make the CoreRT Toolchain work with the latest version of CoreRT #1001 , #1057 Display the number of benchmarks to run: we now display how many benchmarks are going to be executed before running them and how many remained after running each of them #1048 Better list of suggested benchmarks for wrong filter #834 #957 Invalid assembly binding redirects generated by VS were a pain to many of our users, we have now implemented an approach that tries to work around this issue. #895 , #667 , #896 , #942 Handling duplicates in IConfig #912 , #938 , #360 , #463 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts #1059 Give a warning when the [Benchmark] method is static - we now produce an error when users fail into this common issue #983 #985 C# keywords are prohibited as benchmark names #849 File names should be consistent across all OSes - < and > are valid on Unix, but not on Windows. We have unified that and now files produced on Unix and Windows have the same names. #981 Improve restore, build and publish projects #1002 , #1013 Make it possible to disable OptimizationsValidator #988 Sort enum parameters by value instead of name #977 Detect .NET Core benchmark failures from LINQPad #980 Improved error logging #1008 Improved disassembly diff #1022 Using invariant culture for Roslyn Toolchain error messages #1042 Use only full names in the auto-generated code to avoid any possible conflicts with user code #1007 , #1009 #1010 Write the GitHub table format to the console by default #1062 Proper cleanup on Ctrl+C/console Window exit #1061 Introduce StoppingCriteria - the first step to writing your own heuristic that determines when benchmarking should be stopped #984 Breaking changes: .NET Standard 2.0 only - BenchmarkDotNet has a single target now, which should help with some assembly resolving issues. We had to drop .NET 4.6 support because of that and .NET 4.6.1 is now the oldest supported .NET Framework. #1032 CustomCoreClrToolchain has been removed, it's recommended to use CoreRunToolchain instead #928 Bug fixes: NRE in Summary ctor #986 #987 ArgumentNullException when running benchmarks from published .NET Core app #1018 Dry jobs can eat iteration failures #1045 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure #1046 Running the example throws NullReference #1049 Fix race condition in process output reader #1051 #1053 Fix a rare but really annoying bug where for some reason we were sometimes setting ForegroundColor to the same color as BackgroundColor and some parts of the logged output were invisible commit StopOnFirstError must be respected commit Milestone details In the v0.11.4 scope, 42 issues were resolved and 41 pull requests were merged. This release includes 99 commits by 18 contributors. Resolved issues (42) #213 Add a \"benchmark\" cmd to dotnet #343 FileNotFoundException on mono (assignee: @AndreyAkinshin ) #360 Duplicates handling for IConfig (assignee: @adamsitnik ) #385 Consider using S.R.InteropServices.RuntimeInformation.ProcessArchitecture instead pointer based detection of platform (assignee: @adamsitnik ) #387 Add a mode to BenchmarkSwitcher that allows to run a method inline for profiling (assignee: @adamsitnik ) #463 Review interface IConfig (assignee: @adamsitnik ) #660 [Params] should not change the order of provided values #667 Does BenchMarkDotnet supports 4.7.1 Dotnet framework (assignee: @adamsitnik ) #687 Implement [Arguments] support for InProcessToolchain (assignee: @ig-sinicyn ) #714 Test BenchmarkDotNet against unstable/multimodal benchmarks from CoreCLR/CoreFX repo (assignee: @adamsitnik ) #780 ARM support (assignee: @adamsitnik ) #834 Better list of suggested benchmarks for wrong filter (assignee: @morgan-kn ) #843 Exception when returning a stackonly structure in a benchmark case using in-process toolchain (assignee: @ig-sinicyn ) #849 C# keywords are prohibited as benchmark names (assignee: @adamsitnik ) #895 Could not load file or assembly 'System.ValueTuple, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies (assignee: @adamsitnik ) #896 .NET 4.7.1 console app tries to use BenchmarkRunner, gets \"Could not load file or assembly 'System.Runtime, Version=4.1.2.0\" (assignee: @adamsitnik ) #919 Feature proposal: full-featured inprocess toolchain (assignee: @ig-sinicyn ) #928 Remove CustomCoreClrToolchain (assignee: @adamsitnik ) #938 Run benchmark with DisasemblyDiagnoser with --disasam option from console (assignee: @adamsitnik ) #942 System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime, Version=4.1.0.0' after adding BenchmarkDotNet.Diagnostics.Windows (assignee: @adamsitnik ) #967 Publish a snupkg to the NuGet.org symbol server (assignee: @WojciechNagorski ) #970 False alarm bug report #981 File names should be consistent across all OSes (assignee: @adamsitnik ) #982 Invalid string representaiton of CPU Affinity on a machine with more than 32 cores on ARM64 (assignee: @adamsitnik ) #983 Give a warning when the [Benchmark] method is static (assignee: @Rizzen ) #986 NRE in Summary ctor #988 Make it possible to disable OptimizationsValidator (assignee: @adamsitnik ) #998 Missing images in docs (assignee: @AndreyAkinshin ) #1002 Multiple build/publish failure with --coreRun toolchain (assignee: @WojciechNagorski ) #1007 benchmark cannot have type Action (assignee: @adamsitnik ) #1010 Write unit tests which check that BenchmarkProgram.txt doesn't contain usings (assignee: @adamsitnik ) #1018 ArgumentNullException when running benchmarks from published .NET Core app #1039 Some tests are broken on Net 461 (culture-dependent thing) (assignee: @ig-sinicyn ) #1045 Dry jobs can eat iteration failures (assignee: @adamsitnik ) #1046 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure (assignee: @adamsitnik ) #1048 Display the number of benchmarks to run (assignee: @adamsitnik ) #1049 Running the example throws NullReference (assignee: @adamsitnik ) #1051 Fix race condition in process output reader (assignee: @adamsitnik ) #1056 Fails to build when targeting .NET Core 3.0 and .NET Framework (assignee: @adamsitnik ) #1059 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts (assignee: @adamsitnik ) #1062 Write the GitHub table format to the console by default (assignee: @adamsitnik ) #1065 Allow benchmarking .NET Core Desktop apps (assignee: @adamsitnik ) Merged pull requests (41) #912 Duplicates handling for IConfig = big refactor, fixes #360 (by @adamsitnik ) #921 InProcessEmitToolchain (by @ig-sinicyn ) #940 Add support for mono AOT pass (by @alexanderkyte ) #957 Better list of suggested benchmarks for wrong filter #834 (by @morgan-kn ) #968 Support Nuget symbol server (by @WojciechNagorski ) #969 Disable batch mode and explicitly enable build trigger for master branch (by @Ky7m ) #977 sort enum parameters by value instead of name (by @kayle ) #979 ARM support (by @adamsitnik ) #980 Detect .NET Core benchmark failures from LINQPad (by @Turnerj ) #984 Introduce StoppingCriteria (by @AndreyAkinshin ) #985 Give a warning when the [Benchmark] method is static (by @Rizzen ) #987 Fix NRE in MetricColumn (#986) (by @qbit86 ) #991 Fix typos (by @0x6a62 ) #992 Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (by @glennawatson ) #996 Rephrase Notes section and fix markdown (by @Maximusya ) #997 Remove obsolete info from the docs (by @Maximusya ) #999 Synchronize benchmark output with the code in docs (by @Maximusya ) #1001 CoreRT toolchain update (by @adamsitnik ) #1006 BenchmarkDotNet as global tool (by @CodeTherapist ) #1008 Improve error logging to diagnose unstable tests (by @adamsitnik ) #1009 Use only full names in the auto-generated code to avoid any possible conflicts with user code (by @adamsitnik ) #1012 Changed TargetCount to IterationCount in docs (by @Sitiritis ) #1013 Improve restore, build and publish projects - Fix for #1002 (by @WojciechNagorski ) #1014 Update IntroRatioSD.md (by @fredeil ) #1022 Improve diff disassembly (by @WojciechNagorski ) #1032 Target .NET Standard 2.0 only (by @adamsitnik ) #1033 BenchmarkDotNet as global tool (#1006), fixes #213 (by @adamsitnik ) #1035 Improve global tool (by @WojciechNagorski ) #1036 Remove InternalsVisibleTo for Samples application (by @WojciechNagorski ) #1038 Change the name of the global tool (by @WojciechNagorski ) #1040 Making the new InProcessEmitToolchain work after my recent refactor and .NET Standard 2.0 port (by @adamsitnik ) #1041 InProcessEmitToolchain (by @adamsitnik ) #1042 Use invariant culture for csc messages (by @ig-sinicyn ) #1043 minor InProcess fix: diff now checks for implementation flags (by @ig-sinicyn ) #1052 dotnet cli version update + reducing the number of long running tests (by @adamsitnik ) #1053 read the process output in a thread safe way, fixes #1051 (by @adamsitnik ) #1054 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik ) #1055 Allow reflecting on DebuggableAttribute on CoreRT (by @MichalStrehovsky ) #1057 CoreRT toolchain improvements (by @adamsitnik ) #1061 Proper cleanup on Ctrl+C/console Window exit (by @adamsitnik ) #1066 Add experimental support for .NET Core 3.0 WPF benchmarks (by @adamsitnik ) Commits (99) 1fac9b Postrelease update of v0.11.3 changelog (by @AndreyAkinshin ) 40fae8 Support Nuget symbol server (#968) (by @WojciechNagorski ) 69b01f remove batch and explicitly enable build for master (#969) (by @Ky7m ) 01992c better error messages for lack of Cli and invalid CoreRun path (by @adamsitnik ) 767e02 sort enum parameters by value instead of name (#977), fixes #660 (by @kayle ) 128e11 Better list of suggested benchmarks for wrong filter #834 (#957) (by @morgan-kn ) c0910a Fix NRE in BaselineRatioColumn.GetRatioStatistics, fixes #970 (by @AndreyAkinshin ) 67b675 Fix TimeSpan calculations in DotNetCliCommand.AddPackages (by @AndreyAkinshin ) 847c27 Fix a few typos (by @AndreyAkinshin ) 6fb830 ARM support (#979) (by @adamsitnik ) 410d14 Detect .NET Core benchmark failures from LINQPad (#980), #975 (by @Turnerj ) 138325 File names should be consistent across all OSes, fixes #981 (by @adamsitnik ) add308 test fix for #981 (by @adamsitnik ) 77ed41 expose OriginalValues and SortedValues in the Statistics type so they get exp... (by @adamsitnik ) c0aac1 More tests for FolderNameHelper (by @AndreyAkinshin ) 3497ae Better message in MinIterationTimeAnalyser (by @AndreyAkinshin ) 91e16a Fix duplication of IsLinqPad check (by @AndreyAkinshin ) 89255c Refactoring xUnit tests to avoid non-serializable objects in MemberData (by @AndreyAkinshin ) 2cd06a Give a warning when the [Benchmark] method is static (#985) (by @Rizzen ) 5070af Fix NRE in MetricColumn (#986) (#987) (by @qbit86 ) 17378d Fix typos (#991) (by @0x6a62 ) 2ce35a Fix path to logo in README (by @AndreyAkinshin ) a20e4b always print the path, args and working dir of the auto-generated executable,... (by @adamsitnik ) 27dd87 CoreRunToolchain: when the file exists, overwrite it (by @adamsitnik ) 1b01f3 Remove obsolete info from the docs (#997) (by @Maximusya ) 299e1f Synchronized benchmark output with the code in docs (#999) (by @Maximusya ) 0da14b Rephrase Notes section and fix markdown (#996) (by @Maximusya ) 9e791f CoreRT toolchain update (#1001) (by @adamsitnik ) 04747a Use only full names in the auto-generated code to avoid any possible conflict... (by @adamsitnik ) f35465 add unit test that prevents from adding using statements to the code, fixes #... (by @adamsitnik ) fd0b8c Improve build error logging, increase the default timeout (by @adamsitnik ) 8276be Changed TargetCount to IterationCount in docs (#1012) (by @Sitiritis ) 3c98da Update IntroRatioSD.md (#1014) (by @fredeil ) 286996 Improve restore, build and publish projects - Fix for #1002 (#1013) (by @WojciechNagorski ) 923b23 BenchmarkDotNet as global tool (#1006), fixes #213 (by @CodeTherapist ) 7ef5f6 Introduce StoppingCriteria (#984) (by @AndreyAkinshin ) 5e4428 make SortedValues internal property, don't export it! (by @adamsitnik ) 5c519f Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (... (by @glennawatson ) 6ee21b if we fail to do the full build, we try with --no-dependencies (by @adamsitnik ) 8d9714 Support machines without .NET DevPack, fix #1018 (by @AndreyAkinshin ) 573566 Add support for mono AOT pass (#940) (by @alexanderkyte ) 011c79 + InProcessEmitToolchain (by @ig-sinicyn ) 862e6e InProcessEmitToolchain cleanup (by @ig-sinicyn ) 252d7a Fix StringCanBePassedToBenchmarkAsReadOnlySpan (by @ig-sinicyn ) 7ec2f3 Check if there's something wrong with RoslynToolchain on .Net Core (by @ig-sinicyn ) 57acd6 No NOPs (thanks to @Warpten!) (by @ig-sinicyn ) bf362a Diff now compares nops (by @ig-sinicyn ) aa9ff8 + emit correct IL (by @ig-sinicyn ) 351ca5 Ignore NOPs for ldarg too (by @ig-sinicyn ) fc530f Fix build after rebase (by @ig-sinicyn ) 1577ba MonoAotToolchain refactoring, post #940 (by @adamsitnik ) 6ccf45 Improve diff disassembly (#1022) (by @WojciechNagorski ) ef090d if we fail to do the full build, we try with --no-dependencies (for the publi... (by @adamsitnik ) c69934 Give a warning when the [Benchmark] method is static: handle some edge-cases,... (by @adamsitnik ) 935ead use .NET 4.6.1 everywhere, we don't support 4.6 anymore. Cleanup after #992 (by @adamsitnik ) 20a011 C# keywords are prohibited for benchmark names, print nice error message, fix... (by @adamsitnik ) 2aec75 remove CustomCoreClrToolchain, it was causing too much trouble. We can run th... (by @adamsitnik ) f10752 Duplicates handling for IConfig = big refactor, fixes #360, closes #464 and f... (by @adamsitnik ) f9c8cc Target .NET Standard 2.0 (#1032), apply a workaround for assembly binding red... (by @adamsitnik ) aa1ded Merge branch 'master' into tools (by @adamsitnik ) ccee3e Merge pull request #1033 from dotnet/tools (by @adamsitnik ) 1b9f9f almost no warnings ;) (by @adamsitnik ) 3bd18f introduce ConfigOptions - an enum flag which make it easier to introduce new ... (by @adamsitnik ) 66c264 reverting things that should not introduce problems but did... (by @adamsitnik ) 33eaeb Merge branch 'master' into feature-inprocessemit (by @adamsitnik ) a1df27 Merge pull request #921 from ig-sinicyn/feature-inprocessemit (by @adamsitnik ) aac7a6 Improve global tool (#1035) (by @WojciechNagorski ) c01bc5 Remove InternalsVisibleTo for Samples application (#1036) (by @WojciechNagorski ) f6dbe4 Change the name of the global tool (#1038) (by @WojciechNagorski ) 11d8cb Making the new InProcessEmitToolchain work after my recent refactor and .NET ... (by @adamsitnik ) e935b5 minor InProcess fix: diff now checks for implementation flags, (#1043) (by @ig-sinicyn ) da4128 Merge pull request #1041 from dotnet/newInProcess (by @adamsitnik ) 82170f if global cleanup throws, we should report the problem but don't rethrow beca... (by @adamsitnik ) 904ddd tests that ensure that when a benchmark throws the runner does not throw, fix... (by @adamsitnik ) cbdf7b Use invariant culture for csc messages (#1042) (by @ig-sinicyn ) 5215ee Display the number of benchmarks to run, fixes #1048 (by @adamsitnik ) 84cc3e dotnet cli version update + reducing the number of long running tests (#1052)... (by @adamsitnik ) 1c431a read the process output in a thread safe way, fixes #1051 (#1053) (by @adamsitnik ) 41a367 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik ) 20744e allow the user to choose the strategy from console line arguments (by @adamsitnik ) 190b9b Allow reflecting on DebuggableAttribute on CoreRT (#1055) (by @MichalStrehovsky ) 9dd9e7 Ctlr+C: we should kill the entire process tree, not only for the benchmarks b... (by @adamsitnik ) d4249f Disassembly diagnoser should be kept in a separate directory to avoid depende... (by @adamsitnik ) 0b83c9 CoreRT toolchain improvements (#1057) (by @adamsitnik ) 9bc8f3 0.11.4 initial release notes (by @adamsitnik ) 13bb97 if the user provide a custom value, we should use it, post #1057 (by @adamsitnik ) ea3036 fix a rare but really annoying bug where for some reason we were sometimes se... (by @adamsitnik ) cf3f8c Proper cleanup on Ctrl+C/console Window exit (#1061) (by @adamsitnik ) 61f563 Write the GitHub table format to the console by default, fixes #1062 (by @adamsitnik ) 87d281 StopOnFirstError must be respected (by @adamsitnik ) 413d31 Add experimental support for .NET Core 3.0 WPF benchmarks (#1066), fixes #1065 (by @adamsitnik ) 69a8aa copy UseWindowsForms too (thanks @onovotny for pointing this out), post #1066 (by @adamsitnik ) d3379e Bump DocFX version (by @AndreyAkinshin ) 423204 Remove Version ComboBox in docs (by @AndreyAkinshin ) 1a8826 Update build-and-pack.cmd (by @AndreyAkinshin ) 9068d6 Update copyrights in docs (by @AndreyAkinshin ) c0c2bf Update v0.11.4 changelog (by @AndreyAkinshin ) e26441 Highlight the first column separator in the console summary table (by @AndreyAkinshin ) a704a4 Set library version: 0.11.4 (by @AndreyAkinshin ) Contributors (18) Adam Sitnik ( @adamsitnik ) Alexander Kyte ( @alexanderkyte ) Andrey Akinshin ( @AndreyAkinshin ) Code Therapist ( @CodeTherapist ) Fredrik Eilertsen ( @fredeil ) Glenn ( @glennawatson ) ig-sinicyn ( @ig-sinicyn ) Igor Fesenko ( @Ky7m ) Irina Ananeva ( @morgan-kn ) James Turner ( @Turnerj ) Jeff B. ( @0x6a62 ) kayle ( @kayle ) Maksim Yakimets ( @Maximusya ) Mark Tkachenko ( @Rizzen ) Michal Strehovský ( @MichalStrehovsky ) Tymur Lysenko ( @Sitiritis ) Viktor Pti ( @qbit86 ) Wojciech Nagórski ( @WojciechNagorski ) Thank you very much! Additional details Date: February 15, 2019 Milestone: v0.11.4 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.4 BenchmarkDotNet v0.11.3 Highlights This release is focused mainly on bug fixes that were affecting user experience. But don't worry, we have some new features too! Diagnosers ConcurrencyVisualizerProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file which can be opened with Concurrency Visualizer) Command-line: --stopOnFirstError : Stops the benchmarks execution on first error. #947 --statisticalTest : Performs a Mann–Whitney Statistical Test for identifying regressions and improvements. #960 Bug fixes: Dry mode doesn't work because of the ZeroMeasurementHelper #943 MannWhitneyTest fails when comparing statistics of different sample size #948 and #950 Improve the dynamic loading of Diagnostics package #955 BenchmarkRunner.RunUrl throws NRE when Config is not provided #961 Don't require the users to do manual installation of TraceEvent when using Diagnostics package #962 Stop benchmark after closing application + Flush log after stopping benchmark #963 Diagnosers ConcurrencyVisualizerProfiler ConcurrencyVisualizerProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a CVTrace file which can be opened with Concurrency Visualizer . ConcurrencyVisualizerProfiler uses EtwProfiler to get a .etl file which still can be opened with PerfView or Windows Performance Analyzer . The difference is that it also enables all Task and Thread related ETW Providers and exports a simple xml which can be opened with Visual Studio if you install Concurrency Visualizer plugin #964 Concurrency Visualizer Profiler Diagnoser (by @adamsitnik ) dfb3c89 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik ) Command-line In this release, we have some new command-line arguments! --stopOnFirstError : Stops the benchmarks execution on first error When provided, BenchmarkDotNet is going to stop the benchmarks execution on first error. #947 Add option to stop running when the first benchmark fails (by @wojtpl2 ) --statisticalTest : Statistical Test To perform a Mann–Whitney U Test and display the results in a dedicated column you need to provide the Threshold via --statisticalTest . Examples: 5%, 10ms, 100ns, 1s. Example: run Mann–Whitney U test with relative ratio of 1% for all benchmarks for .NET 4.6 (base), .NET Core 2.0 and .NET Core 2.1. class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } public class MySample { [Benchmark] public void Sleep() { #if NETFRAMEWORK Thread.Sleep(50); #elif NETCOREAPP2_0 Thread.Sleep(45); #elif NETCOREAPP2_1 Thread.Sleep(55); #endif } [Benchmark] public void Same() => Thread.Sleep(50); } dotnet run -c Release -f netcoreapp2.1 --filter * --runtimes net46 netcoreapp2.0 netcoreapp2.1 --statisticalTest 1% Note: .NET 4.6 will be our baseline because it was provided as first on the runtimes list. Method Runtime Toolchain Mean Error StdDev Ratio MannWhitney(1%) Sleep Clr net46 50.51 ms 0.1833 ms 0.1714 ms 1.00 Base Sleep Core netcoreapp2.0 45.53 ms 0.1262 ms 0.1181 ms 0.90 Faster Sleep Core netcoreapp2.1 55.50 ms 0.1217 ms 0.1138 ms 1.10 Slower Same Clr net46 50.47 ms 0.1795 ms 0.1679 ms 1.00 Base Same Core netcoreapp2.0 50.55 ms 0.1873 ms 0.1752 ms 1.00 Same Same Core netcoreapp2.1 50.55 ms 0.2162 ms 0.2022 ms 1.00 Same Milestone details In the v0.11.3 scope, 10 issues were resolved and 10 pull requests were merged. This release includes 26 commits by 6 contributors. Resolved issues (10) #870 Error after adding OperationsPerInvoke (assignee: @AndreyAkinshin ) #885 Closing application dot't stop benchmark (assignee: @WojciechNagorski ) #933 Investigate hanging SingleBenchmarkCanBeExecutedForMultipleRuntimes test (assignee: @adamsitnik ) #939 We need an option to stop running when the first benchmark fails. (assignee: @WojciechNagorski ) #943 Dry mode doesn't work because of the ZeroMeasurementHelper (assignee: @AndreyAkinshin ) #948 BenchmarkDotNet.Mathematics.StatisticalTesting.MannWhitneyTest.PValueForSmallN(int n, int m, double u) (assignee: @AndreyAkinshin ) #950 MannWhitneyTest fails when comparing statistics of different sample size (assignee: @AndreyAkinshin ) #955 Improve the dynamic loading of Diagnostics package (assignee: @WojciechNagorski ) #961 BenchmarkRunner.RunUrl throws NRE when Config is not provided #964 Concurrency Visualizer Profiler (assignee: @adamsitnik ) Merged pull requests (10) #941 Fix example code (isBaseline -> baseline) (by @PathogenDavid ) #944 Fixed typo in IntroTagColumn sample (by @ahmedalejo ) #947 Add option to stop running when the first benchmark fails (by @WojciechNagorski ) #949 Add printDiff in DisassemblyDiagnoserAttribute (by @WojciechNagorski ) #951 Add failing test for #948 (by @WojciechNagorski ) #958 Use DependencyContext to load diagnostics assembly (by @WojciechNagorski ) #960 Expose StatisticalTestColumn via command line arguments (by @adamsitnik ) #962 Don't require the users to do manual installation of TraceEvent when using Diagnostics package (by @WojciechNagorski ) #963 Stop benchmark after closing application + Flush log after stopping benchmark. (by @WojciechNagorski ) #966 Fix typos in ConfigParser and CommandLineOptions (by @morgan-kn ) Commits (26) d85a7e Postrelease update of v0.11.2 changelog (by @AndreyAkinshin ) 8b2015 Fix ZeroMeasurementHelper for dry mode case, fixes #943 (by @AndreyAkinshin ) ab8543 Fix example code (#941) (by @PathogenDavid ) ec5fb2 Enable default analysers in BenchmarkTestExecutor (see #943) (by @AndreyAkinshin ) fb251d Remove [DryJob] from IntroBasic (by @AndreyAkinshin ) 1c1bdf Fix another problem in ZeroMeasurementAnalyser (see #943) (by @AndreyAkinshin ) 348f87 make sure we prevent from inlining the benchmarks also in the dummy method ge... (by @adamsitnik ) 80ecec when the parallel build fails, always try one more time in sequential way, ho... (by @adamsitnik ) 042291 set the metrics unit to \"Count\", they should not be empty /cc @jorive (by @adamsitnik ) 5b3657 Fixed typo in IntroTagColumn sample (#944) (by @ahmedalejo ) 60ea17 Add printDiff in DisassemblyDiagnoserAttribute (#949) (by @WojciechNagorski ) b6e8b1 Add failing test for #948 (#951) (by @WojciechNagorski ) 3e9f73 Fix IndexOutOfRangeException in MannWhitneyTest, fixes #948 (by @AndreyAkinshin ) 9f33f0 Add option to stop running when the first benchmark fails (#947) (by @WojciechNagorski ) 376a97 Improve dynamic assembly loading fixes #955 (by @WojciechNagorski ) 7dffd4 Handle another corner case in AdaptiveHistogramBuilder, fixes #870 (by @AndreyAkinshin ) dfb3c8 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik ) 7e7dde Fix NRE in BenchmarkRunner.RunUrl, fixes #961 (by @AndreyAkinshin ) 4e6531 Improve diagnostics dll (#962) (by @WojciechNagorski ) 6c4a59 Stop benchmark after closing application + Flush log after stopping benchmark... (by @WojciechNagorski ) 51a965 Expose StatisticalTestColumn via command line arguments (#960) (by @adamsitnik ) ca188d 0.11.3 initial release notes (by @adamsitnik ) adde64 Fix typos in ConfigParser and CommandLineOptions (#966) (by @morgan-kn ) ab96ab make sure we cleanup the Logger after running the benchmark, otherwise AppDom... (by @adamsitnik ) 91362d Update v0.11.3 changelog (by @AndreyAkinshin ) e7e4b5 Set library version: 0.11.3 (by @AndreyAkinshin ) Contributors (6) Adam Sitnik ( @adamsitnik ) Ahmed Aderopo Alejo ( @ahmedalejo ) Andrey Akinshin ( @AndreyAkinshin ) David Maas ( @PathogenDavid ) Irina Ananeva ( @morgan-kn ) Wojciech Nagórski ( @WojciechNagorski ) Thank you very much! Additional details Date: November 20, 2018 Milestone: v0.11.3 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.3 BenchmarkDotNet v0.11.2 This release includes many PRs from the Hacktoberfest. We are very grateful to all the contributors who spent their time to help us make BenchmarkDotNet even better! Highlights In this release, we have many improvements in different areas: Diagnosers EtwProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file) Execution: Comparing NuGet packages (now it's possible to compare different versions of the same package) .NET Core 3.0 support Deferred Execution Validator Command-line: --list : List of benchmarks --info : Print environment info --runtimes : Choosing execution runtimes ( --runtimes net472 netcoreapp2.1 will executed a benchmark on .NET 4.7.2 and .NET Core 2.1) Options for number of invocations and iterations Custom default settings for console argument parser Case-insensitive filter Benchmarking with different CoreRun instances Hardware counters command-line support Exporters: Markdown output for DisassemblyDiagnoser Diff view for disassembler output Improved LINQPad support (colored monospaced logs) Better CPU brand strings Attributes: Async [GlobalSetup] and [GlobalCleanup] support Introduced [ParamsAllValues] Selecting Baseline across Methods and Jobs Statistics: Better statistical tests (Welch's t-test and Mann-Whitney U-test) ZeroMeasurementAnalyser RatioColumn Other: Azure Pipelines support for internal builds Many minor bug fixes Improved documentation New tests Diagnosers EtwProfiler EtwProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with PerfView or Windows Performance Analyzer . EtwProfiler uses TraceEvent library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events. Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one. You can find more details in the documentation and in the blog post by Adam Sitnik. #878 EtwProfiler Diagnoser (by @adamsitnik ) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik ) Execution Comparing NuGet packages Now it's possible to compare performance of several versions of the same NuGet package. An example: [Config(typeof(Config))] public class IntroNuGet { // Specify jobs with different versions of the same NuGet package to benchmark. // The NuGet versions referenced on these jobs must be greater or equal to the // same NuGet version referenced in this benchmark project. // Example: This benchmark project references Newtonsoft.Json 9.0.1 private class Config : ManualConfig { public Config() { var baseJob = Job.MediumRun.With(CsProjCoreToolchain.Current.Value); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\")); } } [Benchmark] public void SerializeAnonymousObject() => JsonConvert.SerializeObject( new { hello = \"world\", price = 1.99, now = DateTime.UtcNow }); } See also: Sample: IntroNuGet #290 Question: Any official way to benchmark same method between different assembly versions? #931 Same NuGet version used when benchmarking different packages #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza ) #932 Partition benchmark run info based on added nuget packages (by @blairconrad ) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza ) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad ) cf84a4 NuGet casing fix (by @AndreyAkinshin ) .NET Core 3.0 support Now it's possible to run benchmarks on preview versions of .NET Core 3.0. #874 .NET Core 3.0 support (assignee: @adamsitnik ) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik ) Deferred Execution Validator In LINQ, execution of a query is usually deferred until the moment when you actually request the data. If your benchmark just returns IEnumerable or IQueryable it's not measuring the execution of the query, just the creation. This is why we decided to warn you about this issue whenever it happens: Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that. Don't worry! We are also providing you with a Consume extension method which can execute given IEnumerable or IQueryable and consume its results. All you need to do is to create a Consumer instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to Consume extension method. Do not call .ToArray() because it's an expensive operation and it might dominate given benchmark! See also: Sample: IntroDeferredExecution #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik ) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik ) Command-line In this release, we have tons of improvements for command-line experience. --list : List of benchmarks The --list allows you to print all of the available benchmark names. Available options are: flat - prints list of the available benchmarks: --list flat BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5 BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256 BenchmarkDotNet.Samples.IntroArguments.Benchmark BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf BenchmarkDotNet.Samples.IntroBasic.Sleep [...] tree - prints tree of the available benchmarks: --list tree BenchmarkDotNet └─Samples ├─Algo_Md5VsSha256 │ ├─Md5 │ └─Sha256 ├─IntroArguments │ └─Benchmark ├─IntroArgumentsSource │ ├─SingleArgument │ └─ManyArguments ├─IntroArrayParam │ ├─ArrayIndexOf │ └─ManualIndexOf ├─IntroBasic │ ├─Sleep [...] The --list option works with the --filter option. Examples: --list flat --filter *IntroSetupCleanup* prints: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD --list tree --filter *IntroSetupCleanup* prints: BenchmarkDotNet └─Samples ├─IntroSetupCleanupGlobal │ └─Logic ├─IntroSetupCleanupIteration │ └─Benchmark └─IntroSetupCleanupTarget ├─BenchmarkA ├─BenchmarkB ├─BenchmarkC └─BenchmarkD #905 Implement --list #914 Implement --list - fixes #905 (by @wojtpl2 ) #916 Update console-args.md - add information about --list option (by @wojtpl2 ) 330f66 Implement --list - fixes #905 (#914) (by @wojtpl2 ) 6c7521 Update console-args.md - add information about --list option (#916) (by @wojtpl2 ) --info : Print environment info Some of our users really like the info we print about hardware and OS. Now we have the --info console line argument which does not run the benchmarks, but simply prints the info. BenchmarkDotNet=v0.11.1.786-nightly, OS=Windows 10.0.17134.285 (1803/April2018Update/Redstone4) Intel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores Frequency=3507500 Hz, Resolution=285.1033 ns, Timer=TSC .NET Core SDK=3.0.100-alpha1-009642 [Host] : .NET Core 3.0.0-preview1-27004-04 (CoreCLR 4.6.27003.04, CoreFX 4.6.27003.02), 64bit RyuJIT #904 Implement --info #907 fixes #904 Implement --info (by @lahma ) 4be28d fixes #904 Implement --info (#907) (by @lahma ) --runtimes : Choosing execution runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Mono, CoreRT, Core, Clr net46, net461, net462, net47, net471, net472, netcoreapp2.0, netcoreapp2.1, netcoreapp2.2, netcoreapp3.0. Example: run the benchmarks for .NET 4.7.2 and .NET Core 2.1: dotnet run -c Release -- --runtimes net472 netcoreapp2.1 #913 .NET Core Toolchains improvements (by @adamsitnik ) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik ) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik ) Options for number of invocations and iterations --launchCount - how many times we should launch process with target benchmark. The default is 1. --warmupCount - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic. --minWarmupCount - minimum count of warmup iterations that should be performed. The default is 6. --maxWarmupCount - maximum count of warmup iterations that should be performed. The default is 50. --iterationTime - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default. --iterationCount - how many target iterations should be performed. By default calculated by the heuristic. --minIterationCount - minimum number of iterations to run. The default is 15. --maxIterationCount - maximum number of iterations to run. The default is 100. --invocationCount - invocation count in a single iteration. By default calculated by the heuristic. --unrollFactor - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default --runOncePerIteration - run the benchmark exactly once per iteration. False by default. Example: run single warmup iteration, from 9 to 12 actual workload iterations. dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 #902 More command line args (by @adamsitnik ) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik ) Custom default settings for console argument parser If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as .AsDefault and pass it to BenchmarkSwitcher together with the console line arguments. Example: run single warmup iteration by default. static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, GetGlobalConfig()); static IConfig GetGlobalConfig() => DefaultConfig.Instance .With(Job.Default .WithWarmupCount(1) .AsDefault()); // the KEY to get it working Now, the default settings are: WarmupCount=1 but you might still overwrite it from console args like in the example below: dotnet run -c Release -- --warmupCount 2 Case-insensitive filter The --filter or just -f allows you to filter the benchmarks by their full name ( namespace.typeName.methodName ) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Now this filter expression is case-insensitive. #864 Make the filter case insensitive (assignee: @adamsitnik ) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik ) Benchmarking with different CoreRun instances CoreRun is a simpler version of dotnet run , used for developing CoreCLR and CoreFX. Typically when working on the performance of .NET Core a developer has more than 1 copy of CoreRun. Example: CoreRun before my changes, and after my changes. This change allows to simply run same benchmark for few different CoreRuns to compare the perf in easy way. Sample usage: dotnet run -c Release -f netcoreapp2.1 -- -f *Empty.method --job dry --coreRun C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root\\CoreRun.exe C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root_beforeMyChanges\\CoreRun.exe Sample output: #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik ) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik ) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik ) Hardware counters command-line support --counters CacheMisses+InstructionRetired 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik ) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik ) Exporters Markdown output for DisassemblyDiagnoser Now DisassemblyDiagnoser generates markdown version of the assembly listing. #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik ) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik ) Diff view for disassembler output Now we have PrettyGithubMarkdownDiffDisassemblyExporter which can generates nice diffs between assembly listings. This mode can be activated via the --disasmDiff command line argument or the printDiff: true argument of DisassemblyDiagnoserConfig . An output example (Diff between SumLocal and SumField on .NET Core 2.1.4 (CoreCLR 4.6.26814.03, CoreFX 4.6.26814.02), 64bit RyuJIT) -; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumLocal() - var local = field; // we use local variable that points to the field - ^^^^^^^^^^^^^^^^^^ - mov rax,qword ptr [rcx+8] +; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumField() int sum = 0; ^^^^^^^^^^^^ - xor edx,edx - for (int i = 0; i < local.Length; i++) + xor eax,eax + for (int i = 0; i < field.Length; i++) ^^^^^^^^^ - xor ecx,ecx - for (int i = 0; i < local.Length; i++) + xor edx,edx + for (int i = 0; i < field.Length; i++) ^^^^^^^^^^^^^^^^ - mov r8d,dword ptr [rax+8] - test r8d,r8d + mov rcx,qword ptr [rcx+8] + cmp dword ptr [rcx+8],0 jle M00_L01 - sum += local[i]; + sum += field[i]; ^^^^^^^^^^^^^^^^ M00_L00: - movsxd r9,ecx - add edx,dword ptr [rax+r9*4+10h] - for (int i = 0; i < local.Length; i++) + mov r8,rcx + cmp edx,dword ptr [r8+8] + jae 00007ff9`0c412c1f + movsxd r9,edx + add eax,dword ptr [r8+r9*4+10h] + for (int i = 0; i < field.Length; i++) ^^^ - inc ecx - cmp r8d,ecx + inc edx + cmp dword ptr [rcx+8],edx jg M00_L00 return sum; ^^^^^^^^^^^ M00_L01: - mov eax,edx -; Total bytes of code 34 + add rsp,28h +; Total bytes of code 42 #544 Diff view for disassembler output (assignee: @wojtpl2 ) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @wojtpl2 ) #936 Producing the asm diff reports on demand #937 Producing the asm diff reports on demand - fix for #936 (by @wojtpl2 ) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @wojtpl2 ) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @wojtpl2 ) Improved LINQPad support If you run BenchmarkDotNet v0.11.2+ in LINQPad, your logs will be colored and monospaced: #447 Implement ColoredLogger for LinqPad #903 Add LINQPad logging (by @bgrainger ) #915 Use a monospaced font for LINQPad logging output (by @bgrainger ) c3b609 Add LINQPad logging (#903) (by @bgrainger ) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger ) Better CPU brand strings We did a lot of changes which improve the presentation form of the CPU brand string. Here is an example of such string in the previous version of BenchmarkDotNet: AMD Ryzen 7 2700X Eight-Core Processor (Max: 4.10GHz), 1 CPU, 16 logical and 8 physical cores Now it becomes: AMD Ryzen 7 2700X 4.10GHz, 1 CPU, 16 logical and 8 physical cores As you can see, \"Eight-Core Processor\" was removed (because we already have \"8 physical cores\"); \"(Max: 4.10GHz)\" was replaced by 4.10GHz (because the original CPU brand string doesn't contain the nominal frequency). #859 Strange max frequency values on Windows (assignee: @Rizzen ) #909 Improve CPU Brand Strings without frequency #860 Fix strange CPU Frequency values (by @Rizzen ) #910 Simplify AMD Ryzen CPU brand info (by @lahma ) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen ) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma ) Attributes Async GlobalSetup and GlobalCleanup Now GlobalSetup and GlobalCleanup methods can be async. See also: docs.setup-and-cleanup #521 Support async Setup/Cleanup #892 Added support for async GlobalSetup. (by @dlemstra ) #923 async GlobalCleanup support (by @dlemstra ) #926 Added support for async GlobalCleanup. (by @dlemstra ) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra ) a971a4 async GlobalCleanup support (#923) (by @dlemstra ) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra ) Introduced ParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T> , where T is an enum or boolean An example: public class IntroParamsAllValues { public enum CustomEnum { A, BB, CCC } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( E.ToString().Length * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } Output: Method | E | B | Mean | Error | ---------- |---- |------ |---------:|------:| Benchmark | A | ? | 101.9 ms | NA | Benchmark | A | False | 111.9 ms | NA | Benchmark | A | True | 122.3 ms | NA | Benchmark | BB | ? | 201.5 ms | NA | Benchmark | BB | False | 211.8 ms | NA | Benchmark | BB | True | 221.4 ms | NA | Benchmark | CCC | ? | 301.8 ms | NA | Benchmark | CCC | False | 312.3 ms | NA | Benchmark | CCC | True | 322.2 ms | NA | // * Legends * E : Value of the 'E' parameter B : Value of the 'B' parameter #658 [Params] for enums should include all values by default #908 Added [ParamsAllValues] (by @gsomix ) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix ) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin ) Selecting Baseline across Methods and Jobs Now it's possible to mark a method and a job as baselines at the same time: public class TheBaselines { [Benchmark(Baseline = true)] public void Sleep100ms() => Thread.Sleep(TimeSpan.FromMilliseconds(100)); [Benchmark] public void Sleep50ms() => Thread.Sleep(TimeSpan.FromMilliseconds(50)); } static void Main(string[] args) => BenchmarkSwitcher .FromTypes(new[] { typeof(TheBaselines) }) .Run(args, DefaultConfig.Instance .With(Job.Core.AsBaseline()) .With(Job.Clr.WithId(\"CLR 4.7.2\"))); #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin ) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin ) Statistics Statistical tests In this release, statistical testing was significantly improved. Now it's possible to compare all benchmarks against baseline with the help of Welch's t-test or Mann–Whitney U test. An example: [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Ratio, 0.03, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Ratio, 0.03, true)] [SimpleJob(warmupCount: 0, targetCount: 5)] public class IntroStatisticalTesting { [Benchmark] public void Sleep50() => Thread.Sleep(50); [Benchmark] public void Sleep97() => Thread.Sleep(97); [Benchmark] public void Sleep99() => Thread.Sleep(99); [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100); [Benchmark] public void Sleep101() => Thread.Sleep(101); [Benchmark] public void Sleep103() => Thread.Sleep(103); [Benchmark] public void Sleep150() => Thread.Sleep(150); } Output: Method Mean Error StdDev Ratio Welch(1us)/p-values Welch(3%)/p-values MannWhitney(1us)/p-values MannWhitney(3%)/p-values Sleep50 53.13 ms 0.5901 ms 0.1532 ms 0.51 Faster: 1.0000/0.0000 Faster: 1.0000/0.0000 Faster: 1.0000/0.0040 Faster: 1.0000/0.0040 Sleep97 100.07 ms 0.9093 ms 0.2361 ms 0.97 Faster: 1.0000/0.0000 Same: 1.0000/0.1290 Faster: 1.0000/0.0040 Same: 1.0000/0.1111 Sleep99 102.23 ms 2.4462 ms 0.6353 ms 0.99 Faster: 0.9928/0.0072 Same: 1.0000/0.9994 Faster: 0.9960/0.0079 Same: 1.0000/1.0000 Sleep100 103.34 ms 0.8180 ms 0.2124 ms 1.00 Base: 0.5029/0.5029 Base: 1.0000/1.0000 Base: 0.7262/0.7262 Base: 1.0000/1.0000 Sleep101 103.73 ms 2.1591 ms 0.5607 ms 1.00 Same: 0.1041/0.8969 Same: 0.9999/1.0000 Same: 0.1111/0.9246 Same: 1.0000/1.0000 Sleep103 106.21 ms 1.2511 ms 0.3249 ms 1.03 Slower: 0.0000/1.0000 Same: 0.9447/1.0000 Slower: 0.0040/1.0000 Same: 0.9246/1.0000 Sleep150 153.16 ms 3.4929 ms 0.9071 ms 1.48 Slower: 0.0000/1.0000 Slower: 0.0000/1.0000 Slower: 0.0040/1.0000 Slower: 0.0040/1.0000 // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) Welch(1us)/p-values : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' Welch(3%)/p-values : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(3%)/p-values : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' 1 ms : 1 Millisecond (0.001 sec) The statistical testing is a work-in-progress feature. In future versions of BenchmarkDotNet, we are planning to improve API, fill missed docs, and introduce more parameters for customization. See also: Sample: IntroStatisticalTesting 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin ) 05cc8d Statistical testing improvements (by @AndreyAkinshin ) ZeroMeasurementAnalyser When you have an empty benchmark like this [Benchmark] public void Empty() { } The expected duration of this method is zero. However, you can get the mean value like 0.0023ns because of the natural noise. It's a pretty confusing result for many developers. Since v0.11.2, we have ZeroMeasurementAnalyser which warn you about such methods. By default, BenchmarkDotNet automatically evaluate overhead. In this case, ZeroMeasurementAnalyser runs Welch's t-test and compare actual and overhead measurements. If the overhead evaluation is disabled, it runs one-sample Student's t-test against a half of CPU cycle. #906 Zero measurement analyser (by @Rizzen ) 48d193 Zero measurement analyser (#906) (by @Rizzen ) RatioColumn The Ratio column was formerly known as Scaled . The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46 / 100.39 for Time50 ). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. See also: Sample: IntroBenchmarkBaseline , Sample: IntroRatioSD , Benchmark and Job Baselines . 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin ) Milestone details In the v0.11.2 scope, 28 issues were resolved and 33 pull requests were merged. This release includes 84 commits by 20 contributors. Resolved issues (28) #221 Investigate why CanEnableServerGcMode test fails for Core on appveyor #290 Question: Any official way to benchmark same method between different assembly versions? #447 Implement ColoredLogger for LinqPad #521 Support async Setup/Cleanup #544 Diff view for disassembler output (assignee: @WojciechNagorski ) #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik ) #601 Surprising results #658 [Params] for enums should include all values by default #731 Add constant folding analyser #788 Detect correct version of .NET Core in Docket container #842 Benchmark filter: wildcards on *nix CLI (assignee: @adamsitnik ) #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik ) #859 Strange max frequency values on Windows (assignee: @Rizzen ) #862 Don't print parse errors to the output (assignee: @adamsitnik ) #863 Make it easier to understand which process belongs to which benchmark (assignee: @adamsitnik ) #864 Make the filter case insensitive (assignee: @adamsitnik ) #874 .NET Core 3.0 support (assignee: @adamsitnik ) #879 Benchmark attributed with \"HardwareCounters\" throws an exception (assignee: @adamsitnik ) #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin ) #889 ArgumentsSource doesn't work if method takes 1 arg (assignee: @adamsitnik ) #891 Add docs about debugging BDN issues (assignee: @adamsitnik ) #904 Implement --info #905 Implement --list #909 Improve CPU Brand Strings without frequency #911 Excluding specific namespaces from disassembly (assignee: @adamsitnik ) #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik ) #931 Same NuGet version used when benchmarking different packages #936 Producing the asm diff reports on demand Merged pull requests (33) #860 Fix strange CPU Frequency values (by @Rizzen ) #878 EtwProfiler Diagnoser (by @adamsitnik ) #886 Enabled GcModeTests.CanEnableServerGcMode (by @dlemstra ) #887 Dependencies update (by @adamsitnik ) #888 Fix duplicate example in RunStrategy guide (by @stevedesmond-ca ) #890 RPlotExporter: use https to download dependencies (by @xavero ) #892 Added support for async GlobalSetup. (by @dlemstra ) #894 Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (by @dlemstra ) #898 Add workaround for Full framework on *NIX (by @mfilippov ) #900 Fixing aspnet/KestrelHttpServer url (by @facundofarias ) #901 Fixing SignalR and EntityFrameworkCore url as well (by @facundofarias ) #902 More command line args (by @adamsitnik ) #903 Add LINQPad logging (by @bgrainger ) #906 Zero measurement analyser (by @Rizzen ) #907 fixes #904 Implement --info (by @lahma ) #908 Added [ParamsAllValues] (by @gsomix ) #910 Simplify AMD Ryzen CPU brand info (by @lahma ) #913 .NET Core Toolchains improvements (by @adamsitnik ) #914 Implement --list - fixes #905 (by @WojciechNagorski ) #915 Use a monospaced font for LINQPad logging output (by @bgrainger ) #916 Update console-args.md - add information about --list option (by @WojciechNagorski ) #917 Add Azure Pipelines support (by @Ky7m ) #920 OCD Whitespace and tabs cleanup (by @dlemstra ) #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza ) #923 async GlobalCleanup support (by @dlemstra ) #926 Added support for async GlobalCleanup. (by @dlemstra ) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @WojciechNagorski ) #929 Add build status badges for Azure Pipelines (by @Ky7m ) #930 Fix minor spelling issues and typos (by @KonH ) #932 Partition benchmark run info based on added nuget packages (by @blairconrad ) #934 Detect correct version of .NET Core in Docker (by @Rizzen ) #935 Add Timeout for dotnet cli build commands to our toolchains (by @adamsitnik ) #937 Producing the asm diff reports on demand - fix for #936 (by @WojciechNagorski ) Commits (84) 22b020 Postrelease update of v0.11.1 changelog (by @AndreyAkinshin ) 3e26df docs: fix NuGet package lists in footers (v0.11.x) (by @AndreyAkinshin ) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik ) 50fd57 exported json file should contain correct type name for generic types, not Ge... (by @adamsitnik ) 30b885 benchmarked code can be defining IHost so we need to provide full name (examp... (by @adamsitnik ) b7104e Don't print parse errors to the output, fixes #862 (by @adamsitnik ) 3a21b4 Make it easier to understand which process belongs to which benchmark, fixes ... (by @adamsitnik ) 99ea2d Fix behavior of Baseline property of Benchmark attribute in integration with ... (by @Caballero77 ) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik ) ff1214 Update IntroSetupCleanupTarget.md (#876) (by @fredeil ) 1721b4 Fixed typo in the NodaTime name (#877) (by @YohDeadfall ) f411a5 Fix typo in example code (#869) (by @NRKirby ) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin ) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen ) 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin ) 05cc8d Statistical testing improvements (by @AndreyAkinshin ) 557752 Fix compilation (by @AndreyAkinshin ) a03307 Enabled GcModeTests.CanEnableServerGcMode (#886) fixes #221 (by @dlemstra ) add585 Fix duplicate example in RunStrategy guide (#888) (by @stevedesmond-ca ) d8b008 Use NoInlining for CommonExporterApprovalTests (by @AndreyAkinshin ) eacfd7 Dependencies update (#887) (by @adamsitnik ) 579986 improve the docs, explain how to use ArgumentsSource for single arugment, fix... (by @adamsitnik ) 1ceee3 Fix compilation after merge (by @AndreyAkinshin ) 9ff772 RPlotExporter: use https to download dependencies (#890) (by @xavero ) 41d6b8 added xml docs, made some methods virtual/public to make it easier to write y... (by @adamsitnik ) cd0791 restore --no-dependencies was good when we were generating multiple projects,... (by @adamsitnik ) ad1feb expose KeepBenchmarkFiles as --keepFiles command line argument, #891 (by @adamsitnik ) 6880b5 add DebugInProcessConfig and DebugBuildConfig to make troubleshooting easier,... (by @adamsitnik ) 12e01a add Troubleshooting docs, fixes #891 (by @adamsitnik ) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik ) 1b8051 wrap * in '*' on Unix when showing users the help, fixes #842 (by @adamsitnik ) 382a4a Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (#894) (by @dlemstra ) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik ) 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik ) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik ) b90be6 Add workaround for Full framework on *NIX (#898) (by @mfilippov ) 4afdb8 Fixing aspnet/KestrelHttpServer url (#900) (by @facundofarias ) 3319ab Fixing SignalR and EntityFrameworkCore url as well (#901) (by @facundofarias ) b72aab allow the users to specify programmatically custom default job settings and o... (by @adamsitnik ) 2e7042 Merge pull request #902 from dotnet/moreCommandLineArgs (by @adamsitnik ) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik ) 220bae DotNetCliGenerator.TargetFrameworkMoniker must be public (by @adamsitnik ) 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin ) 177c07 Add Windows 10 (1809) in OsBrandStringHelper (by @AndreyAkinshin ) 4be28d fixes #904 Implement --info (#907) (by @lahma ) c3b609 Add LINQPad logging (#903) (by @bgrainger ) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix ) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik ) 330f66 Implement --list - fixes #905 (#914) (by @WojciechNagorski ) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger ) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin ) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik ) 8949df BenchmarkSwitcher should ask the user for choosing the benchmarks when the gl... (by @adamsitnik ) fb8f89 Make WindowsDisassembler public to allow for late resutls filtering in diagno... (by @adamsitnik ) 0bcbce allow configuring disasm recursive depth from console line arguments; --todo; (by @adamsitnik ) 5e3cee make sure BenchmarkSwitcher handles all possible cases and gives nice errors (by @adamsitnik ) 6c7521 Update console-args.md - add information about --list option (#916) (by @WojciechNagorski ) 8773ff when user provides categories via command line to benchmark switcher we don't... (by @adamsitnik ) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik ) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma ) 1b4c7f OCD Whitespace and tabs cleanup (#920) (by @dlemstra ) d917e6 don't parse the trace file if there are no counters configured, wait for dela... (by @adamsitnik ) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra ) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik ) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik ) 98925b initial 0.11.2 release notes (by @adamsitnik ) a971a4 async GlobalCleanup support (#923) (by @dlemstra ) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra ) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza ) 601c66 Add Azure Pipelines support (#917) (by @Ky7m ) f9ac68 Add build status badges (#929) (by @Ky7m ) 8a2eec Fix minor spelling issues and typos (#930) (by @KonH ) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad ) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @WojciechNagorski ) 48d193 Zero measurement analyser (#906) (by @Rizzen ) cf84a4 NuGet casing fix (by @AndreyAkinshin ) fd459f Remove remark about prerelease version in etwprofiler.md (by @AndreyAkinshin ) db444c Add Timeout for dotnet cli build commands to our toolchains (#935) fixes #933 (by @adamsitnik ) bb0b18 Detect correct version of .NET Core in Docker (#934), fixes #788 (by @Rizzen ) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @WojciechNagorski ) 864400 Update v0.11.2 changelog (by @AndreyAkinshin ) 15c035 Minor IntroSamples fixes (by @AndreyAkinshin ) a5b692 Update v0.11.2 changelog (by @AndreyAkinshin ) 2341c7 Set library version: 0.11.2 (by @AndreyAkinshin ) Contributors (20) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Blair Conrad ( @blairconrad ) Bradley Grainger ( @bgrainger ) Caballero77 ( @Caballero77 ) Dirk Lemstra ( @dlemstra ) Evgeniy Andreev ( @gsomix ) Facundo Farias ( @facundofarias ) Flavio Xavero ( @xavero ) Fredrik Eilertsen ( @fredeil ) Igor Fesenko ( @Ky7m ) KonH ( @KonH ) Mark Tkachenko ( @Rizzen ) Marko Lahma ( @lahma ) Mikhail Filippov ( @mfilippov ) Nick Kirby ( @NRKirby ) Shannon Deminick ( @Shazwazza ) Steve Desmond ( @stevedesmond-ca ) Wojciech Nagórski ( @WojciechNagorski ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: November 1, 2018 Milestone: v0.11.2 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.2 BenchmarkDotNet v0.11.1 This release includes some minor improvements and bug fixes: Fixed RPlotExporter ( #852 , #855 ). In v0.11.0, the plot generation was broken because of the huge renaming in #787 . ArgumentsSource now supports additional types like Type ( #840 ), BigInteger ( #850 ), DateTime ( #853 ), and special double values like double.NaN ( #851 ) Generated projects ignore Directory.Build.props and Directory.Build.targets files #854 Now it's possible to run benchmarks with CoreRun ( de152c , #857 ) Milestone details In the v0.11.1 scope, 7 issues were resolved and 2 pull requests were merged. This release includes 29 commits by 4 contributors. Resolved issues (7) #840 ArgumentsSource doesn't work with System.RuntimeType (assignee: @AndreyAkinshin ) #850 Handle BigIntegers arguments properly (assignee: @adamsitnik ) #851 Handle double special values like NaN etc (assignee: @adamsitnik ) #852 BuildPlots script generates empty pictures (assignee: @AndreyAkinshin ) #853 ArgumentsSource containing IFormattable leads to Compile Exceptions (assignee: @adamsitnik ) #855 Empty plot (assignee: @AndreyAkinshin ) #857 Improve user experience for working with local CoreFX builds (assignee: @adamsitnik ) Merged pull requests (2) #839 Small Typo in changelog (by @Tornhoof ) #854 Exclude Directory.Build.props/targets from generated csproj files (by @agocke ) Commits (29) c37aa8 Postrelease update of v0.11.0 changelog (by @AndreyAkinshin ) b7f7fc Handle private types in GetCorrectCSharpTypeName, fixes #840 (by @AndreyAkinshin ) 522158 Handle private types in GetCorrectCSharpTypeName (part 2), fixes #840 (by @AndreyAkinshin ) 64acde small typo (#839) (by @Tornhoof ) 521c22 Add travis_wait for build.sh (by @AndreyAkinshin ) a8a0da Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 9ab58a Introduce BenchmarkDotNet.Samples.csproj.DotSettings (by @AndreyAkinshin ) 3ce9fe BenchmarkDotNet.Samples Cleanup (by @AndreyAkinshin ) a04a23 Cleanup: spelling issues in BenchmarkDotNet (by @AndreyAkinshin ) c37784 Cleanup: code style issues in BenchmarkDotNet (by @AndreyAkinshin ) 5f8452 Cleanup: Redundancies in Code issues in BenchmarkDotNet (by @AndreyAkinshin ) a76f43 Cleanup: Common Practices and Code Improvements in BenchmarkDotNet (by @AndreyAkinshin ) 2d0629 Cleanup: Redundancies in Symbol Declarations Issues in BenchmarkDotNet (by @AndreyAkinshin ) 5a7689 Cleanup: Constraints Violations Issues in BenchmarkDotNet (by @AndreyAkinshin ) 02df24 Cleanup: Language Usage Opportunities in BenchmarkDotNet (by @AndreyAkinshin ) 93ed39 Cleanup: Potential Code Quality Issues in BenchmarkDotNet (by @AndreyAkinshin ) 538f56 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin ) 559773 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin ) 29471e add support for BigIntegers + include namespace of the arugments, fixes #850 (by @adamsitnik ) 2aff9f Handle double and float special values like NaN, PositiveInfinity etc, fixes ... (by @adamsitnik ) 1a68ed properties of SummaryStyle must have public setter (by @adamsitnik ) 5cfb5b support DateTimes for [Arguments/Params Source], fixes #853 (by @adamsitnik ) 2be698 Fix RPlots, fixes #852 (by @AndreyAkinshin ) 7ee3cf Exclude Directory.Build.props/targets from generated csproj files (by @agocke ) 20e901 Merge pull request #854 from agocke/fix-csproj-template (by @adamsitnik ) de152c allow the users to run benchmarks with CoreRun, #857 (by @adamsitnik ) f00ac0 Increase travis timeout (by @AndreyAkinshin ) 071e58 docs: add changelog for v0.11.1 (by @AndreyAkinshin ) c5e586 Set library version: 0.11.1 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Andy Gocke ( @agocke ) Stefan ( @Tornhoof ) Thank you very much! Additional details Date: August 22, 2018 Milestone: v0.11.1 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.1 BenchmarkDotNet v0.11.0 This is one of the biggest releases of BenchmarkDotNet ever. There are so many improvements. We have new documentation, many performance improvements, Job Mutators, better user experience, correct Ctrl+C handling, better generic benchmarks support, more scenarios for passing arguments to benchmarks, awesome support of console arguments, unicode support, LLVM support in MonoDisassembler, and many-many other improvements and bug fixes! A big part of the features and bug fixes were implemented to meet the enterprise requirements of Microsoft to make it possible to port CoreCLR, CoreFX, and CoreFXLab to BenchmarkDotNet. The release would not be possible without many contributions from amazing community members. This release is a combined effort. We build BenchmarkDotNet together to make benchmarking .NET code easy and available to everyone for free! New documentation We have many improvements in our documentation! The new docs include: DocFX under the hood Detailed changelogs which includes all commits, merged pull requests and resolved issues API references Code samples for main features: we generate it automatically based on the BenchmarkDotNet.Samples project; it means that all samples can always be compiled (no more samples with outdated API) Better UI Documentation versioning: now it's possible to look at the documentation for recent BenchmarkDotNet versions Performance improvements BenchmarkDotNet needs to be capable of running few thousands of CoreFX and CoreCLR benchmarks in an acceptable amount of time. The code itself was already optimized so we needed architectural and design changes to meet this requirement. Generate one executable per runtime settings To ensure that the side effects of one benchmark run does not affect another benchmark run BenchmarkDotNet generates, builds and runs every benchmark in a dedicated process. So far we were generating and building one executable per benchmark, now we generate and build one executable per runtime settings. So if you want to run ten thousands of benchmarks for .NET Core 2.1 we are going to generate and build single executable, not ten thousand. If you target multiple runtimes the build is going to be executed in parallel. Moreover, if one of the parallel builds fail it's going to be repeated in a sequential way. Previously the time to generate and build 650 benchmarks from our Samples project was one hour . Now it's something around 13 seconds which means 276 X improvement for this particular scenario. You can see the changes here . Don't execute long operations more than once per iteration BenchmarkDotNet was designed to allow for very accurate and stable micro-benchmarking. One of the techniques that we use is manual loop unrolling. In practice, it meant that for every iteration we were executing the benchmark at least 16 times (the default UnrollFactor value). It was of course not desired for the very time-consuming benchmarks. So far this feature was always enabled by default and users would need to configure UnrollFactor=1 to disable it. Now BenchmarkDotNet is going to discover such scenario and don't perform manual loop unrolling for the very time-consuming benchmarks. BenchmarkDotNet uses Job.IterationTime setting (the default is 0.5s) in the Pilot Experiment stage to determine how many times given benchmark should be executed per iteration. Example: public class Program { static void Main() => BenchmarkRunner.Run<Program>(); [Benchmark] public void Sleep1s() => Thread.Sleep(TimeSpan.FromSeconds(1)); } Time to run with the previous version: 374 seconds . With 0.11.0 it's 27 seconds which gives us almost 14 X improvement. A good example of benchmarks that are going to benefit from this change are computer game benchmarks and ML.NET benchmarks. You can see the changes here and here . Exposing more configuration settings The default settings were configured to work well with every scenario. Before running the benchmark, BenchmarkDotNet does not know anything about it. This is why it performs many warmup iterations before running the benchmarks. When you author benchmarks and run them many times you can come up with custom settings that produce similar results but in a shorter manner of time. To allow you to do that we have exposed: Job.MinIterationCount (default value is 15) Job.MaxIterationCount (default value is 100) Job.MinWarmupIterationCount (default value is 6) Job.MaxWarmupIterationCount (default value is 50) User Experience One of the biggest success factors of BenchmarkDotNet is a great user experience. The tool just works as expected and makes your life easy. We want to make it even better! .NET Standard 2.0 We have ported BenchmarkDotNet to .NET Standard 2.0 and thanks to that we were able to not only simplify our code and build process but also merge BenchmarkDotNet.Core.dll and BenchmarkDotNet.Toolchains.Roslyn.dll into BenchmarkDotNet.dll . We still support .NET 4.6 but we have dropped .NET Core 1.1 support. More information and full discussion can be found here . Note: Our BenchmarkDotNet.Diagnostics.Windows package which uses EventTrace to implement ETW-based diagnosers was also ported to .NET Standard 2.0 and you can now use all the ETW diagnosers with .NET Core on Windows. We plan to add EventPipe support and make this page fully cross-platform and Unix compatible soon. Using complex types as benchmark arguments So far we have required the users to implement IParam interface to make the custom complex types work as benchmark arguments/parameters. This has changed, now the users can use any complex types as arguments and it will just work ( more ). public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); public IEnumerable<object> Arguments() { yield return new Point2D(10, 200); } [Benchmark] [ArgumentsSource(nameof(Arguments))] public int WithArgument(Point2D point) => point.X + point.Y; } public class Point2D { public int X, Y; public Point2D(int x, int y) { X = x; Y = y; } public override string ToString() => $\"[{X},{Y}]\"; } Note : If you want to control what will be displayed in the summary you should override ToString . If IterationSetup is provided run benchmark once per iteration When Stephen Toub says that something is buggy , it most probably is. BenchmarkDotNet performs multiple invocations of benchmark per every iteration. When we have exposed the [IterationSetup] attribute many users were expecting that the IterationSetup is going to be invoked before every benchmark execution. It was invoked before every iteration, and iteration was more than one benchmark call if the user did not configure that explicitly. We have changed that and now if you provide an [IterationSetup] method it is going to be executed before every iteration and iteration will invoke the benchmark just once. public class Test { public static void Main() => BenchmarkRunner.Run<Test>(); [IterationSetup] public void MySetup() => Console.WriteLine(\"MySetup\"); [Benchmark] public void MyBenchmark() => Console.WriteLine(\"MyBenchmark\"); } Before: MySetup MyBenchmark MyBenchmark MyBenchmark MyBenchmark (...) After: MySetup MyBenchmark MySetup MyBenchmark MySetup MyBenchmark (...) Note: If you want to configure how many times benchmark should be invoked per iteration you can use the new [InvocationCountAttribute] . Job Mutators Job represents a set of settings to run the benchmarks. We run every benchmark for every job defined by the user. The problem was that so far many jobs were just added to the config instead of being merged with other jobs. An example: [ClrJob, CoreJob] [GcServer(true)] public class MyBenchmarkClass Resulted in 3 jobs and 3 benchmark executions: ClrJob , CoreJob and GcServer(true) for current runtime. Now all Jobs and their corresponding attributes marked as mutators are going to be applied to other jobs, not just added to the config. So in this particular scenario, the benchmarks from MyBenchmarkClass are going to be executed for .NET with Server GC enabled and .NET Core with Server GC enabled. Mutators are great when you want to have a single, global config for all benchmarks and apply given settings only to selected types. You can find out more about mutators here . Ctrl+C When the user: presses Ctrl+C presses Ctrl+Break logs off closes console window We are now going to close any existing ETW session created by BenchmarkDotNet and restore console colors ( read more ). Handle OutOfMemoryException more gracefully When our benchmark hits OutOfMemoryException we print some nice explanation: public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); private List<object> list = new List<object>(); [Benchmark] public void AntiPattern() => list.Add(new int[int.MaxValue / 2]); } OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. Trimming long strings We used to display the values \"as is\" which was bad for long strings. Now the values are trimmed ( more ). public class Long { [Params(\"text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7\")] public string Text; [Benchmark] public int HashCode() => Text.GetHashCode(); } Method Text HashCode text/(...)q=0.7 [86] More features Generic benchmarks BenchmarkDotNet supports generic benchmarks, all you need to do is to tell it which types should be used as generic arguments ( read more ). [GenericTypeArguments(typeof(int))] [GenericTypeArguments(typeof(char))] public class IntroGenericTypeArguments<T> { [Benchmark] public T Create() => Activator.CreateInstance<T>(); } Arguments We now support more scenarios for passing arguments to benchmarks: passing arguments to asynchronous benchmarks ( more ) passing generic types passing arguments by reference passing jagged arrays ( more ) types with implicit cast operator to stack only types can be passed as given stack-only types to Benchmarks ( more ) Example: public class WithStringToReadOnlySpan { [Benchmark] [Arguments(\"some string\")] public void AcceptsReadOnlySpan(ReadOnlySpan<char> notString) } Console Arguments BenchmarkSwitcher supports various console arguments ( PR ), to make it work you need to pass the args to switcher: class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } Note: to get the most up-to-date info about supported console arguments run the benchmarks with --help . Filter The --filter or just -f allows you to filter the benchmarks by their full name ( namespace.typeName.methodName ) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Note : If you would like to join all the results into a single summary , you need to use --join . Categories You can also filter the benchmarks by categories: --anyCategories - runs all benchmarks that belong to any of the provided categories --allCategories - runs all benchmarks that belong to all provided categories Diagnosers -m , --memory - enables MemoryDiagnoser and prints memory statistics -d , --disassm - enables DisassemblyDiagnoser and exports diassembly of benchmarked code Runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Clr, Mono, Core and CoreRT. Example: run the benchmarks for .NET and .NET Core: dotnet run -c Release -- --runtimes clr core More arguments -j , --job (Default: Default) Dry/Short/Medium/Long or Default -e , --exporters GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML -i , --inProcess (Default: false) Run benchmarks in Process -a , --artifacts Valid path to accessible directory --outliers (Default: OnlyUpper) None/OnlyUpper/OnlyLower/All --affinity Affinity mask to set for the benchmark process --allStats (Default: false) Displays all statistics (min, max & more) --attribute Run all methods with given attribute (applied to class or method) Other small improvements Unicode support: now you can enable support of Unicode symbols like μ or ± with [EncodingAttribute.Unicode] , an example: BenchmarkDotNet.Samples.IntroEncoding (see #735 ) Better benchmark validation (see #693 , #737 ) Improve .NET Framework version detection : now we support .NET Framework 4.7.2 (see #743 ) OutlierModes: now it's possible to control how to process outliers, an example Sample: IntroOutliers (see #766 ) LLVM support in MonoDisassembler (see a7426e ) Grand API renaming we try not to change public API, but sometimes it's necessary because we want to get a consistent and understandable API in v1.0.0. (see #787 ) Many-many small improvements and bug fixes Milestone details In the v0.11.0 scope, 65 issues were resolved and 34 pull requests were merged. This release includes 214 commits by 11 contributors. Resolved issues (65) #136 Fastcheck for correctness of benchmark implementations #175 Add .NET Core support for Diagnostics package (assignee: @adamsitnik ) #368 Memory leak and crash with [Setup] (assignee: @adamsitnik ) #420 Make BenchmarkDotNet.Core runtime independent (assignee: @adamsitnik ) #464 Iteration setup / cleanup should not be called for Idle() (assignee: @adamsitnik ) #484 Broken HTTPS on site (assignee: @jongalloway ) #487 Please consider using 'µs' instead of 'us' #551 List of structs and OutOfMemoryException #583 BenchmarkDotNet.Samples refactoring (assignee: @AndreyAkinshin ) #586 IParam interface improvement (assignee: @adamsitnik ) #638 Config with ryujit but it doesnt actually use ryujit? (assignee: @morgan-kn ) #649 Searching docs leads to 404 page (assignee: @AndreyAkinshin ) #665 Handle OutOfMemoryException more gracefully (assignee: @adamsitnik ) #671 Why does BenchmarkRunner generate an isolated project per each benchmark method/job/params? (assignee: @adamsitnik ) #698 Port to .NET Standard 2.0, drop .NET Core 1.1 support (assignee: @adamsitnik ) #699 Generate one executable per runtime settings (assignee: @adamsitnik ) #700 Improve local CoreCLR support (assignee: @adamsitnik ) #701 Extend exported json file with FullName using xunit naming convention for integration purpose (assignee: @adamsitnik ) #710 Use DocFX as a documentation generator (assignee: @AndreyAkinshin ) #712 [Params] with arrays as params throws System.Reflection.TargetInvocationException (assignee: @adamsitnik ) #713 How to specify the invocation/launch count per type when using Config for multiple runtimes? (assignee: @adamsitnik ) #718 CoreRT support (assignee: @adamsitnik ) #719 If fail to build in Parallel due to file access issues, try to build sequentially (assignee: @adamsitnik ) #720 Add SummaryOrderPolicy.Declared #724 Allocated Memory results are not scaled with OperationPerInvoke (assignee: @adamsitnik ) #726 Improve building guideline #729 Handle Ctrl+C/Break (assignee: @adamsitnik ) #730 IterationSetup is not running before each benchmark invocation (assignee: @adamsitnik ) #733 IOException when running in OneDrive Folder (assignee: @adamsitnik ) #734 Handle missing Mono runtime more gracefully (assignee: @adamsitnik ) #736 Reduce number of initial pilot ops to 1 or make it configurable (assignee: @adamsitnik ) #738 Params string containing characters like quotes is not being escaped properly (assignee: @adamsitnik ) #741 Give users nice warning when T in generic benchmark is not public #745 It should be possible to specify the generic arguments by using attributes #747 Better docs that explain what is target/launch/iteration/invocation count (assignee: @adamsitnik ) #748 Very long string params/arguments should be trimmed (assignee: @adamsitnik ) #749 WithId(…) is ignored unless it’s at the end of the fluent calls chain. (assignee: @adamsitnik ) #763 Make MaxIterationCount configurable, keep current value as default (assignee: @adamsitnik ) #765 Add .NET Core 2.2 support (assignee: @adamsitnik ) #769 ArgumentsSource does not support Jagged Arrays (assignee: @adamsitnik ) #774 Make it possible to use Span and other ByRefLike types with implicit cast operators as benchmark argument (assignee: @adamsitnik ) #778 CS0104: 'Job' is an ambiguous reference between 'BenchmarkDotNet.Jobs.Job' and 'Nest.Job' (assignee: @adamsitnik ) #779 StackOnlyTypesWithImplicitCastOperatorAreSupportedAsArguments doesn't work on .NET Core 2.0 (assignee: @adamsitnik ) #787 Grand renaming #793 job=core for BenchmarkSwitcher (assignee: @adamsitnik ) #794 Don't exclude allocation quantum side effects for .NET Core 2.0+ (assignee: @adamsitnik ) #795 Broken BenchmarkSwitcher (assignee: @adamsitnik ) #797 Allocated is not divided by OperationsPerInvoke (assignee: @adamsitnik ) #802 AdaptiveHistogramBuilder.BuildWithFixedBinSize error when running benchmarks (assignee: @AndreyAkinshin ) #804 What is the point of BuildScriptFilePath ? (assignee: @adamsitnik ) #809 Make it possible to configure Min and Max Warmup Iteration Count (assignee: @adamsitnik ) #810 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .NET Core 2.2 (assignee: @adamsitnik ) #811 Question/Suggestion is GcStats forcing a GC.Collect when it doesn't need to (assignee: @adamsitnik ) #812 When will the next release be available on NuGet? (assignee: @adamsitnik ) #813 Problems with MemoryDiagnoserTests on Mono and .NET Core 2.0 (assignee: @adamsitnik ) #814 For type arguments we should display simple, not-trimmed name (assignee: @adamsitnik ) #816 BenchmarkDotNet.Autogenerated.csproj is not working on .NET Core 2.1 (assignee: @adamsitnik ) #817 Autogenerated project is missing dependencies (assignee: @adamsitnik ) #818 Arguments should be passed to asynchronous benchmarks (assignee: @adamsitnik ) #820 set DOTNET_MULTILEVEL_LOOKUP=0 when custom dotnet cli path is provided (assignee: @adamsitnik ) #821 ArgumentsAttribute causes an error when used with a string containing quotes (assignee: @adamsitnik ) #823 Allow to set multiple Setup/Cleanup targets without string concatenation (assignee: @adamsitnik ) #827 An easy way to run a specific benchmark class via command line (assignee: @adamsitnik ) #829 Error message for wrong command line filter (assignee: @adamsitnik ) #832 Compilation Error CS0119 with ParamsSource (assignee: @adamsitnik ) Merged pull requests (34) #693 Jit runtime validation (by @morgan-kn ) #717 V11 (by @adamsitnik ) #725 Extend exported json file with FullName using xunit naming convention for integration purpose (by @adamsitnik ) #727 Building guideline improvement (by @Rizzen ) #728 BenchmarkReport Exporter (by @Rizzen ) #735 Unicode support (by @Rizzen ) #737 Return value validator (by @ltrzesniewski ) #740 Follow up to #737 (by @ltrzesniewski ) #742 Add .NET Framework 4.7.2 version constant (by @epeshk ) #743 Improve .NET Framework version detection (by @epeshk ) #744 BenchmarkClass Validator (by @Rizzen ) #746 Addition to #743: use HasValue instead of casting (by @epeshk ) #750 Addition to #744: Using single variable in test instead of two (by @Rizzen ) #752 Update HowItWorks.md (by @Tornhoof ) #753 Ability to pass multiple assemblies. (by @paulness ) #754 generate IParams for users in smart way (by @adamsitnik ) #757 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (by @afmorris ) #758 Generic Benchmark Attribute (by @Rizzen ) #760 don't execute long operations more than once per iteration (by @adamsitnik ) #761 stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (by @adamsitnik ) #764 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, run benchmark once per iteration to avoid user confusion (by @adamsitnik ) #766 Introduce OutlierMode (by @AndreyAkinshin ) #771 have two main actions: with unroll and without, for no unroll icrease the step by 1 in pilot (not *2) (by @adamsitnik ) #781 Initial DocFX support, fixes #710 (by @AndreyAkinshin ) #783 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin ) #785 Improve filtering from console args (by @adamsitnik ) #789 docs: add changelog (by @AndreyAkinshin ) #790 add link to inprocesstoolchain (by @IanKemp ) #796 docs: multiversion combobox (by @AndreyAkinshin ) #799 Cpu info improvement (by @Rizzen ) #800 job Mutators (by @adamsitnik ) #824 Use 3rd party lib for console args parsing + support globs for filtering (by @adamsitnik ) #830 Read StandardOutput in a smart way to avoid infinite loops (by @houseofcat ) #833 initial release notes (by @adamsitnik ) Commits (214) defa7e port to .NET Standard 2.0 (by @adamsitnik ) 626b03 keep .NET 4.6 in case somebody is on full framework, but not using .NET Standard (by @adamsitnik ) ae4e22 merge BenchmarkDotNet.Toolchains.Roslyn into BenchmarkDotNet.Core (by @adamsitnik ) 260704 update TraceEvent, port BenchmarkDotNet.Diagnostics.Windows to .NET Standard,... (by @adamsitnik ) 324973 remove .NET Core 1.1 support, update tests (by @adamsitnik ) 64d732 get it working (by @adamsitnik ) 54b829 remove .NET Core 1.1 from the CI jobs (by @adamsitnik ) ebf3d9 ups ;) (by @adamsitnik ) 42d9ae Merge branch 'master' into annotations (by @adamsitnik ) bc9975 cleanup (by @adamsitnik ) 96dd4f merge BenchmarkDotNet and BenchmarkDotNet.Core (by @adamsitnik ) 2dc21b group the benchmarks by runtime settings into partitions, #699 (by @adamsitnik ) fbb283 generate one .cs with all types inside, #699 (by @adamsitnik ) 334af2 build single exe, #699 (by @adamsitnik ) b958a1 run selected type from all types in exe #699 (by @adamsitnik ) 4f5714 polishing the code, #699 (by @adamsitnik ) 0c26a4 reverting some magic .sln change which has most probably broken the Travis bu... (by @adamsitnik ) c8a368 restore to a dedicated temp folder, rebuild only bare minumum, store everythi... (by @adamsitnik ) bd04bd better debugging experience (#699): when building only 1 thing at a time, pri... (by @adamsitnik ) fcf691 Improved local CoreCLR/CoreFX support, tested on all OSes #700, #702 (by @adamsitnik ) 7fbd6c allow the users to define an extra nuget feed, don't force clear tag for loca... (by @adamsitnik ) ad0fc8 Merge branch 'master' into v11 (by @adamsitnik ) 8070e4 Merge remote-tracking branch 'origin/master' into v11 (by @adamsitnik ) 0cccba post code review fixes, part of #175 (by @adamsitnik ) 4acc15 new Runtime and Toolchain for CoreRT, #718 (by @adamsitnik ) 657f05 don't use Expressions in Engine to avoid .NET Native compiler errors, #718 (by @adamsitnik ) 8c93cf the .NET Native compiler complained about some dependencies from referenced p... (by @adamsitnik ) c8ba5c If fail to build in Parallel due to file access issues, try to build sequenti... (by @adamsitnik ) 7173f7 CoreRT does not support reflection yet, so we need to target .NET Core 2.1 to... (by @adamsitnik ) 889270 trying to install Clang 3.9 for CoreRT tests purpose, #718 (by @adamsitnik ) 967167 code review fixes, #718 (by @adamsitnik ) 94863a Merge pull request #717 from dotnet/v11 (by @adamsitnik ) 448752 Improved docs for Disassembly Diagnoser (by @adamsitnik ) 600e5f add FromAssemblyAndTypes method to make it possible to auto-detect all benchm... (by @adamsitnik ) 289292 Allocated Memory must be scaled with OperationPerInvoke, fixes #724 (by @adamsitnik ) 1aa414 Actual Building Guide (by @Rizzen ) cfd9fa Merge pull request #727 from Rizzen/master (by @adamsitnik ) 7cfe09 Created Exporter and moved logic into (by @Rizzen ) b9ff75 Merge pull request #728 from Rizzen/BenchmarkReportExporter (by @adamsitnik ) adea8f support by ref Arguments (by @adamsitnik ) 0ecd7e ignore auto-generated files cleanup errors, #733 (by @adamsitnik ) cf5cd6 Handle missing Mono runtime more gracefully, fixes #734 (by @adamsitnik ) 49495f Remove unused usings (by @AndreyAkinshin ) 160516 Return value validator (#737), fixes #136 (by @ltrzesniewski ) 396f0a Follow up to #737 (#740) (by @ltrzesniewski ) 9dc4e8 Add .NET Framework 4.7.2 release number constant to GetCurrentVersionBasedOnW... (by @epeshk ) 06ff2d Update link to manual with .NET Framework version constants (by @epeshk ) f7d9ac Don't check Reference Assemblies folder existence for .NET Framework version ... (by @epeshk ) ebc1f6 Remove hardcoded Program Files directory location (by @epeshk ) 490304 Refactor framework version determining, extract logic from CsProjClassicNetTo... (by @epeshk ) cbea7e Fix Program Files path on x86 systems (by @epeshk ) 8071c8 ProgramFilesX86DirectoryPath field (by @epeshk ) f1d726 Merge pull request #743 from epeshk/frameworkVersion (by @AndreyAkinshin ) a36442 use HasValue instead of casting (by @epeshk ) c7efcc Merge pull request #746 from epeshk/frameworkVersion (by @adamsitnik ) 58f704 Give users nice warning when T in generic benchmark is not public, fixes #741 (by @Rizzen ) 66f958 when dotnet build --no-restore fails, try to run with restore (by @adamsitnik ) 52067c custom job Id should be preserved, fixes #749 (by @adamsitnik ) 24ec6e Very long string params/arguments should be trimmed, fixes #748 (by @adamsitnik ) b2e5b6 Params string containing characters like quotes is must be escaped properly, ... (by @adamsitnik ) 10865c Better docs that explain what is target/launch/iteration/invocation count by ... (by @adamsitnik ) 32ed86 Addition to #744: Using single variable instead of two (by @Rizzen ) f2a71f Merge pull request #750 from Rizzen/744_addition (by @adamsitnik ) eabfdd Update HowItWorks.md (by @Tornhoof ) 8fc754 Merge pull request #752 from Tornhoof/patch-1 (by @adamsitnik ) 2d79b6 Ability to pass multiple assemblies. (by @paulness ) ba07b0 Merge pull request #753 from paulness/feature-allow-multiple-assemblies-to-be... (by @adamsitnik ) d1b037 generate IParams for users in smart way (by @adamsitnik ) 4665ec Merge pull request #754 from dotnet/noIParam (by @adamsitnik ) 02c7c0 Generic Benchmark Attribute (#758), fixes #745 (by @Rizzen ) 7caf28 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (#757), f... (by @afmorris ) 449002 renamed Defined to Declared to keep consistency, renamed GenericBenchmark to ... (by @adamsitnik ) 8855a2 Jit runtime validation (#693) (by @morgan-kn ) 41614b stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (#761) (by @adamsitnik ) b0c251 Make MaxIterationCount configurable, keep current value as default, fixes #763 (by @adamsitnik ) 6f693e warn the users (once!) that if they run less than 15 iterations, the Multimod... (by @adamsitnik ) a9664f don't execute long operations more than once per iteration (#760), fixes #736 (by @adamsitnik ) 7e8448 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, ... (by @adamsitnik ) a40c75 explain the users why they did hit OOM, fixes #665, #368, #551 (by @adamsitnik ) e66bb0 arrays can be arguments and params, fixes #712 (by @adamsitnik ) 94b83e don't call IterationSetup and Cleanup for Idle, fixes #464 (by @adamsitnik ) 90f9ca Add .NET Core 2.2 support, fixes #765 (by @adamsitnik ) 132048 Better mValue formatting in MultimodalDistributionAnalyzer (by @AndreyAkinshin ) 5f08c2 Merge pull request #764 from dotnet/iterationSetupRunOnce (by @AndreyAkinshin ) 2b5dde Introduce OutlierMode (by @AndreyAkinshin ) 226716 OutliersAnalyserTests (by @AndreyAkinshin ) cabef0 support Jagged Arrays for ArgumentsSource, fixes #769 (by @adamsitnik ) 808a9d support generic by ref arguments with an ugly hack due to reflection limitati... (by @adamsitnik ) ea9f70 remove the ugly hack (by @adamsitnik ) cb4291 make it possible to use arrays of types with no public parameterless ctor (li... (by @adamsitnik ) 272e42 diassembly diagnoser: handle case where two different methods have same meta... (by @adamsitnik ) ea16d1 update preview dependencies to 4.5.0 (by @adamsitnik ) 97ddd6 Make it possible to use Span as benchmark argumen, fixes #774 (by @adamsitnik ) 4863be more generic solution for #774 (by @adamsitnik ) f63726 update build to use rc1 (to fix the build) (by @adamsitnik ) a38c70 make it possible to pass array(s) of reference types as arguments (by @adamsitnik ) 306adc use full Job type name to avoid naming conflicts, fixes #778 (by @adamsitnik ) e92c5b use DOTNET_MULTILEVEL_LOOKUP and IgnoreCorLibraryDuplicatedTypes to fix the... (by @adamsitnik ) 4e9844 Trimming the argument values makes them actually shorter #748 cc @ahsonkhan (by @adamsitnik ) 846d80 Merge branch 'master' of https://github.com/dotnet/BenchmarkDotNet (by @adamsitnik ) 3c3b47 have two main actions: with unroll and without, for no unroll icrease the ste... (by @adamsitnik ) 56f02c use full names in the auto-generated code to avoid possible conflicts (I just... (by @adamsitnik ) e75c44 Update documentations for WithOutlierMode (by @AndreyAkinshin ) 1840ae Merge pull request #766 from dotnet/outliers (by @AndreyAkinshin ) 5ae4bc Fixed BrandString support for Windows 10.0.17134 (by @AndreyAkinshin ) 4d6dfe BrandString support for macOS Mojave (by @AndreyAkinshin ) 426fbc Initial DocFX support, fixes #710 (by @AndreyAkinshin ) fe00d7 Merge pull request #781 from dotnet/docfx (by @AndreyAkinshin ) f0c06e Allow to pass string as ReadOnlySpan only for .NET Core 2.1 where the i... (by @adamsitnik ) bbe273 make netcoreapp2.1 default for .NET Core 2.1 + expose few things which are re... (by @adamsitnik ) bd22b3 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin ) 149e5e Merge pull request #783 from dotnet/docfx-samples (by @AndreyAkinshin ) 237e36 Flat namespace for BenchmarkDotNet.Attributes (by @AndreyAkinshin ) 24d2fe Remove obsolete namespaces in IntegrationTests (by @AndreyAkinshin ) cb25a7 docs: Visual Studio-like style for code snippets (by @AndreyAkinshin ) 914922 docs: add samples for baselines (by @AndreyAkinshin ) 159e85 docs: fix year in license (by @AndreyAkinshin ) 0b02d0 docs: add IntroEnvVars (by @AndreyAkinshin ) 4b0f38 Unicode support (#735) (by @Rizzen ) 971236 Unicode support: cleanup (by @AndreyAkinshin ) 7c43da CommonExtensions cleanup (by @AndreyAkinshin ) 04c0ad Fix link to rplot.png in README.md (by @AndreyAkinshin ) b16b83 docs: samples for setup and cleanup (by @AndreyAkinshin ) c05ac6 add link to inprocesstoolchain (#790) (by @IanKemp ) 44ea0f docs: add changelog (#789) (by @AndreyAkinshin ) 8a31aa docs: save changelog details for old versions in repo (by @AndreyAkinshin ) edd0a3 docs: customizing-runtime.md (by @AndreyAkinshin ) edf7f6 Improve filtering from console args (#785) (by @adamsitnik ) d9e18d a type can have no namespace (by @adamsitnik ) 4bbffe docs: update docfx version (by @AndreyAkinshin ) 52e769 Don't exclude allocation quantum side effects for .NET Core 2.0+, fixes #794 (by @adamsitnik ) 24f8da Cake targets for DocFX (by @AndreyAkinshin ) db0724 docs: add api/index.md (by @AndreyAkinshin ) 026c00 docs: statistics (by @AndreyAkinshin ) ae5baf docs: misc fixes (by @AndreyAkinshin ) fa5cf5 docs: multiversion combobox (by @AndreyAkinshin ) a49cf9 docs: add full contributor list (by @AndreyAkinshin ) 803686 always use FQDN to avoid any possible duplicates, #529 strikes back after a year (by @adamsitnik ) 315530 make sure DisassemblyDiagnoser output is exported, fixes bug introduced in #785 (by @adamsitnik ) 167476 docs: improved diagnosers.md (by @AndreyAkinshin ) b7f9aa docs: improved choosing-run-strategy (by @AndreyAkinshin ) 5da534 remove MultimodalDistributionAnalyzer hint introduced in #763 (by @adamsitnik ) 376339 Merge pull request #796 from dotnet/docs-versions (by @adamsitnik ) 57005f Extend exported json file with FullName using xunit naming convention for int... (by @adamsitnik ) 9c0a2e docs: improved exporters.md (by @AndreyAkinshin ) 22f553 docs: better sample generation (by @AndreyAkinshin ) 734635 docs: improved columns.md (by @AndreyAkinshin ) a82562 docs: improved configs.md (by @AndreyAkinshin ) e7a458 docs: InProcess samples (by @AndreyAkinshin ) 602562 docs: imrpovded order-providers.md (by @AndreyAkinshin ) 8576c5 docs: fix the rest of WithoutDocs samples (by @AndreyAkinshin ) 13b44e docs: rename changelog-generator to _changelog (by @AndreyAkinshin ) 9a9648 docs: fix link to InProcessToolchain (by @AndreyAkinshin ) 5716c1 escape tabs and enters in the exported benchmark id (to keep it in sync with ... (by @adamsitnik ) 4be9bf MemoryDiagnoser handles IterationSetup and Cleanup since #606, removing old i... (by @adamsitnik ) f92532 add --job=core to command line arguments, fixes #793 (by @adamsitnik ) 1c656d update the docs with the change in IterationSetup behavior, #764 (by @adamsitnik ) 6fd39b job Mutators (#800)fixes #713 (by @adamsitnik ) 8954dc Rename: OrderProvider -> Orderer (#787) (by @AndreyAkinshin ) 7b47c6 Rename: Benchmark -> BenchmarkCase (#787) (by @AndreyAkinshin ) cc6f1b Rename: Target -> Descriptor (#787) (by @AndreyAkinshin ) 17bb68 Rename: EnvMode -> EnvironmentMode (#787) (by @AndreyAkinshin ) 73a6cc Rename: Infrastructure.EnvironmentVariables -> Environment.EnvironmentVariabl... (by @AndreyAkinshin ) 6118f1 Huge IterationMode renaming (#787) (by @AndreyAkinshin ) 035452 Handle super narrow distributions in AdaptiveHistogramBuilder, fixes #802 (by @AndreyAkinshin ) b705b3 print Processor Affinity as a bitmask in the summary (by @adamsitnik ) 0db126 fix MacOs build where the default affinity is 0 or we can't read it for some ... (by @adamsitnik ) 5e6e33 make sure the characteristic names match the properties names + rename Target... (by @adamsitnik ) f4cd0d Baseline improvements (#787) (by @AndreyAkinshin ) 124a52 Fix tests (#787) (by @AndreyAkinshin ) e8bf99 fix mac test, make sure IsMutator does not flow to applied job (by @adamsitnik ) 95750c Make it possible to configure Min and Max Warmup Iteration Count, fixes #809 (by @adamsitnik ) 99e753 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .N... (by @adamsitnik ) 62e75c docs: update articles/contributing/documentation (by @AndreyAkinshin ) 41c5f9 Cake: update DocFX (2.36.2->2.37) (by @AndreyAkinshin ) e4b37c Cake: update .NET Core SDK (2.1.300-rc1-008673->2.1.300) (by @AndreyAkinshin ) ad1645 Cpu info improvement (#799) (by @Rizzen ) 61e95e [Params] exported to json should be delimited by \", \" #701 (by @adamsitnik ) 4cd1df handle the types as arguments to match xunit naming convention for porting pu... (by @adamsitnik ) ff6613 for type parameters we should display non-trimmed type name without namespace... (by @adamsitnik ) 89f195 explain how we measure GC stats in the docs, fixes #811 (by @adamsitnik ) c7731c Arguments should be passed to asynchronous benchmarks, fixes #818 (by @adamsitnik ) 0f9c48 add info about Min/Max counts to docs (by @adamsitnik ) 33e568 fix MemoryDiagnoserTests issues, fixes #813 (by @adamsitnik ) 844e95 set DOTNET_MULTILEVEL_LOOKUP=0 to get customDotNetCli path working, fixes #820 (by @adamsitnik ) 7e2d54 if iteration cleanup is provided, the benchmark should be executed once per i... (by @adamsitnik ) 2132d0 allow to set summary style in fluent way (by @adamsitnik ) dfea69 allow to set multuple targets for attributes without string concatenation, fi... (by @adamsitnik ) 6267b2 Use 3rd party lib for console args parsing + support globs for filtering (#824) (by @adamsitnik ) 9c269f make sure the generic type arguments are displayed in the summary, not `1 (by @adamsitnik ) c7d0b9 don't duplicate the jobs when parsing config (by @adamsitnik ) d7825e show generic type name in a joined summary (by @adamsitnik ) 528c9c make sure the config parsing and job merging works as expected (by @adamsitnik ) a7426e LLVM support in MonoDisassembler (by @AndreyAkinshin ) c724e9 Fix typos (by @AndreyAkinshin ) cdbb37 allow to filter benchmarks by simple type name, fixes #827 (by @adamsitnik ) eac833 Read StandardOutput in a smart way to avoid infinite loops (#830), #828 (by @houseofcat ) a298c2 Error message for wrong command line filter, fixes #829 (by @adamsitnik ) a7ecda initial release notes (#833) (by @adamsitnik ) 36bf7c Rename: General -> Actual (#787) (by @AndreyAkinshin ) a1ec4b Add _changelog/details/v0.11.0.md (by @AndreyAkinshin ) 558cae Improved docs for v0.11.0 (by @AndreyAkinshin ) e45f69 docs: update main.js (by @AndreyAkinshin ) 53e576 Update links to docs in README (by @AndreyAkinshin ) 3a8990 update links in docs/index.md (by @AndreyAkinshin ) 5ad710 Repair obsolete logo link (by @AndreyAkinshin ) e38afb Cake: update DocFX (2.37->2.37.1) (by @AndreyAkinshin ) 5b8f91 docs: add analytics scripts in template (by @AndreyAkinshin ) 3ec8f7 docs: add redirects to v0.10.14 (by @AndreyAkinshin ) a00bf6 docs: update how-it-works (by @AndreyAkinshin ) 73980e docs: add redirect for index.htm (by @AndreyAkinshin ) fad583 docs: update changelog for v0.11.0 (by @AndreyAkinshin ) 74d552 Update list of NuGet packages in changelog/footer/v0.11.0 (by @AndreyAkinshin ) 74084f Set library version: 0.11.0 (by @AndreyAkinshin ) Contributors (11) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Evgeny Peshkov ( @epeshk ) Ian Kemp ( @IanKemp ) Irina Ananeva ( @morgan-kn ) Lucas Trzesniewski ( @ltrzesniewski ) Mark Tkachenko ( @Rizzen ) Paul Ness ( @paulness ) Stefan ( @Tornhoof ) Tony Morris ( @afmorris ) Tristan (HouseCat) Hyams ( @houseofcat ) Thank you very much! Additional details Date: July 23, 2018 Milestone: v0.11.0 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0 BenchmarkDotNet v0.10.14 Per-method parameterization ( Read more ) Console histograms and multimodal disribution detection Many improvements for Mono disassembly support on Windows ( Read more ) Many bugfixes Milestone details In the v0.10.14 scope, 8 issues were resolved and 11 pull requests were merged. This release includes 47 commits by 8 contributors. Resolved issues (8) #256 Per-method parameterization (assignee: @AndreyAkinshin ) #429 Detect multimodal distributions (assignee: @AndreyAkinshin ) #496 Integration with TravisCI (assignee: @jongalloway ) #684 Horology.ClockTests.ChronometerTest fails on Travis CI (macOS) (assignee: @AndreyAkinshin ) #689 DisassemblyDiagnoser for Mono does not work on Windows and Linux (assignee: @morgan-kn ) #691 Cannot run F# benchmarks when benchmark returns F# generic (assignee: @adamsitnik ) #697 Copy custom setting from app.config in multitarget projects (assignee: @adamsitnik ) #706 Support private builds of .NET Runtime (assignee: @adamsitnik ) Merged pull requests (11) #577 Arguments (by @adamsitnik ) #647 Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin ) #674 Cleanup suggested by VS2017 Code Analysis (plus one typo) (by @shoelzer ) #675 Fix IDE0034: 'default' expression can be simplified (by @shoelzer ) #676 Correct NodeTime text which links to NodaTime api (by @MishaHusiuk ) #681 Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) #682 Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) #683 Integration with TravisCI (by @Ky7m ) #694 Fix 689 (by @morgan-kn ) #695 Rename Program to UniqueProgramName to avoid conflicts, fixes #691 (by @adamsitnik ) #696 Build system: Update dotnet SDK and dotnet runtime. Enable FastTests netcoreapp1.1 on non-Windows. (by @Ky7m ) Commits (47) 41aeea Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin ) 960e58 Handle measurements with zero operations (by @AndreyAkinshin ) 19cddd Fix typo in BaselineScaledColumn.cs (by @dfederm ) a99594 Merge pull request #673 from dfederm/dfederm/fix-typo (by @AndreyAkinshin ) 5b3425 Cleanup suggested by VS2017 Code Analysis (plus one typo) (#674) (by @shoelzer ) 16b611 Fix IDE0034: 'default' expression can be simplified (by @shoelzer ) 048b32 Merge pull request #675 from shoelzer/master (by @AndreyAkinshin ) 9d5f71 Correct NodeTime text which links to NodaTime lib (by @MishaHusiuk ) c450c7 Merge pull request #676 from MishaHusiuk/patch-1 (by @adamsitnik ) 9fad52 Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) 3d906f Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) d1a48e Merge pull request #681 from dmitry-ra/master (by @AndreyAkinshin ) 4ccd35 Merge pull request #682 from dmitry-ra/patch-1 (by @AndreyAkinshin ) f743a1 CakeBuild 0.24.0 -> 0.26.1 (by @Ky7m ) c5eb40 Remove postProjects from solution file. (by @Ky7m ) e60387 Pass correct configuration to test settings (by @Ky7m ) 224ab8 Disable public sign option for F# project (by @Ky7m ) ee98f3 Limit Max CPU count for msbuild workers (by @Ky7m ) 17031d Fix readme file (by @Ky7m ) 6fbae8 One more update to readme file (by @Ky7m ) cb90f2 disable Travis failing test #684 to unblock #683 (by @adamsitnik ) 782ca7 Merge pull request #683 from Ky7m/Integration-with-TravisCI (by @adamsitnik ) eebf92 Merge branch 'master' into multimodal (by @adamsitnik ) 10511b Merge pull request #647 from dotnet/multimodal (by @adamsitnik ) 57bc17 Fix bug in ClockTests.ChronometerTest, fixes #684 (by @AndreyAkinshin ) 7c4b14 Arguments (#577), fixes #256 (by @adamsitnik ) 40771c Update dotnet SDK (2.1.4 -> 2.1.101) and dotnet runtime (1.1.6 -> 1.1.7). (by @Ky7m ) 88a9db Merge pull request #696 from Ky7m/build-runtime-update (by @adamsitnik ) 4ac6ad we need different name than typical \"Program\" to avoid problems with referenc... (by @adamsitnik ) 1178d6 Update build badges (by @AndreyAkinshin ) 24ed1f ProcessHelper: handle null Data values in OutputDataReceived, fix #689 (by @morgan-kn ) 7a3d2b MonoDisassembler improvements (by @morgan-kn ) f1a0f5 Merge pull request #694 from morgan-kn/Fix689 (by @AndreyAkinshin ) 428905 .NET Core apps are .dlls (not .exes), fixes #697 (by @adamsitnik ) befbc8 Add FAQ notes about #692 (by @AndreyAkinshin ) b4504b Support private builds of .NET Runtime, fixes #706 (by @adamsitnik ) c93e1e Introduce separate logic for Windows10 brand strings (by @AndreyAkinshin ) 685766 Shortify Windows 10 brand strings in the summary (by @AndreyAkinshin ) 9bdd0c Shortify cpu info in summary (by @AndreyAkinshin ) 2288ad Prettify macOS brand string (by @AndreyAkinshin ) 8a0b48 Handle tailed nop instructions in mono disasm output (by @AndreyAkinshin ) d80834 Advanced DryJob attributes (by @AndreyAkinshin ) 9a37ad Handle invalid mono disasm outputs (by @AndreyAkinshin ) 21d6d7 Add IntroDisasm (by @AndreyAkinshin ) 5e37b5 Add \"Disassembly Diagnoser for Mono on Windows\" in docs (by @AndreyAkinshin ) c2c4e8 set COMPLUS_Version env var for private Clr builds even if no env vars were d... (by @adamsitnik ) 88b088 Set library version: 0.10.14 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) David Federman ( @dfederm ) Dmitry Razumikhin ( @dmitry-ra ) Igor Fesenko ( @Ky7m ) Irina Ananeva ( @morgan-kn ) MishaHusiuk ( @MishaHusiuk ) Steve Hoelzer ( @shoelzer ) Thank you very much! Additional details Date: April 09, 2018 Milestone: v0.10.14 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.14 BenchmarkDotNet v0.10.13 Overview post: BenchmarkDotNet v0.10.13 Milestone details In the v0.10.13 scope, 15 issues were resolved and 9 pull requests were merged. This release includes 50 commits by 8 contributors. Resolved issues (15) #541 Mono Support for DisassemblyDiagnoser (assignee: @morgan-kn ) #614 Build fails with \"'Microsoft.NETCore.App', version '1.1.2' was not found\" probably due to 1.1.4 runtime not being available #626 Support Visual Basic project files (.vbroj) targeting .NET Core (assignee: @adamsitnik ) #630 Bug: Statistics.DivMean - NullReferenceException (assignee: @AndreyAkinshin ) #631 Bug: Generic benchmark class fails for DisassemblyDiagnoser with \"Sequence contains no matching element\" (assignee: @adamsitnik ) #632 ParamsSource no longer sorted in results (assignee: @AndreyAkinshin ) #634 Extend SummaryOrderPolicy (assignee: @adamsitnik ) #636 Unable to run Runner.exe --method MethodName (assignee: @adamsitnik ) #640 Disassembler fails with generic instance (assignee: @adamsitnik ) #643 BenchmarkDotNet should respect LangVersion project setting (assignee: @adamsitnik ) #644 BenchmarkDotNet.Mathematics.RankHelper again. (assignee: @AndreyAkinshin ) #648 BenchmarkDotNet requires dotnet cli toolchain to be installed (assignee: @adamsitnik ) #651 Support ANY CoreFX and CoreCLR builds (assignee: @adamsitnik ) #652 BenchmarkSwitcher should support generic types with parameterless public ctors (assignee: @adamsitnik ) #653 Proper way to run BenchmarkDotNet on macOS/Linux (assignee: @adamsitnik ) Merged pull requests (9) #624 Upgrade build tools (by @Ky7m ) #625 Fix xunit warnings connected to usage of Assert.Equal() to check for Null (by @Ky7m ) #633 HostEnvironmentInfo: remove LogicalCoreCount (by @morgan-kn ) #637 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn ) #639 Portability.Cpu tests improvements (by @morgan-kn ) #642 sync DataContracts to CopiedDataContracts (by @morgan-kn ) #645 Fixing --help display for options (by @ENikS ) #646 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAttribute (by @ENikS ) #666 Plots...Examples...Added A config example in F# (by @ScottHutchinson ) Commits (50) a26e82 Upgrade build tools: (by @Ky7m ) 1643cb Merge pull request #624 from Ky7m/upgrade-build-tools (by @adamsitnik ) abae51 Fix xunit warnings connected to usage of Assert.Equal() to check for null val... (by @Ky7m ) fb68bc support Visual Basic .NET Core projects, fixes #626 (by @adamsitnik ) 067a33 Remove redundant properties in common.props (by @AndreyAkinshin ) 80deb9 BuildNumber fix in common.props (by @AndreyAkinshin ) 87b458 Add CONTRIBUTING.md (by @AndreyAkinshin ) 8bcf42 Add CODE_OF_CONDUCT.md (by @AndreyAkinshin ) d3867d HostEnvironmentInfo: remove LogicalCoreCount (#633) (by @morgan-kn ) 06e66a Specify PLACE_SIMPLE_EMBEDDED_STATEMENT_ON_SAME_LINE in DotSettings (by @AndreyAkinshin ) d8ac43 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn ) 4356da Merge pull request #637 from morgan-kn/MonoSupportForDisassemblyDiagnoser (by @AndreyAkinshin ) 7572f4 Fix paths to images in docs (by @AndreyAkinshin ) f076df Portability.Cpu tests improvements (by morgan_kn) da6499 Merge pull request #639 from morgan-kn/TestsImprovment (by @AndreyAkinshin ) 5dd1a5 Disassembly Diagnoser: support for generic types, fixes #640 fixes #631 (by @adamsitnik ) 3c0e71 diassembly diangoser: different methods can have same metadata id, add type i... (by @adamsitnik ) 294801 test fix ;) (by @adamsitnik ) 9e66bb sync DataContracts to CopiedDataContracts (by @morgan-kn ) 690f34 Merge pull request #642 from morgan-kn/sync (by @adamsitnik ) e1e3e2 don't use type.Fullname for file names, it's too long for generics (by @adamsitnik ) 43d7c2 we restore before build, so build does need to restore too (it's new default ... (by @adamsitnik ) 9d4c33 trying harder to trick the JIT (#640, #631) (by @adamsitnik ) f8f70f Natural ordering for logical groups, fixes #632 (by @AndreyAkinshin ) a2ec34 copy LanguageVersion to the output .csproj, fixes #643 (by @adamsitnik ) 31e6dd Fixing --help display for options (#645), fixes #636 (by @ENikS ) 45ace9 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAtt... (by @ENikS ) 8811f2 Fix typo in docs/guide/Contributing/Disassembler.md (by @AndreyAkinshin ) 7da7b9 allow the users to customize Artifacts Path, #377 (by @adamsitnik ) 7554bf validate CustomDotNetCliPath, fixes #648 (by @adamsitnik ) 683964 Support ANY CoreFX and CoreCLR builds, fixes #651 (by @adamsitnik ) 695386 support also only custom CoreFX scenario (default runtime), part of #651 (by @adamsitnik ) eb4dcf allow the users to copy some files after the publish, part of #651 (by @adamsitnik ) b076a3 Add Newtonsoft.Json in the README (by @AndreyAkinshin ) b4eef5 better generics support, fixes #652 (by @adamsitnik ) 77fd46 Handle null values in Statistics.DivMean and Statistics.DivVariance, fixes #630 (by @AndreyAkinshin ) e547f8 Fix NRE in RankColumn, fixes #644 (by @AndreyAkinshin ) 28aa94 allow the users to choose .NET 4.7.1 (by @adamsitnik ) 503570 Fixed image link (by @svick ) 93cc85 Merge pull request #655 from svick/patch-1 (by @adamsitnik ) d33cde Fixed code block formatting (by @svick ) cb7c09 Merge pull request #657 from svick/patch-1 (by @adamsitnik ) 650b4a host Mono process should be able to build .NET Core child process, fixes #653 (by @adamsitnik ) d1dcab List formatting for FAQ (by @svick ) fe52e3 Merge pull request #663 from svick/faq-formatting (by @adamsitnik ) 7792cb Example in F#: with corrected code formatting (by @ScottHutchinson ) e6b225 Merge pull request #666 from ScottHutchinson/patch-2 (by @AndreyAkinshin ) f90207 Allow restore and build command override (#670) (by @BonnieSoftware ) 4443cd Update example in README (by @AndreyAkinshin ) de0b68 Set library version: 0.10.13 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) BonnieSoftware ( @BonnieSoftware ) Eugene Sadovoi ( @ENikS ) Igor Fesenko ( @Ky7m ) Irina Ananeva ( @morgan-kn ) Petr Onderka ( @svick ) Scott Hutchinson ( @ScottHutchinson ) Thank you very much! Additional details Date: March 02, 2018 Milestone: v0.10.13 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.13 BenchmarkDotNet v0.10.12 Overview post: BenchmarkDotNet v0.10.12 Highlights Improved DisassemblyDiagnoser: BenchmarkDotNet contains an embedded disassembler so that it can print assembly code for all benchmarks; it's not easy, but the disassembler evolves in every release. Improved MemoryDiagnoser: it has a better precision level, and it takes less time to evaluate memory allocations in a benchmark. New TailCallDiagnoser: now you get notifications when JIT applies the tail call optimizations to your methods. Better environment info: when your share performance results, it's very important to share information about your environment. The library generates the environment summary for you by default. Now it contains information about the amount of physical CPU, physical cores, and logic cores. If you run a benchmark on a virtual machine, you will get the name of the hypervisor (e.g., Hyper-V, VMware, or VirtualBox). Better summary table: one of the greatest features of BenchmarkDotNet is the summary table. It shows all important information about results in a compact and understandable form. Now it has better customization options: you can display relative performance of different environments (e.g., compare .NET Framework and .NET Core) and group benchmarks by categories. Milestone details In the v0.10.12 scope, 15 issues were resolved and 10 pull requests were merged. This release includes 42 commits by 9 contributors. Resolved issues (15) #273 Create a tail call diagnoser #442 Is it possible to configure benchmark to assign rank for runtime? (assignee: @AndreyAkinshin ) #543 Run Disassembly Diagnoser without extra run (assignee: @adamsitnik ) #546 Synthesizing labels for jump targets (assignee: @adamsitnik ) #574 Display VM hypervisor in summary section (assignee: @lukasz-pyrzyk ) #582 Print amount of logical and physical core (assignee: @morgan-kn ) #599 Proper HTML escaping of BenchmarkAttribute Description #606 Improve Memory Diagnoser (assignee: @adamsitnik ) #608 Properly escaping generated markdown (assignee: @AndreyAkinshin ) #612 Disassembler DisassembleMethod fails with \"Object reference not set to an instance of an object.\", (assignee: @adamsitnik ) #617 Allow baseline per category (assignee: @AndreyAkinshin ) #618 Enable ApprovalTests in .NET Core 2.0 tests (assignee: @AndreyAkinshin ) #621 Try to search for missing references if build fails (assignee: @adamsitnik ) #622 Support of new GC settings (assignee: @adamsitnik ) #623 RPlotExporter uses wrong path to csv measurements (assignee: @AndreyAkinshin ) Merged pull requests (10) #573 Сreate a tail call diagnoser (by @GeorgePlotnikov ) #576 Display VM name in summary section, fixes #574 (by @lukasz-pyrzyk ) #595 Migrate all project to new project system. (by @mfilippov ) #598 Added info about the new TailCallDiagnoser (by @GeorgePlotnikov ) #603 Fix HTML Encoding for Html Exporter (by @Chrisgozd ) #605 Grammar (by @onionhammer ) #607 Print amount of logical and physical core #582 (by @morgan-kn ) #615 Quick fix Disassembler.Program.GetMethod when more than one method found just return null (by @nietras ) #619 Logical group support, fixes #617 (by @AndreyAkinshin ) #620 New README.md (by @AndreyAkinshin ) Commits (42) 6f587d Migrate all project to new project system. (by @mfilippov ) 47ba57 added info about the new TailCallDiagnoser (by @GeorgePlotnikov ) c1a4b2 Сreate a tail call diagnoser (#573) (by @GeorgePlotnikov ) ebe3e2 Merge pull request #598 from GeorgePlotnikov/patch-1 (by @adamsitnik ) 6249f0 some polishing of the JIT diagnosers (by @adamsitnik ) 119231 Fix HTML Encoding for Html Exporter (#603), fixes #599 (by @Chrisgozd ) fe3f30 Disassembly Prettifier, fixes #546 (by @adamsitnik ) 3eb63f Merge pull request #595 from mfilippov/new-fs-vb-proj (by @adamsitnik ) 16d03f make our F# samples work for .NET Core 2.0 (by @adamsitnik ) d06de7 bring back our old Visual Basic and F# integration tests (by @adamsitnik ) 63249b \"Kaby Lake R\" and \"Coffee Lake\" support in ProcessorBrandStringHelper (by @AndreyAkinshin ) a8a09e disassembly prettifier: highlighting references to labels, jumping to next on... (by @adamsitnik ) e6d747 Grammar (by @onionhammer ) fef4aa Merge pull request #605 from onionhammer/patch-1 (by @adamsitnik ) ffacd7 don't require extra run for DisassemblyDiagnoser, fixes #543, #542 (by @adamsitnik ) bcac26 revert last commit change (run global setup regardless of Jitting) (by @adamsitnik ) 3e87d8 don't perform an extra run to get GC stats for .NET Core, part of #550 (by @adamsitnik ) f87dbc obtain GC stats in separate iteration run, no overhead, support for iteration... (by @adamsitnik ) e5fe0f update to C# 7.1 so we can use all the latest features (by @adamsitnik ) bc50b2 build benchmarks in Parallel, part of #550 (by @adamsitnik ) e59590 Display VM name in summary section, fixes #574 (#576) (by @lukasz-pyrzyk ) 8908f8 fix GetMethod (by @nietras ) 4ca82d Merge pull request #615 from nietras/disassembler-more-than-one-method-fix (by @adamsitnik ) 387ae5 be more defensive when trying to read source code with disassembler, part of ... (by @adamsitnik ) 703815 docs: how to contribute to disassembler (by @adamsitnik ) 242671 Enable ApprovalTests in .NET Core 2.0 tests, fixes #618 (by @AndreyAkinshin ) c4d21b Print amount of logical and physical core #582 (#607) (by @morgan-kn ) e33e84 Add HtmlReady dialect for MarkdownExporter, fixes #608 (by @AndreyAkinshin ) cf167b Enable html escaping for GitHub markdown dialect, fixes #608 (by @AndreyAkinshin ) 8bb28b Logical group support, fixes #617 (by @AndreyAkinshin ) ae87c6 Merge pull request #619 from dotnet/logical-groups (by @adamsitnik ) 14e90b parallel build post fix: don't write the compilation errors to NullLogger, re... (by @adamsitnik ) db4ae8 Try to search for missing references if build fails, fixes #621 (by @adamsitnik ) 0eba0f Support of new GC settings, fixes #622 (by @adamsitnik ) e31b2d Revert Samples/Program.cs (by @AndreyAkinshin ) 7f126b Add logs in RPlotExporter (by @AndreyAkinshin ) f8a447 Fix path to csv in RPlotExporter, fixes #623 (by @AndreyAkinshin ) 273f50 New plots in RPlotExporter (by @AndreyAkinshin ) f293f0 New README.md (#620) (by @AndreyAkinshin ) 5e3366 Update copyright year in docs (by @AndreyAkinshin ) ab7458 Update index in docs (by @AndreyAkinshin ) 4616d4 Set library version: 0.10.12 (by @AndreyAkinshin ) Contributors (9) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Christopher Gozdziewski ( @Chrisgozd ) Erik O'Leary ( @onionhammer ) George Plotnikov ( @GeorgePlotnikov ) Irina Ananeva ( @morgan-kn ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) Mikhail Filippov ( @mfilippov ) nietras ( @nietras ) Thank you very much! Additional details Date: January 15, 2018 Milestone: v0.10.12 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.12 BenchmarkDotNet v0.10.11 Highlights ByRef and Stack-only support ( #492 , sample ) .NET Core 2.1 support ( #587 ) Improved LINQPad support Smart logic for precision in ScaledColumn ( #509 , #590 ) Better macOS version detection ( 15d72388 ) Minor fixes and improvements Milestone details In the v0.10.11 scope, 6 issues were resolved and 8 pull requests were merged. This release includes 18 commits by 8 contributors. Resolved issues (6) #509 Better formatting for the Scaled column #579 Improve error message about non-optimized dependencies (assignee: @adamsitnik ) #580 How to get benchmarks running from LINQPad? (assignee: @adamsitnik ) #587 Support netcoreapp2.1 (assignee: @eerhardt ) #588 Broken appveyor build #593 BenchmarkDotNet is not working with LinqPad (assignee: @adamsitnik ) Merged pull requests (8) #492 ByRef and Stack-only support (by @adamsitnik ) #575 xUnit runner upgrade and small tests refactoring (by @Ky7m ) #584 Fixed typo. (by @cincuranet ) #589 Add support for netcoreapp2.1 (by @eerhardt ) #590 Add precision to Scaled Column (by @Chrisgozd ) #591 Fix CI build (by @Ky7m ) #592 Removed a xunit workaround because an issue has been fixed (by @AlekseiKudelia ) #597 Fix typo in WithCustomBuildConfiguration API (by @benjamin-hodgson ) Commits (18) 2a2e6c ByRef and Stack-only support (#492) (by @adamsitnik ) 676c77 xUnit runner upgrade and small tests refactoring (#575) (by @Ky7m ) 7a89cd Fixed typo. (by @cincuranet ) dd28b2 add better error text for non-optimized dlls + add it to FAQ, fixes #579 (by @adamsitnik ) 67e659 detect LINQPad problems and tell the user how to change them, fixes #580 (by @adamsitnik ) 543bd6 don't warn about non-optimized LINQPad dependency (it's OK), #580 (by @adamsitnik ) 8a94f2 Add support for netcoreapp2.1 (by @eerhardt ) fb39db Merge pull request #589 from eerhardt/SupportNetCoreApp21 (by @adamsitnik ) ef11f0 Add CoverageFilterXml in DotSettings (by @AndreyAkinshin ) 962b6a Update DotSetttings (by @AndreyAkinshin ) 717b62 BenchmarkDotNet.Horology cleanup (by @AndreyAkinshin ) d1720b Upgrade version to 2.0.3 and explicitly specify fx version for .netcoreapp2.0 (by @Ky7m ) 94d47a Removed a xunit workaround because an issue has been fixed (by @AlekseiKudelia ) 15d723 More details in GetOsVersion on macOS (by @AndreyAkinshin ) 696f89 Add precision to Scaled Column (#590) (by @Chrisgozd ) e54924 Fix typo in WithCustomBuildConfiguration API (by @benjamin-hodgson ) 8de978 Merge pull request #597 from benjamin-hodgson/patch-1 (by @adamsitnik ) af1510 Set library version: 0.10.11 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) AlekseiKudelia ( @AlekseiKudelia ) Andrey Akinshin ( @AndreyAkinshin ) Benjamin Hodgson ( @benjamin-hodgson ) Christopher Gozdziewski ( @Chrisgozd ) Eric Erhardt ( @eerhardt ) Igor Fesenko ( @Ky7m ) Jiri Cincura ↹ ( @cincuranet ) Thank you very much! Additional details Date: December 01, 2017 Milestone: v0.10.11 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.11 BenchmarkDotNet v0.10.10 Highlights: Disassembly Diagnoser (read more here: Disassembling .NET Code with BenchmarkDotNet ) ParamsSources .NET Core x86 support Environment variables and Mono args support Better environment description More: additional sections in the documentation, bug fixes, build script improvements, internal refactoring. Overview post: BenchmarkDotNet v0.10.10 Milestone details In the v0.10.10 scope, 34 issues were resolved and 18 pull requests were merged. This release includes 95 commits by 11 contributors. Resolved issues (34) #160 Make ClrMd Source diagnoser working with new ClrMD api (assignee: @adamsitnik ) #167 Detect virtual machine environment (assignee: @lukasz-pyrzyk ) #262 Runtime knobs (assignee: @adamsitnik ) #310 Support 32bit benchmarks for .NET Core (assignee: @adamsitnik ) #350 ParamsSource (assignee: @adamsitnik ) #437 Add DisassemblyDiagnoser for outputting disassembled JITed code. (assignee: @adamsitnik ) #466 MSBuild parameters are not passed to generated benchmark project (assignee: @adamsitnik ) #495 Attributes put on base methods are not considered in derived class (assignee: @lukasz-pyrzyk ) #500 Borken compilation for net46 projects when .NET Framework 4.7 is installed (assignee: @adamsitnik ) #505 JsonExporterBase doesn't include MemoryDiagnoser stats in output #511 [bug] Bug in GetTargetedMatchingMethod() logic #513 IterationSetup not run in Job.InProcess #516 Get a compilation error \"CS1009: Unrecognized escape sequence\" when using verbatim strings #519 BenchmarkSwitcher.RunAllJoined throws InvalidOperationException (assignee: @AndreyAkinshin ) #526 Remove project.json support (assignee: @adamsitnik ) #529 No namespace in export filenames can lead to data loss #530 Build error on Appveyor with recent changes. #533 When I clone, build, and run BenchmarkDotNet.Samples I get an error #534 Allow the users to compare 32 vs 64 RyuJit for .NET Core (assignee: @adamsitnik ) #535 No way to set RuntimeFrameworkVersion in multiple-version config (assignee: @adamsitnik ) #536 Strange disassembly ordering/truncation (assignee: @adamsitnik ) #537 Can't benchmark a netstandard2.0 project (assignee: @adamsitnik ) #538 Duplicate using causing benchmark not to work (assignee: @adamsitnik ) #539 Target .NET Core 2.0 to take advantage of the new APIs (assignee: @adamsitnik ) #540 Artifacts for disassembler projects (assignee: @adamsitnik ) #542 Problems with Disassembler + Job.Dry (assignee: @adamsitnik ) #555 Test \"CanDisassembleAllMethodCalls\" fails on Ubuntu (assignee: @adamsitnik ) #556 Table in report is broken in VSCode markdown viewer (assignee: @adamsitnik ) #558 Warn the users when running Benchmarks from xUnit with shadow copy enabled (assignee: @adamsitnik ) #559 DissassemblyDiagnoser jit/arch info seems to be wrong (assignee: @adamsitnik ) #561 Strange behaviour when benchmark project is build in debug mode (assignee: @adamsitnik ) #562 DisassemblyDiagnoser crashes on overloaded benchmark (assignee: @adamsitnik ) #564 [Bug] Benchmarking a method doesn't run global setup when filter is applied (assignee: @adamsitnik ) #571 Allow users to use non compile-time constants as Parameters (assignee: @adamsitnik ) Merged pull requests (18) #507 Fix a typo in Jobs.md (by @aidmsu ) #508 Fixed some typos and grammar (by @lukasz-pyrzyk ) #512 Warning about antivirus software after benchmark failure (by @lukasz-pyrzyk ) #514 #495 - Unit test for reading attributes from the base class (by @lukasz-pyrzyk ) #515 Fix #513 - IterationSetup not run in Job.InProcess (by @ig-sinicyn ) #518 Fixed information about MemoryDiagnoser. (by @cincuranet ) #520 XML Exporter documentation and samples (by @Teknikaali ) #525 adding validator for setup cleanup attributes (by @ipjohnson ) #527 Detecting virtual machine hypervisor, #167 (by @lukasz-pyrzyk ) #531 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m ) #532 Fix type of local in EmitInvokeMultipleBody (by @pentp ) #547 Fix markdown headers (by @jawn ) #548 Fix condition in package reference list and update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system (by @Ky7m ) #549 Project files cleanup (by @Ky7m ) #552 Fix exporters to use fully qualified filenames (by @Teknikaali ) #563 Remove leading space character in a MD table row, #556 (by @rolshevsky ) #565 Single point of full config creation (by @ig-sinicyn ) #569 Update cakebuild scripts (by @Ky7m ) Commits (95) 682820 Fix typo in Jobs.md (by @aidmsu ) e82a8b Fixed some typos and grammar (by @lukasz-pyrzyk ) a0e9b9 Disassembly Diagnoser: displaying ASM, IL and C# for any JIT (by @adamsitnik ) 57e0f0 recursive disassembling (by @adamsitnik ) 1975ae return structured results from Disassembler (by @adamsitnik ) 9ae365 Warning about antivirus software after benchmark failure (#512) (by @lukasz-pyrzyk ) 74b41e Unit test for reading attributes from the base class, fixes #495 (by @lukasz-pyrzyk ) 3bab2d Fix #513 - IterationSetup not run in Job.InProcess (#515) (by @ig-sinicyn ) 769a39 use the IL instructions to detect more calls (by @adamsitnik ) b69537 use InstructionPointer to combine asm with hardware counters (by @adamsitnik ) 200244 Fixed information about MemoryDiagnoser. (by Jiri Cincura) 848a1a handling the lovely edge cases (Cecil vs ClrMD differences in naming types an... (by @adamsitnik ) 40049b single text representation of asm is a range of IPs! (by @adamsitnik ) 56e252 XML Exporter documentation and samples (#520) (by @Teknikaali ) c18597 eliminate duplicates (ClrMD fault), be more defensive for edge cases (by @adamsitnik ) a9262f allow the users to specify recursive depth limit (50MB output for simple lock... (by @adamsitnik ) fbe329 Support params which include slashes, fixes #516 (by @AndreyAkinshin ) f2b9c0 Fix RunAllJoined, fixes #519 (by @AndreyAkinshin ) 983764 UX ;) (by @adamsitnik ) c010de adding validator for setup cleanup attributes (by @ipjohnson ) 424723 Merge pull request #525 from ipjohnson/master (by @adamsitnik ) 7b680a prefer unit tests over integration tests if possible (by @adamsitnik ) 93dc6e Remove project.json support, fixes #526 (by @adamsitnik ) 19f22b Merge pull request #518 from cincuranet/docs (by @adamsitnik ) fe2db1 configurable, runtime specific diagnosers, hard part transparent to end users (by @adamsitnik ) fb60e5 disassembly diagnoser for Mono (by @adamsitnik ) 55ce0d smart diagnoser can choose the right disassembler (by @adamsitnik ) 46c911 one test to verify all scenarios (by @adamsitnik ) d06086 minor improvements (by @adamsitnik ) 116119 group instructions into maps for better visualization (by @adamsitnik ) d19b1e test fix: split on any new line ;) (by @adamsitnik ) 647a67 Merge branch 'asm' (by @adamsitnik ) 91c8e4 move disassembler stuff to resources of Core project to make it super easy to... (by @adamsitnik ) 363900 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m ) 22e993 Disable parallel build option (by @Ky7m ) 9c327c Merge pull request #531 from Ky7m/removes-no-build-argument (by @adamsitnik ) 20db28 the docs for Disassembly Diagnoser, #437 (by @adamsitnik ) 13732b added asm report with navigation (by @adamsitnik ) 33ee03 fix type of local in EmitInvokeMultipleBody (by @pentp ) 7d943f Merge pull request #532 from pentp/master (by @adamsitnik ) 4d173d RyuJit 32bit support for .NET Core, fixes #310, fixes #533 (by @adamsitnik ) 5f5237 test fix (set platform in explicit way to avoid lack of 32-bit .NET Core sdk ... (by @adamsitnik ) f359c9 allow the users to set custom RuntimeFrameworkVersion, fixes #535 (by @adamsitnik ) 264150 disassembler: print the results in machine code order, not il, part of #536 (by @adamsitnik ) 0088bd Detecting virtual machine hypervisor, #167 (#527) (by @lukasz-pyrzyk ) 007444 print all returns (maps with negative ILOffset are not always prolog or epilo... (by @adamsitnik ) aebc32 empty methods for LegacyJit64 have only maps with negative ILOffset, #536 (by @adamsitnik ) ba7489 docs for Toolchains, closes #537 (by @adamsitnik ) 8c4f53 allow the users to specify custom build configuration, #466, close #528 (by @adamsitnik ) eb80b2 Environment Variables support, #262 (by @adamsitnik ) ab7045 test fixes ;) (by @adamsitnik ) 455c60 allow the users to specify custom arguments (Mono, MsBuild), #466, #262 (by @adamsitnik ) e03384 make sure that all new custom settings are presented in human friendly way, #262 (by @adamsitnik ) cc8d07 enforce TreatWarningsAsErrors=False in auto-generated csproj to override glob... (by @adamsitnik ) 97ab49 target .NET Core 2.0 to take full advantage of the new API, fixes #539 (by @adamsitnik ) 8b2c7e check if reference assemblies are installed when choosing the default .NET fr... (by @adamsitnik ) feabd1 bump the .NET Core version, #539 (by @adamsitnik ) a21f86 for .NET Core 1.1 we should run only the Backward Compatibility tests. #539 (by @adamsitnik ) b7a966 typo fix (by @adamsitnik ) 73a30a docs: Customizing Mono, Env Variables & minor updates, fixes #262 (by @adamsitnik ) 612b41 exclude Artifacts for disassembler projects, fixes #540 (by @adamsitnik ) 360326 typo, #540 (by @adamsitnik ) f3e4ae show nice error when Job.Dry is used for Disassembler, fixes #542 (by @adamsitnik ) c6bbda allow to specify custom dotnet cli path to compare RyuJit 32 vs 64 for .NET C... (by @adamsitnik ) a0c7e5 Add info about Redstone 3,4 in WindowsBrandVersions (by @AndreyAkinshin ) d42262 Additional info about WindowsBrandVersions (by @AndreyAkinshin ) cd0a1f Improve formatting in WindowsBrandVersions (by @AndreyAkinshin ) 1cd844 Fix OsBrandStringTests.WindowsIsPrettified (by @AndreyAkinshin ) f00787 Fix markdown headers (by @jawn ) 363814 Merge pull request #547 from jawn/patch-1 (by @adamsitnik ) 405c4c Update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system. (#548) (by @Ky7m ) 97a9b2 Fix compiler warning connected to problem with the XML tag. (by @Ky7m ) 24585d Remove PackageTargetFallback element. (by @Ky7m ) 174c19 Merge pull request #549 from Ky7m/csproj-files-cleanup (by @AndreyAkinshin ) 84a4e2 Fix exporters to use fully qualified filenames (#552), fixes #529 (by @Teknikaali ) a7578a disable Disassembler tests for non-Windows OS, fixes #555 (by @adamsitnik ) a147dd Remove leading space character in a MD table row, fixes #556 (by @rolshevsky ) 9c194c DisassemblyDiagnoser crashes on overloaded benchmark, fixes #562 (by @adamsitnik ) 9076a6 give users nice warning when they run into shadow copy issues, fixes #558 (by @adamsitnik ) 1670ca the build fix ;) (by @adamsitnik ) d5854d Include UBR in Windows versions (by @AndreyAkinshin ) 1fcfee display correct runtime info in exported disassembly result, fixes #559 (by @adamsitnik ) de45ad Single point of full config creation (#565) (by @ig-sinicyn ) 395a52 make sure filters don't exclude Setup/Cleanup methods, fixes #564 (by @adamsitnik ) 4276ac fail when running benchmarks in Debug with DefaultConfig, fixes #561 (by @adamsitnik ) 0145f8 Fix build number for Windows 10 Fall Creators Update (by @AndreyAkinshin ) 7f7a7c Update cakebuild scripts (#569) (by @Ky7m ) cff577 introduce ParamsSource attribute, fixes #350, part of #256 (by @adamsitnik ) 3af915 introduce IParam to support complex, not-compile time constants as parameters... (by @adamsitnik ) 4a877f build the disassemblers before .Core, but don't add the dependency to them to... (by @adamsitnik ) 188850 specify all the embedded resources in explicit way to avoid some crazy MSBuil... (by @adamsitnik ) b5fbbf Typo fix (by @AndreyAkinshin ) eb90ce Update message in JitOptimizationsValidator (by @AndreyAkinshin ) 6c1137 Updated DotSettings (by @AndreyAkinshin ) 3d0dfe Set library version: 0.10.10 (by @AndreyAkinshin ) Contributors (11) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Andrey Dorokhov ( @aidmsu ) Anssi Kettunen ( @Teknikaali ) Bernard Vander Beken ( @jawn ) Ian Johnson ( @ipjohnson ) ig-sinicyn ( @ig-sinicyn ) Igor Fesenko ( @Ky7m ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) Pent Ploompuu ( @pentp ) Rostislav Olshevsky ( @rolshevsky ) Thank you very much! Additional details Date: November 03, 2017 Milestone: v0.10.10 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.10 BenchmarkDotNet v0.10.9 Migrate from custom build scripts to Cake (C# Make) ( #426 , #475 , thanks @Ky7m ) Target Setup methods for specific Benchmarks ( #469 , #501 , thanks @ipjohnson ) Many improvements in XmlExporter ( #476 , #488 , thanks @Teknikaali ) Add MemoryDiagnoser results to JsonExporter output ( #453 , #478 , thanks @Teknikaali ) Detect correct version of .NET Core (+ improved presentation for information about runtime) ( #448 , ed586585...ed586585 ) Fix UnauthorizedAccessException ( #380 , #390 , #490 , #491 , 8505abb5 ) Fix app.config generation ( #499 , dc6dc411 ) Fix incorrect order of IterationCleanup and Benchmark jitting ( #481 , #503 ) Fix test scripts for MacOS+zsh ( 1177c8 ) Unix-related ProcessorAffinity fixes ( #474 , 26d44411 ) Minor fixes in docs ( #465 , #467 , #473 , #480 , #483 , thanks @mtschneiders , @davkean , @aarondandy , @AmadeusW ) Temporary hacks for appveyor connectivity incident ( #497 , #506 ) Additional warnings for incorrect Configs ( #482 , eb84825f ) Additional warnings for F# methods with spaces ( #479 , 3c2c8dec , 7ba1c809 , 3ca39afe ) Milestone details In the v0.10.9 scope, 13 issues were resolved and 14 pull requests were merged. This release includes 37 commits by 10 contributors. Resolved issues (13) #380 Problem running benchmark due to \"could not copy\" during build (assignee: @adamsitnik ) #390 Crashing benchmark (assignee: @adamsitnik ) #426 Migrate from custom build scripts to Cake (C# Make) #448 Detect correct version of .NET Core (assignee: @AndreyAkinshin ) #453 MemoryDiagnoser and JsonExporter #469 [Suggestion] Specify Setup per benchmark (assignee: @AndreyAkinshin ) #474 PlatformNotSupportedException when reading ProcessorAffinity on non-Windows platforms (assignee: @AndreyAkinshin ) #479 Invalid C# code generated for valid F# identifiers (assignee: @adamsitnik ) #481 Iteration cleanup runs before the benchmark (assignee: @AndreyAkinshin ) #482 Benchmark seems to hang when no logger is defined (assignee: @adamsitnik ) #490 BDN.Generated.exe is locking files when killed with ctrl+c (assignee: @adamsitnik ) #491 UnauthorizedAccessException preventing report to be written (assignee: @adamsitnik ) #499 Opting into app-compat switches in a benchmark doesn't work (assignee: @adamsitnik ) Merged pull requests (14) #465 Small correction in Filters.md (by @mtschneiders ) #467 Small improvements to FAQ.md (by @mtschneiders ) #471 Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders ) #473 Adds ISummaryStyle information to the Exporters guide (by @AmadeusW ) #475 Cake (C# Make) integration. Migration from custom build scripts. (by @Ky7m ) #476 Improve Xml exporter's discoverability (by @Teknikaali ) #478 Add MemoryDiagnoser results to JsonExporter output (by @Teknikaali ) #480 Fix links to Overview/FAQ (by @davkean ) #483 Update jobs docs (by @aarondandy ) #488 Improve XmlExporter (by @Teknikaali ) #497 Add temporary solution to address connectivity issues to nuget.org (by @Ky7m ) #501 Target Setup methods for specific Benchmarks (by @ipjohnson ) #503 Make sure IterationCleanup is run after Jitting (by @smitpatel ) #506 Removes a temporary solution related to connectivity issues to nuget (by @Ky7m ) Commits (37) 0b5657 Small correction in comments (by @mtschneiders ) b1ad2c Merge pull request #465 from mtschneiders/patch-1 (by @adamsitnik ) 3bb154 Small corrections to FAQ.md (by @mtschneiders ) 1a8559 Merge pull request #467 from mtschneiders/patch-2 (by @adamsitnik ) fc4dfe Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders ) cb5072 Remove UpgradeLog.htm (by @AndreyAkinshin ) 7013bd Adds ISummaryStyle information to the Exporters guide (by @AmadeusW ) 345af7 wording (by @AmadeusW ) a114ea Merge pull request #473 from AmadeusW/docs/exporters (by @adamsitnik ) 26d444 Unix-related ProcessorAffinity fixes (fix #474) (by @AndreyAkinshin ) 2d8a53 Improve Xml exporter's discoverability (#476) (by @Teknikaali ) baebf9 Add MemoryDiagnoser results to JsonExporter output (#478) (by @Teknikaali ) 32993c Fix links to Overview/FAQ (by @davkean ) 8e712c Merge pull request #480 from davkean/FixLinks (by @adamsitnik ) 43405d Update jobs docs (by @aarondandy ) 1bacac Merge pull request #483 from aarondandy/docs-changes (by @adamsitnik ) 3c2c8d print nice error for F# methods that contain whitespaces, fixes #479 (by @adamsitnik ) 7ba1c8 post code review #479 (by @adamsitnik ) 3ca39a even more post code review #479 (by @adamsitnik ) eb8482 warn the users if no logger, columns or exporters were defined, fixes #482 (by @adamsitnik ) 8505ab unique file names by default, are removed after printing the results, fix #49... (by @adamsitnik ) 3e74aa Improve XmlExporter (#488) (by @Teknikaali ) 6e2577 Cake (C# Make) integration. Migration from custom build scripts. (#475) (by @Ky7m ) 6e6fcc Add temporary solution to address connectivity issues to nuget.org https://ap... (by @Ky7m ) dc6dc4 all runtime settings, that do not belong to Job must be rewritten by default ... (by @adamsitnik ) ed5865 Rename \"dotnet cli version\" to \".NET Core SDK\", see #448 (by @AndreyAkinshin ) 857f2b Detecting the correct version of .NET Core, fixing #448 (by @AndreyAkinshin ) 7ec001 Don't print information about unknown timers in HostEnvironmentInfo (by @AndreyAkinshin ) 4c3c82 Add missing space in HostRuntimeInfo (by @AndreyAkinshin ) da8226 Print actual information about .NET Framework version in summary, see #448 (by @AndreyAkinshin ) cea199 Fix MultipleRuntimesTest.SingleBenchmarkCanBeExecutedForMultpleRuntimes (by @AndreyAkinshin ) db56bc Make sure IterationCleanup is run after Jitting (by @smitpatel ) 3df90f Merge pull request #503 from smitpatel/orderingissue (by @adamsitnik ) 1177c8 Improve tests/runCoreTests.sh (by @AndreyAkinshin ) 976900 Removes a temporary solution related to connectivity issues to nuget.org http... (by @Ky7m ) 557246 Target Setup methods for specific Benchmarks (#501) (by @ipjohnson ) 80d70a Set library version: 0.10.9 (by @AndreyAkinshin ) Contributors (10) Aaron Dandy ( @aarondandy ) Adam Sitnik ( @adamsitnik ) Amadeusz Wieczorek ( @AmadeusW ) Andrey Akinshin ( @AndreyAkinshin ) Anssi Kettunen ( @Teknikaali ) David Kean ( @davkean ) Ian Johnson ( @ipjohnson ) Igor Fesenko ( @Ky7m ) Mateus Artur Schneiders ( @mtschneiders ) Smit Patel ( @smitpatel ) Thank you very much! Additional details Date: July 28, 2017 Milestone: v0.10.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.9 BenchmarkDotNet v0.10.8 Legend for time units ( #349 , #459 , f14e508e ) XML exporter ( #157 , #452 , a0148db8 ) .NET Framework 4.7 support ( #461 , 3f2b5c3c , 5513873a ) Public API for AllocationQuantum ( #450 , #462 , a0148db8 ) Milestone details In the v0.10.8 scope, 5 issues were resolved and 3 pull requests were merged. This release includes 8 commits by 4 contributors. Resolved issues (5) #157 Implement export to xml #349 What the report title and value means? (assignee: @AndreyAkinshin ) #450 [Minor feature request] Please make GcStats.AllocationQuantum public #459 [Question] What does the unit of measurement us stand for #461 .NET Framework 4.7 support (assignee: @adamsitnik ) Merged pull requests (3) #452 Feature: XML Exporter (by @Teknikaali ) #455 Wrong xml doc comment (by @ig-sinicyn ) #462 make allocation quantum public, deal with a spelling error and expose… (by @RichLinnell ) Commits (8) f14e50 Add legend for time units (by @AndreyAkinshin ) e59550 Add info about OrderProviders in docs (by @AndreyAkinshin ) 6fc245 Fix ConfigPassingTest (by @AndreyAkinshin ) ef0583 Feature: XML Exporter (#452) (by @Teknikaali ) 3f2b5c .NET 4.7 support from .NET Core host process on Windows, fixes #461 (by @adamsitnik ) a0148d make allocation quantum public, deal with a spelling error and expose allocat... (by @RichLinnell ) 551387 add Windows check to our CsProjClassicNetToolchain (by @adamsitnik ) 971565 Set library version: 0.10.8 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Anssi Kettunen ( @Teknikaali ) Rich Linnell ( @RichLinnell ) Thank you very much! Additional details Date: June 09, 2017 Milestone: v0.10.8 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.8 BenchmarkDotNet v0.10.7 LINQPad support (5.22.05+) ( #66 , #445 ) Benchmark filters and categories ( #248 ) Updated setup/cleanup attributes: [GlobalSetup] , [GlobalCleanup] , [IterationSetup] , [IterationCleanup] ( #270 , #274 , #325 , #456 ) Better Value Types support ( afa803d0 ) Building Sources on Linux: it's possible to build the solution (with unloaded F#/VB projects), run samples (for both net46/netcoreapp1.1), run unit tests (for netcoreapp1.1 only) Fix minor bugs in JsonExporter ( #451 ) Milestone details In the v0.10.7 scope, 6 issues were resolved and 1 pull requests were merged. This release includes 24 commits by 4 contributors. Resolved issues (6) #66 Friendliness to LinqPad (assignee: @adamsitnik ) #248 Support a \"category\" attribute for selecting benchmarks (assignee: @AndreyAkinshin ) #270 Add support for Cleanup and Setup between benchmarks (assignee: @AndreyAkinshin ) #274 Support for run-once Setup and Clean-up with Parameters available (assignee: @AndreyAkinshin ) #325 Setup & Cleanup versions of attribute which would run before/after each benchmark iteration (assignee: @AndreyAkinshin ) #445 Missing reference to Microsoft.CodeAnalysis.CSharp when using BenchmarkDotNet in Linqpad (assignee: @adamsitnik ) Merged pull requests (1) #451 Fix minor bugs in JsonExporter (by @Teknikaali ) Commits (24) a54645 handle the LINQPad shadow copying, #445, #66 (by @adamsitnik ) fe3032 Add Filters (by @AndreyAkinshin ) 2e7427 Add categories (by @AndreyAkinshin ) f96346 Add categories filters (by @AndreyAkinshin ) 34f808 Support category filters in BenchmarkSwitcher (by @AndreyAkinshin ) 786afe Implement join mode in BenchmarkSwitcher (by @AndreyAkinshin ) a77a77 Post code review changes (by @AndreyAkinshin ) cc7006 Fix minor bugs in JsonExporter (#451) (by @Teknikaali ) 4dd789 Rename Setup/Cleanup to GlobalSetup/GlobalCleanup (by @AndreyAkinshin ) 21369c Introduce IterationSetup/IterationCleanup (by @AndreyAkinshin ) 0e9be7 Add IterationSetupCleanupAnalyser (by @AndreyAkinshin ) 4f3703 docs: update structure (by @AndreyAkinshin ) 5fe564 docs: add info about RunStrategy.Monitoring and new Setup/Cleanup attributes (by @AndreyAkinshin ) 87ce0f Mark ProcessPropertiesTests as WindowsOnly (by @AndreyAkinshin ) 7e479e Fix typo in File_StreamVsMemoryMapperVewStream.cs (by @AndreyAkinshin ) 975514 Wrong xml doc comment (by @ig-sinicyn ) 165b13 Merge pull request #455 from ig-sinicyn/patch-1 (by @adamsitnik ) afa803 better Value Types support (by @adamsitnik ) d16ddb workaround for weird AppVeyor behavior (by @adamsitnik ) 9f3d68 support recursive nesting for returned types (by @adamsitnik ) b7668e Add tests/runCoreTests.sh (by @AndreyAkinshin ) 3cceb6 runCoreTests.sh: fix output file for integration-tests (by @AndreyAkinshin ) a21421 Make some tests Windows-only (by @AndreyAkinshin ) 00a156 Set library version: 0.10.7 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Anssi Kettunen ( @Teknikaali ) ig-sinicyn ( @ig-sinicyn ) Thank you very much! Additional details Date: June 05, 2017 Milestone: v0.10.7 Overview post: http://aakinshin.net/blog/post/bdn-v0_10_7/ NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.7 BenchmarkDotNet v0.10.6 Removed buggy allocation from Engine which was spoiling the results of MemoryDiagnoser for micro benchmarks. This part of the code is now guarded with very strict integration tests, it should never happen again. We now also exclude the side effects of the Allocation Quantum. This bug was serious, you must update to 0.10.6 ( #439 ) Support of the PackageTargetFallback setting which allows to reference components that target old framework monikers (like dotnet5.4 or portable-net45+win8 ) ( #438 ) Added InstructionRetiredPerCycleColumn which shows up automatically when HardwareCounter.InstructionRetired and HardwareCounter.TotalCycles are used. Support benchmark classes without namespace ( #446 ) Fix problem with RPlotExporter and quoted directories in %PATH% ( #446 ) Show Windows brand version in summary Milestone details In the v0.10.6 scope, 3 issues were resolved and 1 pull requests were merged. This release includes 11 commits by 3 contributors. Resolved issues (3) #438 Need to Update Autogenerated csproj file (assignee: @adamsitnik ) #439 Question - This benchmark apparently allocates, but why? (assignee: @adamsitnik ) #446 ArgumentNullException if RPlotExporter is used (assignee: @AndreyAkinshin ) Merged pull requests (1) #444 Added line separator at the end in JsonExporters (by @alinasmirnova ) Commits (11) 3c1f09 copy the PackageTargetFallback setting if present in csproj to support older ... (by @adamsitnik ) ffab7d remove allocation from Engine, make sure tests detect breaking change in the ... (by @adamsitnik ) 7c9a0f consider Allocation Quantum side effects to have correct results for micro be... (by @adamsitnik ) 4af5f3 Added line separator in JsonExporters (by @alinasmirnova ) 8ac913 added Instruction Retired per Cycle (IPC) to the predefined columns for Pmc D... (by @adamsitnik ) 0898c3 post code review changes (by @adamsitnik ) b4d68e 'kB' -> 'KB' (by @AndreyAkinshin ) 23bd4f Handle null values in CsvHelper.Escape (by @AndreyAkinshin ) 77ed63 RPlotExporter.FindInPath: handle exceptions, trim quotes #446 (by @AndreyAkinshin ) 626e3a Show Windows brand versions in summary (by @AndreyAkinshin ) 247634 Set library version: 0.10.6 (by @AndreyAkinshin ) Contributors (3) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Date: May 12, 2017 Milestone: v0.10.6 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.6 BenchmarkDotNet v0.10.5 Fixed SizeUnit presentation in the summary table ( #434 ) In MemoryDiagnoser, now 1kB = 1024B (instead of 1000 in v0.10.4) ( #434 ) Fix false allocations detection ( #436 9b44de70 ) Hide ScaledSD column for small values ( da857ad7 ) Autoselecting amount of digits after the decimal point ( #404 ) Milestone details In the v0.10.5 scope, 3 issues were resolved and 2 pull requests were merged. This release includes 16 commits by 4 contributors. Resolved issues (3) #404 Autoselecting amount of digits after the decimal point (assignee: @AndreyAkinshin ) #428 Cleanup NuGet.Config (assignee: @adamsitnik ) #434 Allocation output suddenly is 0 GB (assignee: @AndreyAkinshin ) Merged pull requests (2) #435 Joined approved files according to cultures (by @alinasmirnova ) #436 Fix false allocations detection (by @ig-sinicyn ) Commits (16) d9eefd NuGet feeds cleanup, fixes #428 (by @adamsitnik ) 2a95b0 Fix SizeUnit presentation, fixes #434 (by @AndreyAkinshin ) 8eca28 Add a note about kilobytes in docs (by @AndreyAkinshin ) ae483e Separate approved files only for cultures, not for exporters (by @alinasmirnova ) 78a6a0 Improved legend for MemoryDiagnoser (by @AndreyAkinshin ) 47ae20 SizeUnitTests (by @AndreyAkinshin ) 9b44de fix false allocations detection (by @ig-sinicyn ) ffd535 Merge pull request #436 from ig-sinicyn/fix_allocations_on_run (by @adamsitnik ) 87c2bd Inclusive ConfidenceInterval.Contains (by @AndreyAkinshin ) da857a Don't show the ScaledSD column if values are small (by @AndreyAkinshin ) e0cf24 Add DefaultColumnProvidersTests (by @AndreyAkinshin ) f2baa3 Fix typo in DefaultColumnProvidersTests (by @AndreyAkinshin ) 117560 Fix BaselineScaledColumnTest.ColumnsWithBaselineGetsScaled (by @AndreyAkinshin ) 3a1fb7 Implement BestAmountOfDecimalDigits for statistics columns in SummaryTable, f... (by @AndreyAkinshin ) 4201ee Fix ToolchainTest.CustomToolchainsAreSupported (by @AndreyAkinshin ) cba245 Set library version: 0.10.5 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) ig-sinicyn ( @ig-sinicyn ) Thank you very much! Additional details Date: April 26, 2017 Milestone: v0.10.5 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.5 BenchmarkDotNet v0.10.4 New logo Update to Roslyn 2.0, drop .NET 4.5 support ( #303 ) Initial support of HardwareCounters (Windows only) Initial experimental support of in-process benchmarks Optional configs for BenchmarkSwitcher ( #391 , #392 ) Host API interface ( #356 ) Improved measurements for async benchmarks ( #415 ) Improved precision level (MinIterationTimes is 500ms instead of 200ms; introduced AccuracyMode.MaxAbsoluteError and AccuracyMode.MaxRelativeError instead of AccuracyMode.MaxStdErrRelative ; logic which select amount of iterations uses confidence intervals instead of standard errors; the Error column (half of CI99.9%) is shown by default instead of StdErr) Introduced ISummaryStyle , raw data in CSV reports ( #118 , #146 , #396 ) Handle cases when report files are existed and locked ( #414 , #416 ) MarkdownExporter right-justifies numeric columns ( #421 ) Better colors for console output ( #376 ) Column legends Add information about CPU microarchitecture for well-known processors to summary Fix AssemblyInformationalVersionAttribute ( #382 ) Fix incorrect method filtering in BenchmarkSwitcher ( #365 ) Fix OS Version in Summary for Windows 10 ( #351 ) Fix OS Version on Mono Fix --class and --method filtering ( #249 ) Fix --exporters option ( #189 ) Fix escaping logic in CsvExporter ( #294 , #409 ) Fix MacOS detection Minor bugfixes and API improvements Milestone details In the v0.10.4 scope, 23 issues were resolved and 14 pull requests were merged. This release includes 103 commits by 8 contributors. Resolved issues (23) #118 Raw data in CSV reports (assignee: @AmadeusW ) #146 Ability to specify units / easier comparison (assignee: @AmadeusW ) #159 Warn user if no Columns were defined (assignee: @adamsitnik ) #189 --exporters option appears not to be working (assignee: @adamsitnik ) #249 --class and --method should combine as \"AND\" filtering (assignee: @adamsitnik ) #294 [Suggestion] CSVHelper.Escape() method should check for actual separator value (assignee: @alinasmirnova ) #303 Update to Roslyn 2.0 when RTM is shipped to nuget.org (assignee: @adamsitnik ) #351 Fix OS Version in Summary for Windows 10 (assignee: @adamsitnik ) #352 Troubles with CoreJob on Linux (assignee: @adamsitnik ) #365 [Minor bug] Benchmark switcher: incorrect method filtering (assignee: @adamsitnik ) #376 Pick better background colors for output (assignee: @AndreyAkinshin ) #382 AssemblyInformationalVersion doesn't work (assignee: @AndreyAkinshin ) #388 Precise Machine Counter Diagnoser (assignee: @adamsitnik ) #391 BenchmarkSwitcher should take an optinal IConfig #393 Troubles with ClrJob in .NET Core applications (assignee: @adamsitnik ) #395 Could not load file or assembly 'System.Reflection.Metadata' (assignee: @adamsitnik ) #401 Exceptions in Roslyn.Builder (assignee: @adamsitnik ) #406 BenchmarkDotNet with netcoreapp2.0 requires using RuntimeFrameworkVersion directly in the project file (assignee: @adamsitnik ) #410 Troubles with Classic applications on nightly BenchmarkDotNet (assignee: @adamsitnik ) #412 HardwareCounter.InstructionRetired failing with ArgumentNullException. Build 82 (assignee: @adamsitnik ) #415 Allocations for async methods measures BenchmarkDotNet (assignee: @adamsitnik ) #419 Suspicious warnings about MemoryMappedFiles (assignee: @adamsitnik ) #424 Make InliningDiagnoser filtering more flexible (assignee: @adamsitnik ) Merged pull requests (14) #356 Feature: host API interface (by @ig-sinicyn ) #379 Feature: in-process benchmarks (by @ig-sinicyn ) #392 Add an optional config to BenchmarkSwitcher. (by @ILMTitan ) #396 Allow users to pick, show and hide measurement units in the reports and exports. (by @AmadeusW ) #400 fix spelling error: misspredict => mispredict (by @stevedesmond-ca ) #405 Make RoslynToolchain types public (by @cdmihai ) #407 Propagate benchmark to hooks (by @cdmihai ) #408 Small fixes before approval tests (by @alinasmirnova ) #409 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova ) #416 Exports file to temporary location if target is locked (by @AmadeusW ) #421 MarkdownExporter right-justifies numeric columns (by @stevedesmond-ca ) #423 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova ) #430 Fix unix OS detection. (by @mfilippov ) #432 Fix macOS detection (by @mfilippov ) Commits (103) bd790c Simplify BenchmarkDotNet.IntegrationTests.Classic.ReferencesTests (by @AndreyAkinshin ) bf9f4e Feature: host API interface (by @ig-sinicyn ) f85ffe Merge pull request #356 from ig-sinicyn/feature-host-api (by @AndreyAkinshin ) 8ffff0 Feature: in-process benchmarks (by @ig-sinicyn ) 51fc0c Feature: in-process benchmarks, FixAffinity() helper (by @ig-sinicyn ) c5179f Feature: in-process benchmarks, review fixes (by @ig-sinicyn ) 6c5990 Feature: in-process benchmarks, review fixes, part 2 (by @ig-sinicyn ) c6b046 Feature: in-process benchmarks, STA & priority on full .Net FW (by @ig-sinicyn ) cc2c89 Feature: in-process benchmarks, env validation in toolchain, intro example ad... (by @ig-sinicyn ) 101a80 Improved versioning system (by @AndreyAkinshin ) 846532 Update links to appveyor (by @AndreyAkinshin ) 5464e4 Improved versioning system, part 2 (by @AndreyAkinshin ) e39a50 Merge pull request #379 from ig-sinicyn/feature-inprocess (by @adamsitnik ) ae4cc8 AssemblyInformationalVersion fix in common.props, resolves #382 (by @AndreyAkinshin ) d036f9 Precise Machine Counter Diagnoser #388 (by @adamsitnik ) 390442 Improved invocationCount behavior in SimpleJobAttribute (by @AndreyAkinshin ) 7b61ed add possibility to set Hardware Counters per class in runtime-independent way... (by @adamsitnik ) 6e208c Add an optional config to BenchmarkSwitcher. (by ILMTitan) 935d23 Merge pull request #392 from ILMTitan/master (by @adamsitnik ) 6b9a88 update to Roslyn 2.0, drop .NET 4.5 support, fixes #303 (by @adamsitnik ) ea4c55 BenchmarkDotNet.IntegrationTests.csproj: fix formatting (by @AndreyAkinshin ) 20a537 Update year in LICENSE.md (by @AndreyAkinshin ) 878796 Update logo (by @AndreyAkinshin ) faba77 Update README.md (by @AndreyAkinshin ) 6dce74 Update logo in README.md (by @AndreyAkinshin ) 7a750f Another fix in README.md (by @AndreyAkinshin ) 1caa0d fix spelling error: misspredict => mispredict (by @stevedesmond-ca ) 742912 use Array.Empty and Task.Completed (after upgrading to .NET 4.6) (by @adamsitnik ) 0dafac there is no need to set up with latest VS, fixes #393 (by @adamsitnik ) f5d88e Catch exceptions in BenchmarkDotNet.Running.BenchmarkRunnerCore.Run (by @AndreyAkinshin ) fa176f Merge pull request #400 from stevedesmond-ca/missspelling (by @AndreyAkinshin ) 90c3b1 Docs improvements (by @AndreyAkinshin ) 84c524 Mark SimpleJobAttribute with AllowMultiple (by @AndreyAkinshin ) 531804 Update README.md (by @AndreyAkinshin ) 7f2221 Make RoslynToolchain types public (#405) (by @cdmihai ) be8c33 Improved confidence intervals (by @AndreyAkinshin ) 767811 Propagate benchmark to hooks (#407) (by @cdmihai ) ec5e54 All exporters should not use static environment info (by @alinasmirnova ) 2b8a9e Culculate csv separator when it is needed, not in constructor (by @alinasmirnova ) 95aeb5 clean up (by @alinasmirnova ) 2e74c2 Name field for all exporters (by @alinasmirnova ) badb0b Merge pull request #408 from alinasmirnova/small-fixes (by @AndreyAkinshin ) 9da9ca search for .NET Core 2.0 settings in imported props files, fixes #406 (by @adamsitnik ) 2b08c5 filter sealed, generic and abstract classes from BenchmarkSwitcher, fixes #365 (by @adamsitnik ) 14ad55 print correct OS version in summary, fixes #351 (by @adamsitnik ) b86f48 BenchmarkDotNet does not support running .NET Core benchmarks when host proce... (by @adamsitnik ) 11b51b refactoring in TypeParser (by @adamsitnik ) 8047a7 use AND when filtering with args from command line, fixes #249 (by @adamsitnik ) 3cf8d8 handle cmd line arguments without '=', fixes #189 (by @adamsitnik ) cdc71f test fix after recent changes, #249 (by @adamsitnik ) 97c211 detect situation when users want to use Hardware Counters with InProcessToolc... (by @adamsitnik ) ba972b Warn user if no Columns were defined, fixes #159 (by @adamsitnik ) 2520f2 migrate old csprojs to the new format to get the tests running in common way,... (by @adamsitnik ) dd1b4d Improvements in StatisticsTests (by @AndreyAkinshin ) 07d149 emptyEnumerable.All(whatever) returns true (by @adamsitnik ) 0d61a7 improve dynamic diagnoser loading (case when diagnosers NuGet pacakge is inst... (by @adamsitnik ) 5a6937 Ignore BenchmarkProject.json in BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 5895c4 Improvements in TypeParserTests (by @AndreyAkinshin ) 1124ae BenchmarkDotNet.Tests: cleanup (by @AndreyAkinshin ) d37ef4 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova ) 43643c move hardwareCounters from Job to Config, fixes #412 (by @adamsitnik ) 303fff pass config from runner => executor => diagnoser #412 (by @adamsitnik ) 5b432e Addded approval tests for exporters (by @alinasmirnova ) ac6507 Added more info in mock summary (by @alinasmirnova ) a59b17 MockEnvironmentInfo for approval tests (by @alinasmirnova ) 610f3b Awaiting Tasks should not interfere allocation results, fixes #415 (by @adamsitnik ) cf16f6 I forgot about aligning, #415 (by @adamsitnik ) 2860d2 help the .NET framework to resolve assemblies when binding redirects are miss... (by @adamsitnik ) e7ad36 don't log false alarms, fixes #419 (by @adamsitnik ) 803081 Allow users to pick, show and hide measurement units in the reports and expor... (by @AmadeusW ) fa3128 Exports file to temporary location if target is locked (#416) (by @AmadeusW ) c923ba MarkdownExporter right-justifies numeric columns (#421) (by @stevedesmond-ca ) aa290d Add column legends (by @AndreyAkinshin ) 8d8db5 Handle case when there are no columns with legends (by @AndreyAkinshin ) dc201c Add empty line before legends (by @AndreyAkinshin ) ff7fc9 Approved files (by @alinasmirnova ) 3f6372 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova ) 7d23d1 Merge remote-tracking branch 'upstream/master' (by @alinasmirnova ) 57cbbb Merge branch 'new-test-sdk-version' (by @alinasmirnova ) c0c563 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova ) 539834 Updated spproved files according last changes in md exporter (by @alinasmirnova ) f117f0 Added *.received and *.orig in .gitignore (by @alinasmirnova ) 0d7e72 Make InliningDiagnoser filtering more flexible, fixes #424 (by @adamsitnik ) d25eb0 allow to set InProcessToolchain via attribute /cc @ig-sinicyn (by @adamsitnik ) 8cf041 Mock strings in mock environment info (by @alinasmirnova ) 0db804 Changed file naming in approval files (by @alinasmirnova ) 29aeaf correct Idle implementation for Task-returning benchmarks, fixes #418 (by @adamsitnik ) c81aa5 the missing docs for Hardware Counters, fixes #388 (by @adamsitnik ) 6076e2 Improved precision (by @AndreyAkinshin ) 72b3a6 Show \"NA\" for statistic columns with double.NaN values (by @AndreyAkinshin ) ea2222 Processor brand string prettifying (by @AndreyAkinshin ) 678d43 Added approval files info links to docs (by @alinasmirnova ) 33911c Merge remote-tracking branch 'upstream/master' (by @alinasmirnova ) d4c928 Fixed approval tests according to recent changes in master (by @alinasmirnova ) eb9f4f Fix typos in docs (by @AndreyAkinshin ) 271b27 Merge pull request #348 from alinasmirnova/master (by @AndreyAkinshin ) 152f3e Parsing Gulftown processor brand strings (by @AndreyAkinshin ) 74d793 Minor improvements in docs (by @AndreyAkinshin ) 764bd3 Minor improvements in docs, part 2 (by @AndreyAkinshin ) 0a251b Fix unix OS detection. (by @mfilippov ) 5c3b39 Fix typo in PlatformID (by @mfilippov ) 7f3d06 Always use PlatformAbstractions in RuntimeInformation.GetOsVersion() (by @AndreyAkinshin ) 46d34f Set library version: 0.10.4 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Amadeusz Wieczorek ( @AmadeusW ) Andrey Akinshin ( @AndreyAkinshin ) ig-sinicyn ( @ig-sinicyn ) Mihai Codoban ( @cdmihai ) Mikhail Filippov ( @mfilippov ) Steve Desmond ( @stevedesmond-ca ) Thank you very much! Additional details Date: April 21, 2017 Milestone: v0.10.4 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.4 BenchmarkDotNet v0.10.3 New .csprojs support for .NET Core. Also for F# ( #366 )! New plots and RPlotExporter (density plots for each job; cumulative mean plots) Fixed exporter order (now RPlotExporer uses the actual measurements instead of previous version) Xplat improvments in RuntimeInformation Introduced RunStrategy.Monitoring Possibility to set custom path for Mono ( #306 ) Possibility to set any .NET Core version >= 1.1 ( #336 ) MemoryDiagnoser is now disabled by default (Breaking changes!!) ( #369 ) Milestone details In the v0.10.3 scope, 10 issues were resolved and 2 pull requests were merged. This release includes 79 commits by 3 contributors. Resolved issues (10) #300 Switch back from project.json and xproj to csproj, support dotnet cli preview 3 (assignee: @adamsitnik ) #306 Custom path for mono (assignee: @adamsitnik ) #320 Results table should be a GitHub Flavored Markdown table (assignee: @alinasmirnova ) #322 First benchmark always fails when running on .NET Core with -c release (assignee: @adamsitnik ) #336 allow the users to choose the target .NET Core version (1.2, 2.0 etc) (assignee: @adamsitnik ) #366 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild) (assignee: @adamsitnik ) #369 Consider to disable MemoryDiagnoser by default (assignee: @adamsitnik ) #372 Troubles with ClrJob from CoreCLR project (assignee: @adamsitnik ) #374 BenchmarkDotNet doesn't understand netcoreapp2.0 (assignee: @adamsitnik ) #375 Troubles with dotnet pack (assignee: @adamsitnik ) Merged pull requests (2) #355 Fixed typo in IntroBasic.cs (by @mmayr-at ) #357 Farewell project json (by @adamsitnik ) Commits (79) 8099a5 Print process.StartInfo in Executor (by @AndreyAkinshin ) abd931 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 5c8c75 toolchains should not require parameterless ctors, the real fix for #327 (by @adamsitnik ) b22cf2 allow the users to choose the target .NET Core version, fixes #336 (by @adamsitnik ) f99c82 .net core toolchain: root folder detection bug fix (by @adamsitnik ) c7aba1 experimental .NET Core support for the new VS 2017 csproj files, #300 (by @adamsitnik ) bca146 Additional density plots in RPlotExporter (by @AndreyAkinshin ) 4bb147 Additional cummean plots in RPlotExporter (by @AndreyAkinshin ) 8bf40c Implement top sort in CompositeExporter (by @AndreyAkinshin ) ad771d Always print the AllocationColumn in the Summary table (if MemoryDiagnoser is... (by @AndreyAkinshin ) 8a1f0e Fix order of exporters in ExporterDependencyTests (by @AndreyAkinshin ) a7366e xproj to csproj auto migration (by @adamsitnik ) cec3e2 xproj to csproj: manual changes (conditional recursive dependencies not suppo... (by @adamsitnik ) 74006d xproj to csproj: I did not ask for the .NET Standard dependency (by @adamsitnik ) bf7093 xproj to csproj: manual changes (conditional dependencies not supported anymo... (by @adamsitnik ) 4e060f xproj to csproj: manual changes (simple case not supported) (by @adamsitnik ) 59602c remove F# .NET Core samples (not working now) (by @adamsitnik ) 2488ae cleanup (by @adamsitnik ) d7925b get our toolchain up and running, thanks to @cesarbs (by @adamsitnik ) e719e7 Update IntroBasic.cs (by @mmayr-at ) 1ef000 Merge pull request #355 from mmayr-at/patch-1 (by @AndreyAkinshin ) 5cf1dc making diagnosers, ctrl+c, custom priority and affinity work for the new csprojs (by @adamsitnik ) d0f334 getting net46 toolchain work again for new .csprojs when called from .NET Cor... (by @adamsitnik ) d1bf9b removing old project.json workarounds (by @adamsitnik ) e0b134 taking advantage of the csproj (by @adamsitnik ) 001b3f appveyor stuff (by @adamsitnik ) 63d674 don't introduce limit for .sln file search depth (by @adamsitnik ) 81adbb make VS stop complaining about root namespace for BenchmarkDotNet.Core project (by @adamsitnik ) 2eee5f let's round it to reduce the side effects of Allocation quantum (by @adamsitnik ) f38e93 a project that targets AnyCPU cany be referenced by any other executable (32 ... (by @adamsitnik ) 8ed5a4 post code review changes (by @adamsitnik ) 50c938 add possibility to use RetainVMGarbageCollection config switch (by @adamsitnik ) ca1bc8 final Cleanup and some renaming ;) (by @adamsitnik ) a26d61 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 008819 getting all the test runnable again (by @adamsitnik ) a66913 trying to get the versioning done right (by @adamsitnik ) c6f245 the updated docs (by @adamsitnik ) f1a1fd update to the latest xUnit 2.2 + minor cleanup (by @adamsitnik ) 262c87 appveyor config + minor bug fixes (by @adamsitnik ) 1a7bd4 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild), fix... (by @adamsitnik ) e8f6ac support projects without .sln file (dotnet cli only) (by @adamsitnik ) 1b71c5 update our tests to net452 because XUnit VS runner 2.2 does no longer support... (by @adamsitnik ) 6121ad disable shadow copy for our integration tests (by @adamsitnik ) 54375c warn the users when code optimization was not enabled (debug build can be opt... (by @adamsitnik ) 03ed32 stop using --binaries option which started producing new folder for every re... (by @adamsitnik ) 27f280 dotnet cli like to not release used files for a while.. (by @adamsitnik ) 7886ad Merge pull request #357 from dotnet/farewellProjectJson (by @AndreyAkinshin ) 751f64 Xplat RuntimeInformation.GetProcessorName() (by @AndreyAkinshin ) b327b7 tell why dotnet command failed + how much time it took to execute (by @adamsitnik ) b740bb WindowsVersion on CoreCLR (by @AndreyAkinshin ) 5b879b Lazty HostEnvironmentInfo.OsVersion (by @AndreyAkinshin ) 76d081 Lazy HostEnvironmentInfo.OsVersion, fix in ToFormattedString() (by @AndreyAkinshin ) 5dafb9 do not restore or build the dependent projects, just the auto-generated one (by @adamsitnik ) 5c1914 better troubleshooting: when dll is not found but somehow build has succeeded... (by @adamsitnik ) 322998 using csproj to tell msbuild where to put output so appveyor custom settings ... (by @adamsitnik ) e2a8fa post code review changes (by @adamsitnik ) 6fe93d MinIterationTimeAnalyser (by @AndreyAkinshin ) 3ac892 RunStrategy.Monitoring (by @AndreyAkinshin ) f412b9 Docs: add FAQ section about supported version of Visual Studio (by @AndreyAkinshin ) 67a007 fixing ProjectJsonToolchains after recent CsProjToolchain optimizations (by @adamsitnik ) 2b5c6e Improved RuntimeInformation.GetProcessorName() (by @AndreyAkinshin ) a44638 Improved RuntimeInformation.GetOsVersion() (by @AndreyAkinshin ) f58e06 Improved RuntimeInformation.GetRuntimeVersion() for Mono (by @AndreyAkinshin ) fdca26 Minor RuntimeInformation fixes (by @AndreyAkinshin ) 2a2168 Fix bug in ExternalToolsHelper (by @AndreyAkinshin ) 9dfd95 Custom path for mono, fixes #306 (by @adamsitnik ) 448b07 disable MemoryDiagnoser by default, BREAKING CHANGE, fixes #369 (by @adamsitnik ) 125b71 docs for Custom Mono Paths, #306 (by @adamsitnik ) a3d6e0 docs/FAQ: Add section about new .NET Core Console App in VS2017 (by @AndreyAkinshin ) b04195 give users the AnyCpu hint when they struggle with BadImageFormatException, f... (by @adamsitnik ) 7de671 generate the projects in the bin folder, not solution's root (by @adamsitnik ) 1d52ae docs/FAQ: add another question (by @AndreyAkinshin ) 06aaa0 copy NetCoreAppImplicitPackageVersion and RuntimeFrameworkVersion settings to... (by @adamsitnik ) f1fe16 shame on me for not building the code for all TFMs before pushing (by @adamsitnik ) fe33dd GitHub Markdown: every table row should start with \"|\" , fixes #320 (by @adamsitnik ) 7d0d73 remove old results, otherwise, the file will be overwritten and remaining old... (by @adamsitnik ) 80348b Change Hint color to DarkCyan #376 (by @AndreyAkinshin ) 0b35ec Increase MinIterationTime (Accuracy improvement) (by @AndreyAkinshin ) cdee09 Set library version: 0.10.3 (by @AndreyAkinshin ) Contributors (3) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Michael Mayr ( @mmayr-at ) Thank you very much! Additional details Date: March 01, 2017 Milestone: v0.10.3 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.3 BenchmarkDotNet v0.10.2 Closed #307 : culture invariant statistics output Closed #321 : persist optimized, auto-generated dll compiled from url/plain code Closed #322 : always restore the console foreground color Closed #337 : Better detection of Rscript.exe in RPlotExporter Closed #345 : fix bug in WelchTTestPValueColumn for DryJob VS 2017 compatibility fix fix bold markup for Atlassian exporter Improved precision of nanobenchmarks Minor infrastructure changes and misc fixes Milestone details In the v0.10.2 scope, 10 issues were resolved and 3 pull requests were merged. This release includes 30 commits by 7 contributors. Resolved issues (10) #295 Fix CLS-compliant warnings in Diagnostics (assignee: @adamsitnik ) #307 Output: interpolated strings & culture (assignee: @alinasmirnova ) #319 [Request] some API to public? (assignee: @adamsitnik ) #321 BenchmarkRunner.RunUrl throws BenchmarkSystem.IO.FileNotFoundException (assignee: @adamsitnik ) #327 Unable to use ClassicToolchain in explicit way (assignee: @adamsitnik ) #332 default color of terminal is changed after the run is completed (assignee: @adamsitnik ) #335 Support benchmarking startup performance (assignee: @AndreyAkinshin ) #337 Problematic mechanism/docs for locating Rscript.exe #340 [FeatureRequest] Enable Characteristic-based properties for non-job types. (assignee: @ig-sinicyn ) #345 Fail to run IntroAdvancedStats in dry mode (assignee: @AndreyAkinshin ) Merged pull requests (3) #338 Fix typo (by @roji ) #339 Better detection of Rscript in RPlotExporter (by @roji ) #341 Base types for characteristic objects: (by @ig-sinicyn ) Commits (30) e7c398 Fixes parentheses error (by Josef Ottosson) 2655b3 Merge pull request #318 from joseftw/patch-1 (by @adamsitnik ) 4115a2 make GcStats and Net46Toolchain internal members public, fixes #319 (by @adamsitnik ) 52f953 ignore the CLS compilant errors for Diagnosers package, fixes #295 (by @adamsitnik ) d96b68 Improved Consumer (by @AndreyAkinshin ) 943c49 CLSCompliant fixes in Consumer (by @AndreyAkinshin ) f4bdae specify the .NET Core sdk version in explicit way to get the solution working... (by @adamsitnik ) df8c55 always restore the console foreground color, fixes #332 (by @adamsitnik ) 24dea4 fix bold markup for Atlassian exporter (by @lahma ) 4d3c75 persist optimized, auto-generated dll compiled from url/plain code, fixes #321 (by @adamsitnik ) 2e92a2 allow to set Classic/Roslyn tool chain in explicit way, fixes #327 (by @adamsitnik ) aabece Merge pull request #329 from lahma/features/atlassian-bold-format (by @adamsitnik ) 91152c ExportToFiles now accepts console logger (by @roji ) 299375 Base types for characteristic objects: (by @ig-sinicyn ) afc65d Better detection of Rscript.exe in RPlotExporter (by @roji ) 15869b Merge pull request #339 from roji/rscript-detect (by @AndreyAkinshin ) 9f6a82 Merge pull request #341 from ig-sinicyn/feature-characteristic-object (by @AndreyAkinshin ) 432adf Fix typo (by @roji ) cfa015 Merge pull request #338 from roji/dependencies-typo (by @AndreyAkinshin ) 4d953f Temporary rollback of the link to appveyor (by @AndreyAkinshin ) 1f5a6e Update year in docs footer (by @AndreyAkinshin ) 183ab6 Fix warning in RoslynToolchain (by @AndreyAkinshin ) 6fd9f3 Used ToStr to make statistics builder culture invariant (fixed #307) (by @alinasmirnova ) 3a3100 Merge pull request #346 from alinasmirnova/master (by @AndreyAkinshin ) 7ee2f1 Fix in WelchTTestPValueColumn for DryJob, fixes #345 (by @AndreyAkinshin ) 795f4a Disable jitting for RunStrategy=ColdStart, fixes #335 (by @AndreyAkinshin ) 5b5a8c Fixed typo (by @lukasz-pyrzyk ) 54519c Merge pull request #347 from lukasz-pyrzyk/master (by @adamsitnik ) fbac75 Introduced Dummy actions (by @AndreyAkinshin ) 484f53 Set library version: 0.10.2 (by @AndreyAkinshin ) Contributors (7) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) ig-sinicyn ( @ig-sinicyn ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) Marko Lahma ( @lahma ) Shay Rojansky ( @roji ) Thank you very much! Additional details Date: January 21, 2017 Milestone: v0.10.2 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.2 BenchmarkDotNet v0.10.1 MemoryDiagnoser got improved. The changes: Memory Diagnoser is now part of BenchmarkDotNet.Core.dll, and it's enabled by default MemoryDiagnoser is 100% accurate about allocated memory when using default settings or Job.ShortRun or any longer job. (see #284 ) Memory Diagnoser no longer includes allocations from Cleanup/Setup methods (see #186 ) the results are now scaled so they are stable across the runs. (see #133 ) .NET Core 1.1+ support, we no longer support 1.0, we target netcoreapp1.1 now. Reason: we wanted to use GC.GetAllocatedBytesForCurrentThread in MemoryDiagnoser which is available only in 1.1+ Improved information about environment in summary Minor bugfixes Milestone details In the v0.10.1 scope, 9 issues were resolved and 2 pull requests were merged. This release includes 38 commits by 2 contributors. Resolved issues (9) #133 High differences between run for GC Diagnoser (assignee: @adamsitnik ) #186 GC Diagnoser should not include allocations done by Setup method (assignee: @adamsitnik ) #200 be accurate about allocated bytes/op (assignee: @adamsitnik ) #208 Troubles with MemoryDiagnoserTests (assignee: @adamsitnik ) #298 PlatformNotSupportedException when reading ProcessorAffinity on MacOS (assignee: @adamsitnik ) #301 netcoreapp1.1 support (assignee: @adamsitnik ) #309 Diagnosers don't export data to the measurements.csv files (assignee: @adamsitnik ) #312 RuntimeInformation can be made static and internal (assignee: @AndreyAkinshin ) #313 Bug in Generator (interface as a return type) (assignee: @AndreyAkinshin ) Merged pull requests (2) #284 built-in accurate and cross platform Memory Diagnoser (by @adamsitnik ) #314 Improved information about job environments in summary (by @AndreyAkinshin ) Commits (38) 23f3b2 built-in accurate and cross platform Memory Diagnoser, fixes #186, fixes #200 (by @adamsitnik ) 4cabc2 don't try to use AppDomain's Monitoring in Mono since it's not implemented there (by @adamsitnik ) 99c21e scale GC collections count / op, makes MemoryDiagnoser output stable for benc... (by @adamsitnik ) e91255 use per mille to make the Memory Diagnoser output more human-friendly + reduc... (by @adamsitnik ) a0536d Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik ) ade1be preallocate results list in more safe, but still ugly way (by @adamsitnik ) 102282 closed the ugly code in separate class (by @adamsitnik ) 7825b7 Update links in docs (by @AndreyAkinshin ) aaf720 Fix typo (by @AndreyAkinshin ) 1e2d38 update to netcoreapp1.1 in order to get universal cross platform memory diagn... (by @adamsitnik ) e69e80 don't show Gen 1 and Gen 2 columns if empty for all benchmarks (by @adamsitnik ) b10a84 PlatformNotSupportedException when reading ProcessorAffinity on MacOS, fixes ... (by @adamsitnik ) 2a529a update to .NET Core 1.1, fixes #301 (by @adamsitnik ) e6ccee always show Gen 0 column, display Gen 0/1/2 per 1k op (by @adamsitnik ) 3bcc59 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik ) a09810 make public things readonly, expensive things lazy and extend's validators in... (by @adamsitnik ) eae2cd added documentation and smarter bytes formatting (by @adamsitnik ) 1208c3 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik ) f1f231 Merge pull request #284 from dotnet/universalMemoryDiagnoser (by @AndreyAkinshin ) 6300a2 include MemoryDiagnoser's results in CsvMeasurementsExporter, fixes #309 (by @adamsitnik ) ddb37e don't use spaces in columns names in CSV, #309 (by @adamsitnik ) 112f62 Fix stupid bug with condition for optional MedianColumn (by @AndreyAkinshin ) 60127c Remove Cpu_Ilp_RyuJit.cs because it's obsolete (by @AndreyAkinshin ) 401456 Print full information about a GenerateException (by @AndreyAkinshin ) 0b9177 Support of benchmark methods with an interface as a return type, fixed #313 (by @AndreyAkinshin ) b42b9e Improved information about job environments in summary (by @AndreyAkinshin ) 92f1db Improved information about job environments in summary, part 2 (by @AndreyAkinshin ) 5d8dd7 Merge pull request #314 from dotnet/summary (by @AndreyAkinshin ) d279f6 Make RuntimeInformation static internal, fix #312 (by @AndreyAkinshin ) 1df6ca Minor API improvements in BenchmarkSwitcher (by @AndreyAkinshin ) c12daf Dot't show the median column for the N=1 case (by @AndreyAkinshin ) 19caa2 RyuJit is always avaiable for .NET Core (by @adamsitnik ) 13e12c make JitOptimizationsValidator work for .NET Core (needed properties are avai... (by @adamsitnik ) c17b43 hide the AllocatedBytes column for Mono, show Gen 0 only if any of the benchm... (by @adamsitnik ) 29ac91 updated docs about Diagnosers in the Overview ;) (by @adamsitnik ) cc974e Improved information about job environments in summary, part 3 (by @AndreyAkinshin ) 8846af Update docs (by @AndreyAkinshin ) 37b126 Set library version: 0.10.1 (by @AndreyAkinshin ) Contributors (2) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Date: December 04, 2016 Milestone: v0.10.1 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.1 BenchmarkDotNet v0.10.0 Now BenchmarkDotNet is a part of .NET Foundation Job and Column API refactoring (see new documentation) Measurement engine improvements Horology enhancement (see TimeInterval and Frequency ) Introduced RankColumn which is based on WelchTTest (see 157aabc3 ) JsonExporters refactoring (see the Exporters/Json section in the documentation) Renamed JsonExporters classed and attributes JsonExporters with custom settings JsonExporters now includes information about the target type namespace (see #246 ). Add JetBrains.Annotations (see #253 ) RFC 4180 support in CSV exporters (see #241 ) Many bugfixes Milestone details In the v0.10.0 scope, 19 issues were resolved and 7 pull requests were merged. This release includes 85 commits by 7 contributors. Resolved issues (19) #30 Better information when we haven't got a valid measurement #121 Strange # of \"Launches\" chosen with Count.Auto #154 PathTooLong exception on custom config #185 Report if difference between 2 benchmarks is statistically significance #241 .csv results output does not play well with Excel or Google Sheets #244 DefaultConfig StatisticColumn values #246 No namespace information? #265 Add ability to specify that benchmark requires STAThread #266 Don't assume that TargetType has reference to BenchmarkDotNet (assignee: @adamsitnik ) #268 Print runtime of child processes in summary #271 Params attribute does not handle nullable types #272 [Setup] error when doing inheritance #276 System.EntryPointNotFoundException #280 Cannot run on OSX / Mono (System.Xml.XmlException: Root element is missing) #281 Results are exported twice for single run #288 IdleWarmup running off forever #291 [Bug] Incorrect results for targetCount:Auto #292 Support for Beta versions #296 [BUG] NRE in OutliersAnalyser Merged pull requests (7) #253 Mark [Benchmark] as implying implicit use (by @roji ) #267 Make shipped assemblies have CLSCompliant(true) applied (by @lahma ) #277 Changed diagnosers flow, reduced heap allocations in Engine to 0 (by @adamsitnik ) #278 Support Atlassian flavored wiki markup (by @lahma ) #286 Mutable Job implementation (by @ig-sinicyn ) #287 Fix docs: job API changed (by @ig-sinicyn ) #293 Presenters: IFormattable support (by @ig-sinicyn ) Commits (85) a8b4e7 JsonExporters refactoring (by @AndreyAkinshin ) e6a4ae JsonExporters: add information about namespaces, resolves #246 (by @AndreyAkinshin ) 29ee0a Add Namespace column (by @AndreyAkinshin ) 26c333 Better error message (by @arthrp ) 12b313 Merge pull request #251 from arthrp/master (by @AndreyAkinshin ) 03d00c Mark [Benchmark] as implying implicit use (by @roji ) 394a93 Merge pull request #253 from roji/resharper-annotations (by @AndreyAkinshin ) 4912ea Remove unnecessary specific shell reference (by @factormystic ) 023115 Merge pull request #254 from factormystic/patch-1 (by @AndreyAkinshin ) 972fee Big refactoring (by @AndreyAkinshin ) cf839a Improved ranks (by @AndreyAkinshin ) ef3ecf Extended TimeInterval and Frequency API (by @AndreyAkinshin ) dfcc98 Minor fixes (by @AndreyAkinshin ) fb3757 Improved CSV export, fixes #241 (by @AndreyAkinshin ) f490d1 further root folder cleanup #228 (by @adamsitnik ) f7a6a0 Added [MeansImplicitUse] and explanation to summary for SetupAttribute and Cl... (by @adamsitnik ) 56b1f2 Configuration fix in JitOptimizationsTests (by @AndreyAkinshin ) faac58 Introduce AnaylyzeLaunchVariance (by @AndreyAkinshin ) 9953a9 Smart statistics in StatisticsColumnProvider (by @AndreyAkinshin ) 2a6578 Minor fixes in docs (by @AndreyAkinshin ) 03fb04 Introduce UnrollFactor (by @AndreyAkinshin ) 137636 NewLine fix in OutputLogger (by @AndreyAkinshin ) b35d52 Unique column support (by @AndreyAkinshin ) 24e944 Don't assume that TargetType has reference to BenchmarkDotNet, fixes #266 (by @adamsitnik ) 69330a Make shipped assemblies have CLSCompliant(true) applied (by @lahma ) fb8402 Merge pull request #267 from lahma/features/cls-compliancy (by @adamsitnik ) 0944b5 Make exported HTML valid, add alternating color to result table (by @lahma ) 748a2c Merge pull request #269 from lahma/features/html-export-enhancements (by @adamsitnik ) afff51 ExecutionValidator should not throw on overridden [Setup] methods, fixes #272 (by @adamsitnik ) ab9db4 Support nullable types as [Params], fixes #271 (by @adamsitnik ) ce4994 support for [STAThread], fixes #265 (by @adamsitnik ) 13fa5c move ConsoleHandler to separate file for better readability (by @adamsitnik ) 0e8e82 Print runtime of child processes in summary, fixes #268 (by @adamsitnik ) 491a28 Print more info about runtime of child processes in summary (and in a nicer w... (by @adamsitnik ) 0580a5 updated docs for #265 (by @adamsitnik ) f9baa6 catch native exceptions when determining clock type, #276 (by @adamsitnik ) 93a23d Check OS version in WindowsClock, fixed #276 (by @AndreyAkinshin ) 8d65fe changed diagnosers flow, possibility to hook up before jitting, after setup a... (by @adamsitnik ) f346ff added predefined attributes for diagnosers (by @adamsitnik ) e7cc6b Support Atlassian flavored wiki markup (by @lahma ) 376bd8 reduce memory allocated by Engine during run to increase MemoryDiagnoser accu... (by @adamsitnik ) b5ab55 display results when runing when no diagnoser is attached (by @adamsitnik ) 7ae2b5 Improved idle method for primitive types (by @AndreyAkinshin ) e1213a Fix NRE in BuildJobRuntimes (by @AndreyAkinshin ) 572fa4 Make code CLS-Compliant, fix CS3015 warning (by @AndreyAkinshin ) 4070a1 preload all settings in ctors, introduced IEngineFactory (by @adamsitnik ) 2f0df7 make Engine use InvocationCount (by @adamsitnik ) 8a7a12 calculate Statistics without allocations! makes the code look bad, but saves ... (by @adamsitnik ) d8fa70 remove last allocations from Engine.Run (by @adamsitnik ) f2a106 perform Jitting after first Setup call, better naming, test fix (by @adamsitnik ) be3ce3 introduce general catch with hopes to help with #280 (by @adamsitnik ) 3c5e70 post code review changes (by @adamsitnik ) 16e258 possibility to define custom Engine (by @adamsitnik ) afa586 Merge pull request #277 from PerfDotNet/diagnosersFlow (by @adamsitnik ) 534189 export files only once, not twice, fixes #281 (by @adamsitnik ) a733b5 Mutable Job implementation (by @ig-sinicyn ) 259647 Merge pull request #286 from ig-sinicyn/feature-mutable-characteristics (by @AndreyAkinshin ) c184b8 Fix docs: job API changed (by @ig-sinicyn ) 47b152 Merge pull request #287 from ig-sinicyn/fix-docs-jobs-updated (by @AndreyAkinshin ) 868ffc Jobs: WithXxx() extension methods added back, docs updated (by @ig-sinicyn ) eede54 Jobs: .With() methods now create new instances of the Job. (by @ig-sinicyn ) 40f160 Test fixed (by @ig-sinicyn ) fd92f7 Jobs: helper for .With() methods (by @ig-sinicyn ) 307b72 Merge pull request #289 from ig-sinicyn/features-jobs-with (by @AndreyAkinshin ) d576f5 Presenters: IFormattable support (by @ig-sinicyn ) 8647e7 Fix #291 (by @AndreyAkinshin ) 49c000 Merge pull request #293 from ig-sinicyn/fix-presenter-culture (by @AndreyAkinshin ) 684334 Merge pull request #278 from lahma/features/atlassian-wiki-markup (by @AndreyAkinshin ) 7f3ca5 Make BenchmarkRunnerCore.Run public (by @AndreyAkinshin ) 10a91e Allow using newer versions of Microsoft.NETCore.App, fixes #292 (by @adamsitnik ) 134d74 Misc improvements in Exporters (by @AndreyAkinshin ) 33c63f Respect RemoveOutliers in the RunResults (by @AndreyAkinshin ) 5e022b Fix #291, part 2 (by @AndreyAkinshin ) 4b6ea9 Improved name for the Id CharacteristicColumn (by @AndreyAkinshin ) af6f8a Fix some compilation warnings (by @AndreyAkinshin ) 2f8584 Analysers refactoring + OutliersAnalyser (by @AndreyAkinshin ) b11935 Make BenchmarkRunnerCore public (by @AndreyAkinshin ) 781740 Specify generated id for the default job (by @AndreyAkinshin ) 846255 JobTests.Test01Create fix (by @AndreyAkinshin ) 9f9544 Check if there is no MainTarget measurements in OutliersAnalyser, fixes #296 (by @AndreyAkinshin ) 503b04 Proper exception in GetStatistics for empty input, see #296 (by @AndreyAkinshin ) c667aa Fix path to logo (by @AndreyAkinshin ) 0b91c3 Fix null check in JobMode.ApplyCore (by @AndreyAkinshin ) 2edb56 Copyrights and links update (by @AndreyAkinshin ) 2edb9a Set library version: 0.10.0 (by @AndreyAkinshin ) Contributors (7) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Arthur ( @arthrp ) factormystic ( @factormystic ) ig-sinicyn ( @ig-sinicyn ) Marko Lahma ( @lahma ) Shay Rojansky ( @roji ) Thank you very much! Additional details Date: November 10, 2016 Milestone: v0.10.0 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.0 Online Documentation: https://dotnet.github.io/BenchmarkDotNet/ BenchmarkDotNet v0.9.9 Attribute config style (see #166 ) Online documentation (see #219 ) Mono LLVM support (see #226 ) Async method support (see #236 ) NuGet packages and repo layout restructuring (see #225 , #228 ) [Cleanup] attribute (see #215 ) New statistics columns: Skewness , Kurtosis , WelchTTestPValue , Improved math for the Scaled column Now current default branch is master Minor improvements and bug fixes Milestone details In the v0.9.9 scope, 14 issues were resolved and 1 pull requests were merged. This release includes 46 commits by 4 contributors. Resolved issues (14) #166 Suggestion: Attribute Config style (assignee: @AndreyAkinshin ) #215 Allow a [Cleanup] method to be specified #219 Online documentation and API reference #223 Add support for System.Type in Params #224 [Breaking change] BenchmarkAttribute become sealed. #225 Refactoring the roslyn dependency into another package #226 Support Mono/LLVM as a runtime/jit #227 Suggestion: change default branch (assignee: @AndreyAkinshin ) #228 Suggestion: clean up the root folder #231 Add references to default framework assemblies (System.Runtime etc) #232 Make all tests use OutputLogger (assignee: @adamsitnik ) #235 Don't show non-error output of dotnet cli (assignee: @adamsitnik ) #236 Possibility to benchmark asynchronous methods (assignee: @adamsitnik ) #240 Total Time reports hour rounded up Merged pull requests (1) #233 Add support of Cleanup attribute #215 (by @DenisIstomin ) Commits (46) f9f748 Improved \"Scaled\" column (by @AndreyAkinshin ) 5d7ba9 Warmup improvements (by @AndreyAkinshin ) 664c64 Add Skewness, Kurtosis, and WelchTTestPValue columns and configs (by @AndreyAkinshin ) c9e802 Attribute Config style, fixes #166 (by @AndreyAkinshin ) 378173 README: add supported OS (by @AndreyAkinshin ) 50ac57 Make Benchmark, Params and Setup attributes non-sealed again, fixes #224, #57 (by @adamsitnik ) b9c815 Support Mono/LLVM as a runtime/jit, fixes #226 (by @adamsitnik ) cdfbd5 Update info about default branch, see #227 (by @AndreyAkinshin ) 42e9b9 Add System.Type support in Params, fixes #223 (by @AndreyAkinshin ) db3dc3 Suggestion: clean up the root folder, fixes #228 (by @adamsitnik ) 4e1db3 use shorter names for test for xunit test runner (method name instead of full... (by @adamsitnik ) a35b22 make sure all framework assemblies are referenced, #231 (by @adamsitnik ) 19426a spliting BenchmarkDotNet.dll to few dlls to avoid mandatory Roslyn dependency... (by @adamsitnik ) 356a39 move BenchmarkRunner's core to separate class to .Core project so it can be ... (by @adamsitnik ) 0121a6 minor cleanup: rename LLVM => Llvm, remove [Obsolete] things (by @adamsitnik ) fb8047 Make all tests use OutputLogger, fixes #232 (by @adamsitnik ) ae17a7 Add support of Cleanup attribute, fix #215 (by @DenisIstomin ) 3bf9c0 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @adamsitnik ) 355c6f Don't show non-error output of dotnet cli, fixes #235 (by @adamsitnik ) 76df80 Possibility to benchmark asynchronous methods #236 (by @adamsitnik ) 3ab578 use GetAwaiter().GetResult() for Tasks instead of .Wait or .Result, #236 (by @adamsitnik ) d1db7d Added documentation source and output based on readme.md (by @FransBouma ) ac8cf2 Updated folder structure, removed html output, updated gitignore (by @FransBouma ) bed0f9 Removed unused folder copy directive from docnet.json (by @FransBouma ) 650fca Merge pull request #239 from FransBouma/master (by @AndreyAkinshin ) aceb96 Added Api docs generation directives (by @FransBouma ) a9ee7c Fix in total time formatting, fix #240 (by @AndreyAkinshin ) 1d2141 Update README.md (by @AndreyAkinshin ) 7b9fdb Fixed a couple of issues with api doc generation (by @FransBouma ) 682837 Merge pull request #243 from FransBouma/master (by @AndreyAkinshin ) 9a2cf2 docs improvements (by @AndreyAkinshin ) 334925 Rename: GarbageCollection -> GcMode (by @AndreyAkinshin ) 7a740a SummaryTableTests and minor refactorings (by @AndreyAkinshin ) c9d358 Transform GcModeColumn with null values to a trivial column (by @AndreyAkinshin ) cb6359 Improved HardwareTimerKind detection (by @AndreyAkinshin ) 04f736 Fix references in the IntegrationTests project files (by @AndreyAkinshin ) a9403a Fix warnings (by @AndreyAkinshin ) 691a05 BenchmarkDotNet.Tests: Remove the System.Globalization dependency (by @AndreyAkinshin ) 9e97d7 Show JitModules in EnvInfo only for the classic toolchain (by @AndreyAkinshin ) 823518 Improved docs (by @AndreyAkinshin ) 5fb854 Update README (by @AndreyAkinshin ) 5ebf8b Minor fixes (by @AndreyAkinshin ) 086dfd generic wrapper for config values (by @adamsitnik ) cf58b0 Merge branch 'gc' (by @adamsitnik ) bbccbe docs: add informations about NuGet packages (by @AndreyAkinshin ) 60bea3 Set library version: 0.9.9 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Denis Istomin ( @DenisIstomin ) Frans Bouma ( @FransBouma ) Thank you very much! Additional details Date: August 18, 2016 Milestone: v0.9.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.9 Online Documentation: https://perfdotnet.github.io/BenchmarkDotNet/ BenchmarkDotNet v0.9.8 CoreCLR RTM support (see #216 ). Breaking change: we have dropped dnx451 and dnxcore50 support. Migration from MSBuild to Roslyn, which supports Mono on Linux and MacOS (see #149 ). Breaking change: we have dropped .NET 4.0 support. Ability to manage GC mode: turn on/off the Server/Concurrent GC modes, extend to CPU groups, set gcAllowVeryLargeObjects and avoid BenchmarkDotNet from forcing GC.Collect (see #188 , #76 and #211 ) Support CopyToOutput (see #212 ). Now you can use native dependencies as well as custom files. Copying custom settings from app.config (see #108 ). It means we support assembly binding redirects as well as custom connection strings etc. AsciiDocExporter (see #169 ) Framework setting in Job has been removed (see #194 ) Minor bugfixes and improvements Milestone details In the v0.9.8 scope, 21 issues were resolved and 1 pull requests were merged. This release includes 69 commits by 5 contributors. Resolved issues (21) #57 Make Benchmark, Setup and Params attribute sealed in explicit way #76 Allow users to set gcAllowVeryLargeObjects for Runtime Settings (assignee: @AndreyAkinshin ) #77 Implement a C.I build (assignee: @mattwarren ) #108 Copy custom setting from app.config #131 [Mono] BenchmarkDotNet doesn't work on Mac OS #149 Migrate from MSBuild to Roslyn #174 NRE in Summary indexer property. #176 Split and simplify printed summaries #188 Ability to manage GC mode: turn on/off the Server/Concurrent GC modes and extend to CPU groups #191 MSBuild dependency - best way of fixing? #194 Framework settings in Jobs (assignee: @mattwarren ) #196 Allow specifying a gist url to RunUrl #197 Regression in 0.9.7: --help option fails under dotnet run #203 Third-party libraries must be explicitly included in test context to be loaded by runner #209 Fix appveyor bug #211 Possibility to turn off GC.Collect after each benchmark run (assignee: @adamsitnik ) #212 Support CopyToOutput #214 Benchmark ignores binding redirects #216 Update to .NET Core RTM (assignee: @adamsitnik ) #218 Errors in BenchmarkDotNet.Samples.FSharp.Core/projects.json #222 A problem with System.Threading.Tasks Merged pull requests (1) #169 Support export to asciidoc (by @russcam ) Commits (69) fcf48e Support export to asciidoc (by @russcam ) 590a0a Road to Roslyn: first attempt (by @AndreyAkinshin ) 704605 Added appveyor ci build (by @gigi81 ) 3859a1 Catch exception when accessing Console.WindowWidth, fixes #197 (by @mattwarren ) 7b92eb Filter tests by attribute (see #130) (by @mattwarren ) dd3464 Merge pull request #202 from gigi81/appveyor-build-2 (by @adamsitnik ) 29d106 Added missing 'build dependency' (by @gigi81 ) 2e8209 Merge pull request #205 from gigi81/fix-missing-dependency (by @AndreyAkinshin ) ff298d Appveyor build improvements (by @gigi81 ) 600cdd Merge pull request #206 from gigi81/appveyor-4 (by @AndreyAkinshin ) 68b070 Fixed tests not using OutputLogger (by @gigi81 ) 7d0501 Renamed _output to output (by @gigi81 ) ae5eab Merge pull request #207 from gigi81/fix-outputlogger (by @AndreyAkinshin ) dfe110 Small cleanup: remove compilation warnings (by @AndreyAkinshin ) ffe9f7 Clean up, part 2 (by @AndreyAkinshin ) 559f20 appveyor specific test fixes (by @AndreyAkinshin ) 38af24 MemoryDiagnoserTests: double.Parse Culture fix (by @AndreyAkinshin ) 02048d StatResultExtenderTests: SpeedUp (by @AndreyAkinshin ) f2b21f Clean up, part 3 (by @AndreyAkinshin ) d32328 SpeedUp: BaselineScaledColumnsTest, StatResultExtenderTests (by @AndreyAkinshin ) 5e37fa MemoryDiagnoserTests: additional parsing fixes (by @AndreyAkinshin ) 45c66f Merge branch 'develop' into Roslyn (by @adamsitnik ) a4cb8c MemoryDiagnoserTests: Temporarily suppressed (by @AndreyAkinshin ) ae38a5 README: add the appveyor badge (by @AndreyAkinshin ) 77bd64 README: update badges (by @AndreyAkinshin ) a74f82 README: update badges, part 2 (by @AndreyAkinshin ) 453a49 merging recent changes from develop with Roslyn branch to get it working again (by @adamsitnik ) ce4af5 add dependencies in recursive way, fixes #203 (by @adamsitnik ) a36af4 farewell MSBuid (by @adamsitnik ) d2dd83 Workaround for xunit bug (by @gigi81 ) 46f2b7 Merge pull request #210 from gigi81/xunit-workaround-2 (by @AndreyAkinshin ) c5b4ae Merge remote-tracking branch 'refs/remotes/origin/develop' into Roslyn (by @AndreyAkinshin ) 54109b copy custom settings from app.config file, fixes #108 (by @adamsitnik ) 20c41f enable GC settings customization, fixes #188 (by @adamsitnik ) dd0bc4 tests fix ;) (by @adamsitnik ) 0726b5 Possibility to turn off GC.Collect after each benchmark run, fixes #211 (by @adamsitnik ) da24b4 rename GC to GarbageCollection to avoid conflicts with System.GC (by @adamsitnik ) 3bf420 gcAllowVeryLargeObjects, fixes #76 (by @adamsitnik ) bdce98 split EnvironmentInfo into Host and Benchmark specific, make expensive method... (by @adamsitnik ) e819c8 added GC info to BenchmarkEnvironmentInfo (by @adamsitnik ) 9e0480 change GC settings display order (Workstation Concurrent => Concurrent Workst... (by @adamsitnik ) d03d17 support CopyToOutput: build in output directory + some refacotring, fixes #212 (by @adamsitnik ) 237370 minor bug fix: support spaces in parameters representation (by @adamsitnik ) 06349a Update to .NET Core RTM, drop DNX* support, fixes #216 (by @adamsitnik ) 106477 Merge branch 'develop' of https://github.com/russcam/BenchmarkDotNet into rus... (by @AndreyAkinshin ) 2e18db Merge branch 'russcam-develop' into develop (by @AndreyAkinshin ) 388155 Fix a NRE bug in Summary indexer, fixes #174 (by @AndreyAkinshin ) d448b4 Now RunUrl can work with non-raw github and gist urls, fixes #196 (by @AndreyAkinshin ) 7e1b95 Welch's Two Sample t-test (by @AndreyAkinshin ) cc70cb specify version of F# compiler in explicit way to workaround nuget bug, fixes... (by @adamsitnik ) e21373 use Roslyn's managed API for compilation, drop .NET 4.0 support!! fixes #149 (by @adamsitnik ) cd25cc use single reflection api after update to .NET 4.5 (by @adamsitnik ) 785d92 make Benchmark, Setup and Params Attribute sealed #57 (by @adamsitnik ) 8a3212 hopefully a workaround for appveyor build (by @adamsitnik ) ef7e35 hopefully a workaround for appveyor build, which does not have the latest dot... (by @adamsitnik ) 918a6d Remove xmlns for packages.config in IntegrationTests.Classic (by @AndreyAkinshin ) b897ed Merge branch 'Roslyn' into develop (by @adamsitnik ) 742a16 skip test that fails for Core on appveyor, #221 (by @adamsitnik ) a94a8b skip test that fails for Classic on appveyor, #221 (by @adamsitnik ) fec206 Fix incorrect xml-docs in MathHelper (by @AndreyAkinshin ) 1567d9 DEVELOPING.md: add a section about develop NuGet feed (by @AndreyAkinshin ) 5c3c31 appveyor: add BenchmarkDotNet.Diagnostics.Windows.nupkg to artifacts (by @AndreyAkinshin ) a69188 DEVELOPING.md: fix a typo (by @AndreyAkinshin ) 4e99b4 project.json: add tags (by @AndreyAkinshin ) 61b4c1 use System.Threading.Tasks as nuget package to fix nuget installation problem... (by @adamsitnik ) 976118 remove Framework settings from Jobs, fixes #194 (by @adamsitnik ) be0b71 try to remove the directory few more times when it's still not released to ma... (by @adamsitnik ) 0647a0 use the Configuration from the hosting process, not BDN dll (by @adamsitnik ) c6405a Set library version: 0.9.8 (by @AndreyAkinshin ) Contributors (5) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Luigi Grilli ( @gigi81 ) Matt Warren ( @mattwarren ) Russ Cam ( @russcam ) Thank you very much! Additional details Milestone: v0.9.8 Date: July 07, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.8 BenchmarkDotNet v0.9.7 .NET Core RC2 support (see #187 ) Bugfixes Milestone details In the v0.9.7 scope, 8 issues were resolved and 0 pull requests were merged. This release includes 27 commits by 3 contributors. Resolved issues (8) #168 Unable to run tests locally #170 Error handling in the spawned Benchmark process (assignee: @mattwarren ) #172 Ensure CsvMeasurementsExporter is enabled when RPlotExporter is used (assignee: @mattwarren ) #179 Job.GetAllProperties(): old property names are used #181 CompositeValidator: some validators will be skipped #183 [Suggestion] Make ValidationError public #187 .NET Core RC2 (assignee: @adamsitnik ) #192 Avoid creating .cs files at execution time Merged pull requests (0) Commits (27) 7568c0 Initial work on #130 (currently just matching existing behaviour) (by @mattwarren ) 34965e Fixes #170 (by @mattwarren ) 4d6d32 Remove \"@\" from the ProcessorName (by @AndreyAkinshin ) 57b402 Specify HintPath for all referenced assemblies (for mono support) (by @AndreyAkinshin ) 0d065b Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren ) c24a9c Less \"magic\" strings - Fixes #179 (by @mattwarren ) 1371ea Allow Exporters to have dependencies, fixes #172 (by @mattwarren ) d6a55c Further work on #130 (by @mattwarren ) e0ebd4 Tidy up of the Json exporter code (part of #189) (by @mattwarren ) ae330c Allow formatted/indented Json (see #189) (by @mattwarren ) 83fd20 Also allow args with \"--\", i.e. --exporters=json (see #189) (by @mattwarren ) 78af45 File missing from previous check-in \"ae330c4\" (#189) (by @mattwarren ) 9352d0 \"Measurments\" -> \"Measurements\" (by @mattwarren ) a34507 .NET Core RC2 support, fixes #187 (by @adamsitnik ) 0c9524 remove IValidationError interface, make the implementation public, fixes #183 (by @adamsitnik ) 30a6ec Avoid creating .cs files at execution time, fixes #192 (by @adamsitnik ) 792176 hiding CompositeValidator, fix few typos, fixes #181 (by @adamsitnik ) a345e7 Use short, hard coded name for folders to avoid PathTooLongEx if user does no... (by @adamsitnik ) 354b28 minor cleanup after moving to RC2 (by @adamsitnik ) 53b7ff dotnet cli bug workaround, Tornhoof's idea (by @adamsitnik ) 8e6d30 added missing Nuget feeds to NuGet.Config, removed launchSettings which we do... (by @adamsitnik ) 9addd0 Improvements in MethodInvoker (by @AndreyAkinshin ) ccd91d Update Chronometer.HardwareTimerKind (by @AndreyAkinshin ) e9db3d Update year in LICENSE.md (by @AndreyAkinshin ) acd019 updated docs for .NET Core RC2 #187 (by @adamsitnik ) 605aa1 README.md: add a link to BenchmarkDotNet.Diagnostics.Windows (by @AndreyAkinshin ) 571b3d Set library version: 0.9.7 (by @AndreyAkinshin ) Contributors (3) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Milestone: v0.9.7 Date: May 29, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.7 https://www.nuget.org/packages/BenchmarkDotNet/0.9.7-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.7 BenchmarkDotNet v0.9.6 Added Percentiles (see #164 ) Added support for Json export (see #84 ) Bugfixes Milestone details In the v0.9.6 scope, 11 issues were resolved and 2 pull requests were merged. This release includes 40 commits by 5 contributors. Resolved issues (11) #100 Code generation doesn't support generic classes #112 Generic benchmark classes are not supported #140 Readd an ability to define and to use custom Toolchain #141 [Request for comments] Assembly-level config attribute? #151 Crash during benchmark with baseline #152 MarkdownExporter.Default.ExportToLog fails with NRE for Summary with Critical Validation Errors #153 ManualConfig.Add(IConfig config) does not add the validators. #156 Cleanup benchmark folders #158 BaselineDiffColumn: NullReferenceException if one of the benchmark methods was failed. #161 Build warnings after update to 0.9.5 #171 Problem with ExceptionDispatchInfo (assignee: @AndreyAkinshin ) Merged pull requests (2) #138 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn ) #164 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn ) Commits (40) 9e625a copying validators when merging configs, fixes #153 (by @adamsitnik ) 5d0a7d returning empty objects instead of nulls, fixes #152 (by @adamsitnik ) cfff3b switching back to the old moniker that is supported not only by dnx and dotne... (by @adamsitnik ) 522fde Initial work on Json export (#84) (by @mattwarren ) 31452f Make SimpleJson build under \"DNXCore,Version=v5.0\" - (#84) (by @mattwarren ) 48b17a Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren ) d8dad6 removing ClrMD dependencies that were causing troubles with nuget package rel... (by @adamsitnik ) 0a81d4 removing ClrMd diagnosers, they are kept in clrmd branch (by @adamsitnik ) 972ea2 setting BenchmarkDotNet version to one that is not in the Nuget yet to get do... (by @adamsitnik ) 1e6581 Removing final traces or Runtime and Source SourceDiagnosers (by @mattwarren ) 3576d4 Make BaselineDiffColumn more robust - fixes #158 and #151 (by @mattwarren ) 3f0d7b Exclude \"BenchmarkDotNet.Artifacts\" folder (can get in the way when building) (by @mattwarren ) 00995d Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn ) 2410d4 Update project.json files (by @AndreyAkinshin ) ed75f6 Assembly-level config attribute, Fixes #141 (by @AndreyAkinshin ) 6f3a0c Add a BenchmarkSwitcher constructor for assembly, see #141 (by @AndreyAkinshin ) 4124d0 Catch InvalidOperationException in ClassicBuilder (by @AndreyAkinshin ) 9c8513 Cleanup benchmark folders (by default!), fixes #156 (by @adamsitnik ) d0179f merge KeepBenchmarkFiles and allow fluent api usage, #156 (by @adamsitnik ) b8130a Readd an ability to define and to use custom Toolchain, fixes #140 (by @adamsitnik ) 8a263b moving KeepBenchmarkFiles merge logic to Add method (by @adamsitnik ) e1e5c7 Sample & documentation for percentiles (by @ig-sinicyn ) 0d4262 Merge commit '00995dfac270ae71e81897348ec379cd97fb01c3' into feature-percentiles (by @ig-sinicyn ) 54b4f0 Merge pull request #164 from ig-sinicyn/feature-percentiles (by @AndreyAkinshin ) f8278c Generic benchmark support, fixes #100, fixes #112 (by @AndreyAkinshin ) c28056 Support Mono+.NET4.6 in CommonExtensions.ToStr. (by @AndreyAkinshin ) 285f77 set dependencies to MSBuild dlls as \"type\": \"build\" to make them implicit dep... (by @adamsitnik ) 42abd1 Merge remote-tracking branch 'refs/remotes/origin/develop' into develop (by @mattwarren ) 030d6c Rename \"GCDiagnoser\" -> \"MemoryDiagnoser\" (by @mattwarren ) 4e96e6 give compilation error instead of warning or exception at runtime (by @adamsitnik ) 0fbe10 Revert \"give compilation error instead of warning or exception at runtime\" (by @adamsitnik ) 19708a Tidy up of the Integration tests (by @mattwarren ) f7b3a4 Thread safe jobs, fixes #171 (by @AndreyAkinshin ) edf293 DisableTestParallelization for Classic integration tests to avoid races (by @adamsitnik ) 89165f moving dll that is required for custom path integration tests out of root folder (by @adamsitnik ) cbaa3b README: Add additional info about RPlotExprter (by @AndreyAkinshin ) 1cc936 The benchmark is improperly testing the Max operation because as all the numb... (by @redknightlois ) 40a1ea Merge pull request #173 from redknightlois/develop (by @AndreyAkinshin ) a9bf3b README: add information about the diagnostics package (by @AndreyAkinshin ) 5191bc Set library version: 0.9.6 (by @AndreyAkinshin ) Contributors (5) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) ig-sinicyn ( @ig-sinicyn ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Milestone: v0.9.6 Date: May 11, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.6 https://www.nuget.org/packages/BenchmarkDotNet/0.9.6-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.6 BenchmarkDotNet v0.9.5 Added validators, JitOptimizationsValidator detects all non-optimzied dlls that were referenced #134 Strong naming #101 Add IOrderProvider #107 Putting all the generated artifacts in a separate folder: ./BenchmarkDotNet.Artifacts/results and ./BenchmarkDotNet.Artifacts/bin #94 Printing dotnet cli version for .NET Core and Dnx451, informing user when not installed. Closed #128 Supporting assembly redirects #67 Changed used msbuild version: 12 for .NET 4.5 (VS 2013), 14 for .NET 4.6 (VS 2015). Closed #132 and #137 Switched to new ‘dotnet’ target framework monikers (dotnet5.4 instead of dnxcore50), why dnx452, dnx46, net462 support added Executing single Benchmark for multiple Runtimes also with Diagnoser attached (see #117 ) Misc minor changes Milestone details In the v0.9.5 scope, 13 issues were resolved and 0 pull requests were merged. This release includes 45 commits by 4 contributors. Resolved issues (13) #67 F# requiring assembly binding redirects for FSharp.Core #94 Put all the generated artifacts in a separate folder #101 Strong naming? #107 Specify benchmark method order #122 Reports: Move params columns next to Method column #128 Print dotnet cli version in EnvironmentInfo #129 Improve DnxAndCoreTests #132 [Bug] FileNotFoundException On 0.9.4. #134 [Feature request] Release builds only? #137 Brand new machine with VS 2015 only b0rks #142 [Suggestion] BenchmarkDotNet.Analyzers.IAnalyser - use same spelling for namespace and type? #148 Crash on [Params] with a string value that contains an invalid path char #150 Declaring nested enums and using them as parameter value make incorrectly generated code/ Merged pull requests (0) Commits (45) 2645ef use AutoGenerateBindingRedirects to avoid assembly conflicts, fixes #67 (by @adamsitnik ) 693b21 warn user if dotnet cli is not installed and print it's version in summary, f... (by @adamsitnik ) bfb017 target NET46 to reference msbuild 14 that comes with VS 2015 to make BDN work... (by @adamsitnik ) fceb3c fallback to bat if MSBuild dlls are not found + generate bat when needed (by @adamsitnik ) 49bdf0 restore: generating build script file (now for all runtimes) (by @adamsitnik ) b9b0bc scripts: cleanup -> build -> show failed tests if any ->cleanup, fixes #129 (by @adamsitnik ) ad64d8 Put all the generated artifacts in a separate folder, fixes #94 (by @adamsitnik ) 902de6 F# samples targeting .NET Core +classic F# part reorganization (by @adamsitnik ) b31c0b supported languages: updated readme & integration tests for Visual Basic (by @adamsitnik ) 24ade7 handle missing MSBuild.dll, get latest msbuild in fallback script scenario, s... (by @adamsitnik ) d371de Spelling mistake in errors message (see #139) (by @mattwarren ) c882dd core: dependencies cleanup + getting rid of warnings (by @adamsitnik ) b14e35 Add IOrderProvider, fixes #107 (by @AndreyAkinshin ) c95267 warn user if non-optimized dll is used, fixes #134 (by @adamsitnik ) 5876f5 Strong naming, fixes #101 (by @adamsitnik ) 036168 Analys(z)ers unification, lets use single spelling, fixes #142 (by @adamsitnik ) 2fa5c0 Update README.md (by @JohanLarsson ) 8b8641 Merge pull request #145 from JohanLarsson/master (by @AndreyAkinshin ) 734533 introducing Validators: validate benchmarks before running, return errors in ... (by @adamsitnik ) eaa943 ExecutionValidator: allow users to verify that all their benchmarks are runna... (by @adamsitnik ) e4fa4b support overriding with 'stronger' validators, eliminate duplicates (by @adamsitnik ) 57666a Add column order for SummaryTable, fixes #122 (by @AndreyAkinshin ) 62af92 Minor fixes in README (by @AndreyAkinshin ) 5e6877 updated README (by @adamsitnik ) 1255a4 Initial work on BenchmarkDotNet.Diagnostics.Windows rename (by @mattwarren ) 59ca8c Ensure renamed diagnostics dll is loaded (BenchmarkDotNet.Diagnostics.Windows... (by @mattwarren ) 825193 Added info about Diagnosers (by @mattwarren ) b836c5 Spelling/formatting (by @mattwarren ) 3f74c7 Fixing project.json (after I overwrite previous changes) (by @mattwarren ) c24a78 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren ) 8c678f reflecting recent Diagnosers->Diagnostics.Windows changes (by @adamsitnik ) 9bcdca Executing single Benchmark for multiple Runtimes [with Diagnoser attached] #117 (by @adamsitnik ) 4dffdb Switching to new ‘dotnet’ target framework monikers (by @adamsitnik ) 81b1e4 improved Runtimes descriptions + .NET 4.6.2 support (by @adamsitnik ) 8e92e1 dnx452 and dnx46 support (by @adamsitnik ) 06efde Fix in BaselineDiffColumnTest, see also #122 (by @AndreyAkinshin ) f79f83 DEVELOPING.md: use stable version of dotnet cli (by @AndreyAkinshin ) c2206d BenchmarkDotNet/project.json: correct version for System.IO.FileSystem (by @AndreyAkinshin ) 1b650d Support for nested Enums as Params values, fixes #150 (by @adamsitnik ) 76ef44 characters as Params support, including invalid path characters, fixes #148 (by @adamsitnik ) 14e45c Distinct jobs to avoid possible duplication when config is doubled (by @adamsitnik ) 837254 cleanup (by @adamsitnik ) d0cf6b added NETCore.Platforms dependency to make dotnet cli restore our Core projects (by @adamsitnik ) f7a20e replacing the chars that are invalid for file names, not only paths #148 (by @adamsitnik ) e31872 Set library version: 0.9.5 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Johan Larsson ( @JohanLarsson ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Milestone: v0.9.5 Date: May 02, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.5 https://www.nuget.org/packages/BenchmarkDotNet/0.9.5-beta BenchmarkDotNet v0.9.4 Improved messages about error in benchmarks, see #104 Natural sort order, see #92 , #95 , #97 Improved double / float / decimal / enum support for Params, see #96 , #105 , #116 Now environment info includes information about HardwareTimerKind and JitModules Added DryConfig Improved export performance, closed #119 , merged #124 Better cmd-line discoverability (see #78 ), e.g. run Benchmark.exe --help and some useful information will be printed Supporting all kinds of references for generated project (exact version, custom paths, GAC, sub-folders, dependent assemblies not copied), closed #41 , #49 , #72 , #123 , merged #125 Friendliness to LinqPad restored, closed #66 , merged #125 Milestone details In the v0.9.4 scope, 13 issues were resolved and 2 pull requests were merged. This release includes 55 commits by 4 contributors. Resolved issues (13) #41 Seems, not supported \"sub-folder\" #49 Dependent assemblies are not copied or added to the project file. #72 Referenced assembly dll-file (directly via file) not referenced in generated Program.csproj #78 Better command line discoverability (assignee: @mattwarren ) #92 Results in the R graphs aren't displayed in a \"Natural Sort Order\" #95 Results should preserve the order of param values definition #96 Implement enums as valid Param for test #97 Params changes an order #104 System.InvalidOperationException: StatSummary: Sequence contains no elements #105 Params Attribute bug with float type #116 Issue when ParamAttribute decorated property is double and current system culture has comma as decimal separator #119 For large benchmarks report exporting is very, very slow and has a massive Gen2 heap #123 Can not run benchmark that references custom framework library (like WindowsBase) Merged pull requests (2) #124 Faster export (by @adamsitnik ) #125 supporting all kinds of references for generated project (by @adamsitnik ) Commits (55) 74789d Sort results by Parameter, in a Natural Sort Order (by @mattwarren ) fec115 ParameterComparer refacotring (by @AndreyAkinshin ) 9d3856 Add information about JIT modules in EnvironmentHelper (by @AndreyAkinshin ) 7667ee Adding TraceEvent library for parsing ETW Events (by @mattwarren ) ae71f2 More work on the GC/Allocation diagnostics (by @mattwarren ) efa739 Allow diagnosers to be run from cmd line or via [Config(..)] (by @mattwarren ) 633f1c Throw an error when invalid Config(..) options are specified (by @mattwarren ) 04678a Add information about HardwareTimerKind (by @AndreyAkinshin ) 7f3cf0 Fix in GetCorrectTypeNameTest (by @AndreyAkinshin ) d9b890 Fix in HardwareTimerKind (by @AndreyAkinshin ) 416e36 Natural sort order for CsvMeasurementsExporter and plots, Fixed #92 (by @AndreyAkinshin ) dfc54a Ensure we sort the results by Method Name/Description (by @mattwarren ) fa6c62 Changed GCDiagnoser to inspect live ETW event stream instead of recording to ... (by @goldshtn ) d3f7ce Params: float/double/decimal support, Fixed #105 (by @AndreyAkinshin ) 7bce9b Params: enum support, Fixed #96 (by @AndreyAkinshin ) 4890dd Merge pull request #106 from goldshtn/develop (by @mattwarren ) 9072b9 More robust when a benchmark throws an exception (see #104) (by @mattwarren ) 2b9162 Work on #73 - highlighting in the Console output (by @mattwarren ) f62483 Work on #73 - highlighting in the Console output (by @mattwarren ) a639d5 Work on #73 - highlighting in Markdown output (by @mattwarren ) 1457fe Changing [ConfigWithDryJobs] -> [DryConfig] (by @mattwarren ) 396b7d Diagnostics for \"JIT In-lining\" events (by @mattwarren ) 7a1027 Merge remote-tracking branch 'origin/master' into develop (by @adamsitnik ) 6ec7f0 GC Diagnosers: reference to nuget package, unit test for both CLASSIC and DNX (by @adamsitnik ) 9e7059 Proper XML Doc comment for DryConfig attribute (by @mattwarren ) ad6be7 README.md: update (by @AndreyAkinshin ) a4d0b8 Merge branch 'master' into develop (by @adamsitnik ) 71e911 perf: CSV export: less allocations, reusing JobShortInfo (by @adamsitnik ) 409b5e perf: logging with less allocations (by @adamsitnik ) be6bfc perf: simpified LoggerWithPrefix, no need to check for multiple lines because... (by @adamsitnik ) ade8a1 perf: avoid string.Concat and string.PadLeft (by @adamsitnik ) f070eb perf: reuse AllProperties, reduced complexity (by @adamsitnik ) 57c88b perf: deffer export to enable continuous progress updates instead of single l... (by @adamsitnik ) 40071d loggers: final cleanup and fix for doubled new lines for diagnosers (by @adamsitnik ) c46854 supporting all kinds of references for generated project. This closes #49, cl... (by @adamsitnik ) a36e34 Initial work on better cmd line discoverability (part of #78) (by @mattwarren ) 3f0752 Better formatting in the Baseline column (by @mattwarren ) 8ab1a2 More samples (by @mattwarren ) 1981a3 Refactoring of ConfigParser code (part of #78) (by @mattwarren ) 3d1eba Allows \"Exporters\" and \"Analysers\" to be specified via cmd line (part of #78) (by @mattwarren ) 5d195a Allow \"all\" option, i.e. \"exporters=all\" (part of #78) (by @mattwarren ) 2146b8 Added some tests for ConfigParser (by @mattwarren ) 582e08 Merge pull request #124 from PerfDotNet/perf (by @AndreyAkinshin ) 84e67d README: Update team section (by @AndreyAkinshin ) 4d6001 README: add FAQ question (by @AndreyAkinshin ) 43ade3 BenchmarkDotNet.Samples: add #CLASSIC_RELEASE in launchSettings (by @AndreyAkinshin ) e3c2d1 README: some improvements (by @AndreyAkinshin ) c416c4 use the highest used target framework version to avoid framework mismatches +... (by @adamsitnik ) 8a49b3 Merge branch 'develop' into references (by @adamsitnik ) 23b2ea integration tests for complex references scenarios (by @adamsitnik ) ddfa4a classic: specify full name and use newer msbuild dlls to avoid calling extra bat (by @adamsitnik ) 79e8eb code cleanup after LINQPad 4 & 5 verification (by @adamsitnik ) 445137 Merge pull request #125 from PerfDotNet/references (by @AndreyAkinshin ) 4f1e1f Update package description (by @AndreyAkinshin ) 0f5531 Set library version: 0.9.4 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Sasha Goldshtein ( @goldshtn ) Thank you very much! Additional details Milestone: v0.9.4 Date: March 24, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.4 https://www.nuget.org/packages/BenchmarkDotNet/0.9.4-beta BenchmarkDotNet v0.9.3 CoreCLR support (Closed #52 , Merged #113 ) Milestone details In the v0.9.3 scope, 2 issues were resolved and 1 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (2) #52 CoreCLR Compatibility #114 Update NETStandard.Library dependency Merged pull requests (1) #113 Core Clr support (by @adamsitnik ) Commits (12) 5b6460 Core: compilable main project (by @adamsitnik ) cfdde6 Core: compilable samples and tests projects (by @adamsitnik ) ab8b26 Core: new profile for running Samples from VS (by @adamsitnik ) 9e1372 Core: new toolchain implementation with dnx451 code reuse (by @adamsitnik ) de8bcc Core: tests: script to run both dnx and core (by @adamsitnik ) 05d50f Core: dotnet cli supports only x64 now, workaround (by @adamsitnik ) 726c66 Core: executing only supported benchmarks (x86 and Legacy Jit are not supported) (by @adamsitnik ) de3371 Core: Dnx and Core as Runtimes, removed Toolchain configuration (by @adamsitnik ) e7a3a8 Core: generating path in Linux-friendly way ;) (by @adamsitnik ) fede7c Core: notify user when the process.Priority can not be set and continue execu... (by @adamsitnik ) d59827 Merge pull request #113 from PerfDotNet/coreclr (by @AndreyAkinshin ) 939891 Set library version: 0.9.3 (by @AndreyAkinshin ) Contributors (2) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Milestone: v0.9.3 Date: March 13, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.3 https://www.nuget.org/packages/BenchmarkDotNet/0.9.3-beta BenchmarkDotNet v0.9.2 Dnx451 support (Closed #51 , Merged #87 ) Milestone details In the v0.9.2 scope, 1 issues were resolved and 1 pull requests were merged. This release includes 48 commits by 2 contributors. Resolved issues (1) #51 DNX Compatibility Merged pull requests (1) #87 DNX451 support (by @adamsitnik ) Commits (48) f25427 road to DNX: part I: moving from csproj to xproj (by @adamsitnik ) 2fe5cf road to DNX: part II: added dnx451 target (DNX SDK running on .Net 4.5.1) (by @adamsitnik ) 6b4400 road to DNX: part II: the moment when Unit Test has shown up in VS! (by @adamsitnik ) c97792 road to DNX: part II: able to debug Samples (by @adamsitnik ) f901d6 road to DNX: part II: the moment when Integration Test has shown up in VS! (by @adamsitnik ) f46296 road to DNX: part II: including *.txt files as resources, excluding auto-gene... (by @adamsitnik ) cfc1b6 updated gitignore to exclude files created during integration tests run (by @adamsitnik ) 60b343 Road to DNX: benchmark execution : building project.json instead of .csproj (by @adamsitnik ) 0d41cb Road to DNX: benchmark execution : compiling project.json with Microsoft.Dnx.... (by @adamsitnik ) 31bc59 updated versions in .json files after sync with master, (by @adamsitnik ) c8e826 road to DNX: compilation: adding MetadataReferences for dlls required to comp... (by @adamsitnik ) 2ebe6c road to DNX: compilation: adding executing assembly as dependency to project.... (by @adamsitnik ) 76a74e Road to DNX: removing dependencies to BenchmarkDotNet.Diagnostics for DNX451 ... (by @adamsitnik ) 40419a road to DNX: handling \"nuget-like\" package versions that can contain text (as... (by @adamsitnik ) 8f06a7 it should have never happened but it does when debugging: DirectoryNotFoundEx... (by @adamsitnik ) 7c2a96 Road to DNX: reusing MS dnu to restore and build. Simple solution that just w... (by @adamsitnik ) e51d4d Road to DNX: alternative to MS dnu. reuses nuget and roslyn but as for now it... (by @adamsitnik ) ada7cb Road to DNX: replacing dnu build with dnx run. +putting files in a folder tha... (by @adamsitnik ) 18e969 road to DNX: referencing the right thing, bitness the same as hosting process (by @adamsitnik ) 8e870c road to DNX: setting the compiler EXPLICIT to finally make it WORKING (at lea... (by @adamsitnik ) 466d13 Road to DNX: removing failed PoC,dependencies cleanup, added some comments (by @adamsitnik ) 5b3675 Road to DNX: removing dependencies to MSBuild for DNX target, some project.js... (by @adamsitnik ) 3e65e8 road to DNU: reference project during development, but package when released (by @adamsitnik ) 617a61 road to DNX: logging output from dnu restore/dnx run + default timeout (by @adamsitnik ) 075cdc road to DNX: new value for toolchain enum: DNX451 (by @adamsitnik ) bd3fea road to DNX: being able to debug NET40 from VS (by @adamsitnik ) da5a9a road to DNX: copying all files that used to be copied in \".csproj times\" (by @adamsitnik ) 5d8717 road to DNX: new debug profile with DNX trace mode ON, use when troubleshooti... (by @adamsitnik ) 8272f6 road to DNX: fixing tests (by @adamsitnik ) 96bcf8 road to DNX: make sure that our child process get the right priority and affi... (by @adamsitnik ) cd0ba8 road to DNX: respecting specified benchmark processor architecture (by @adamsitnik ) b1eb28 road to DNX: added all output files from integration tests to .gitignore (by @adamsitnik ) aa62d1 fix for 4.0 (was passing arguments in wrong order) (by @adamsitnik ) 0c1251 merge (by @adamsitnik ) 46cd5e F# support, limited to existing tools possibilities (can not run from VS, onl... (by @adamsitnik ) 74020c Merge remote-tracking branch 'upstream/master' (by @adamsitnik ) 3402f0 replacing dnx with dotnet cli (by @adamsitnik ) d634f4 road to DNX: final cleanup (by @adamsitnik ) 24cd3a removing project.lock.json files (by @adamsitnik ) 80becb removing all .csproj & packages.config file + keeping only single .sln file (by @adamsitnik ) 9633d5 removing nuspec (now auto-generated by VS based on project.json) + version in... (by @adamsitnik ) 617d82 running Classic Framework tests from console + minor cleanup (by @adamsitnik ) fc9d98 DNX: running once compiled assembly directly without dotnet cli (perf+abble t... (by @adamsitnik ) 8adad8 dnx: Diagnosers support. Currently only these which do not need umanaged libs... (by @adamsitnik ) 34c3c9 DNX: changed folder of the auto-generated files to benchmark-specific + samples (by @adamsitnik ) 9cf009 DNX: description for development (by @adamsitnik ) 43af33 update to dotnet cli changes: output path and exit codes , now we set output... (by @adamsitnik ) f59d3e Merge pull request #87 from adamsitnik/master (by @AndreyAkinshin ) Contributors (2) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Milestone: v0.9.2 Date: March 5, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.2 BenchmarkDotNet v0.9.1 Milestone details In the v0.9.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 5 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (5) a0cfba use benchmarkSwitcher and 0.9.0 api features (by @cloudRoutine ) a88fc0 Merge pull request #89 from cloudRoutine/patch-1 (by @AndreyAkinshin ) 99d7c5 Improved ReflectionExtensions.GetCorrectTypeName; Fixed #90 (by @AndreyAkinshin ) 770510 Improved work with idle method that returns a value type; Fixed #70 (by @AndreyAkinshin ) 3c4410 Set library version: 0.9.1 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Jared Hester ( @cloudRoutine ) Thank you very much! Additional details Date: February 10, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.1 BenchmarkDotNet v0.9.0 New API Autodetermination of amount iteration for warmup/target idle/main iterations, duration of iteration, amount of CLR launches. Milestone details In the v0.9.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 4 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) 71369d Add benchmarks to tests different ways of accessing arrays. Copypasted from h... (by @alexandrnikitin ) 9a5930 Merge pull request #79 from alexandrnikitin/samples-array-access (by @AndreyAkinshin ) 1b8cf9 MathSummaryTests: fix output (by @AndreyAkinshin ) 92503b BenchmarkSwitcher improvements (by @AndreyAkinshin ) ebaeea Big API refactoring (by @AndreyAkinshin ) f149cb Big API refactoring, Part 2 (by @AndreyAkinshin ) 380d9a Big API refactoring, Part 3 (by @AndreyAkinshin ) 6cd2ce Big API refactoring, Part 4 (by @AndreyAkinshin ) 1665d8 Big API refactoring, Part 5 (by @AndreyAkinshin ) 140312 A better way of running a F# integration test (by @mattwarren ) 8e58ab Big API refactoring, Part 6 (by @AndreyAkinshin ) 9ec71b Add html export, resolved #75 (by @alinasmirnova ) 7ae4ed Merge pull request #86 from alinasmirnova/refactoring (by @AndreyAkinshin ) bfbc80 Big API refactoring, Part 7 (by @AndreyAkinshin ) 256ed4 Re-design of the IDiagnoser API (by @mattwarren ) f4bad8 Initial work on ETW Diagnostic Providers (by @mattwarren ) da2e3f Big API refactoring, Part 8 (by @AndreyAkinshin ) 5df553 Big API refactoring, Part 9 (by @AndreyAkinshin ) 120b7c Big API refactoring, Part 10 (by @AndreyAkinshin ) e61425 Big API refactoring, Part 11 (by @AndreyAkinshin ) 171ba0 Big API refactoring, Part 12 (by @AndreyAkinshin ) 854633 Big API refactoring, Part 13 (by @AndreyAkinshin ) caafa9 Fix a bug in Templates/BenchmarkProgram.txt (by @AndreyAkinshin ) 568c44 Add BenchmarkDotNet.Samples.FSharp (by @AndreyAkinshin ) 2fa773 Fix a bug in Generator (by @AndreyAkinshin ) 30e855 Update README (by @AndreyAkinshin ) 1164ef Update README (by @AndreyAkinshin ) 9c357c Improved plots for benchmarks with Params (by @AndreyAkinshin ) ef41f6 Fix a bug in ClassicBuilder (by @AndreyAkinshin ) 02babc Add BaselineDiffColumn.Scaled (by @AndreyAkinshin ) 4388c8 Remove construction with description in BenchmarkAttribute (by @AndreyAkinshin ) c9c25f Update README (by @AndreyAkinshin ) 1cef82 RPlotExporter improvements (by @AndreyAkinshin ) 173abf Set library version: 0.9.0 (by @AndreyAkinshin ) Contributors (4) Alexandr Nikitin ( @alexandrnikitin ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Date: February 9, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.0 BenchmarkDotNet v0.8.2 Changes in the Summary table Summary table now supports ResultExtenders that can add new column to the table Now we use StandardError (aka Error ) as the main accuracy metric Columns op/s , StdDev are disabled by default (you can add it via ResultExtenders) Statistic improvements, now you have detailed statistic in the console log like follows: Mean = 118.5298 us, StdError = 1.2863 us (N = 30, StdDev = 7.0454 us) Min = 109.1602 us, Median = 117.1794 us, Max = 132.5764 us IQR = 10.1244 us, LowerFence = 98.0834 us, UpperFence = 138.5810 us ConfidenceInterval = [116.0086 us; 121.0510 us] (CI 95%) Added the Baseline feature, see #64 Export improvements, now you have files <BenchmarkName>-report-github.md , <BenchmarkName>-report-stackoverflow.md for easy publishing results on GitHub and StackOverflow. Basic plotting. Added new BenchmarkRPlotExporter that creates BuildPlots.R in the bin directory. It is an R script that generates boxplot and barplot for your benchmarks (you should have installed R with defined R_HOME environment variable) Updated environment info Added Stopwatch Frequency and Resolution Split common benchmark properties (like Mode , Platform , Runtime ) in several lines (3 properties per line) Log improvements: add total time, statistics, list of exported files Bug fixes Milestone details In the v0.8.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 3 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) de0140 Add BenchmarkEnvironmentAnalyser (by @AndreyAkinshin ) 9ea78f Improved confidence intervals (by @AndreyAkinshin ) b8d4b6 Rename: PreWarmup -> Pilot (by @AndreyAkinshin ) 988efc Reporting: change StandardDeviation to StandardError (by @AndreyAkinshin ) 4da39d Big refactoring (by @AndreyAkinshin ) 6a0caa Add BenchmarkRPlotExporter (by @AndreyAkinshin ) 3a6ea4 Allow plugins to extend the Results Table (by @mattwarren ) 7a7991 Create a \"Result Extender\" plug-in for #64 (by @mattwarren ) 70ea89 Integration tests for #64 (by @mattwarren ) a2d0ec Separate class for string extensions. (by @alinasmirnova ) 5d6c78 Multiline prefix string extension. (by @alinasmirnova ) bdd84e New logger type for adding prefix. StackOverflow markdowns. (by @alinasmirnova ) ba9ec5 Move ExportToFile to ExporterBase. Add file suffix. (by @alinasmirnova ) 38cd8c GitHub markdown support. (by @alinasmirnova ) 732420 Markdown readme edits (by @alinasmirnova ) 541eef Merge pull request #71 from alinasmirnova/refactoring (by @AndreyAkinshin ) c53618 Merge remote-tracking branch 'refs/remotes/origin/develop' into refactoring (by @AndreyAkinshin ) e3f420 Samples: add Intro_08_Baseline (by @AndreyAkinshin ) 145b78 README: add NuGet badge (by @AndreyAkinshin ) b0e108 Minor fixes (by @AndreyAkinshin ) 565c25 Update README (by @AndreyAkinshin ) 045e2a Add BenchmarkStatResultExtender (by @AndreyAkinshin ) 20c6d2 Minor fixes (by @AndreyAkinshin ) f80edc Update README (by @AndreyAkinshin ) 3d2309 README: links to wiki (by @AndreyAkinshin ) d60d0f Fix bug in TimeUnit (by @AndreyAkinshin ) 034961 Unit tests for TimeUnit (by @AndreyAkinshin ) f2c6f1 Logs: add total time (by @AndreyAkinshin ) 140dec Merge branch 'refs/heads/refactoring' into develop (by @AndreyAkinshin ) 9e16e8 Ensure that the DeltaResultExtender doesn't throw (by @mattwarren ) 60f7c9 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren ) 77b24b Rollback of bad changes from the last merge (by @AndreyAkinshin ) 3df71a More robust way of wiring up BenchmarkBaselineDeltaResultExtender (by @mattwarren ) 8e5a0e Set library version: 0.8.2 (by @AndreyAkinshin ) Contributors (3) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Date: January 19, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.8.2 BenchmarkDotNet v0.8.1 Milestone details In the v0.8.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (12) 79ee93 README.md: small fixes (by @AndreyAkinshin ) a3e2dc Adding missing CLRMD binary dependencies (by @mattwarren ) 7492c1 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren ) ddae06 Lazy-load the Diagnostic plug-ins, fixes #63 (by @mattwarren ) 5df0df More robust version of the Diagnostic Library (see #53) (by @mattwarren ) 9f3ba0 Ensure that non-void SingleRun Benchmarks work (by @mattwarren ) de5bca Allow Benchmarks that use Inner classes (see #55) (by @mattwarren ) 5d000f Ensure we can run Benchmarks produced by F# (see #59) (by @mattwarren ) 8b0563 Added missing binary dependency (part of #59) (by @mattwarren ) 60047e Fixing #45 (by @mattwarren ) 3bede9 Implemented Ctrl-C handling in the Console (Fixes #50) (by @mattwarren ) 719391 Set library version: 0.8.1 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much! BenchmarkDotNet v0.8.0 Milestone details In the v0.8.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 67 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (67) 042631 Atomics sample (by @redknightlois ) 6ce693 Merge pull request #35 from redknightlois/master (by @AndreyAkinshin ) e73ce4 Update Intro_03_SingleRun (by @AndreyAkinshin ) add75c Samples: add Js_AsVsCast (by @AndreyAkinshin ) 1d4653 Samples: updates Js_AsVsCast (by @AndreyAkinshin ) 73f48f BenchmarkRuntime support (by @AndreyAkinshin ) 8e9fec BenchmarkRuntime: fix a bug (by @AndreyAkinshin ) 0d8a86 Added RotateBits (will be interested when https://github.com/dotnet/coreclr/i.. . (by @redknightlois ) 724970 Added and special case which we know it must not be optimized at all (for com... (by @redknightlois ) 30ba93 Merge pull request #43 from redknightlois/master (by @AndreyAkinshin ) a2338c Big refactoring (by @AndreyAkinshin ) dc8d02 Make the \"Getting Started\" guide read better (by @mattwarren ) 9883ca Update README.md (by @mattwarren ) 3cd76b Update README.md (by @mattwarren ) 6a3d00 Update README.md (by @mattwarren ) 7de832 Better way of generating Benchmark competition list (by @mattwarren ) 10ded0 Add Jit_GenericsMethod (by @AndreyAkinshin ) e5538b Fix for #42 (make benchmarks work in LINQPad) (by @mattwarren ) 873450 Make logging robust when strings contain '{' or '} (by @mattwarren ) 2ee55a Create a batch file that builds the benchmark (by @mattwarren ) d14b18 Adding \"Advanced Features\" section (by @mattwarren ) deb1a9 Sample benchmark for different types of loops (by @mattwarren ) 26e7b0 Move sample to correct namespace (by @mattwarren ) 505711 Grouping parameter results together (fixes #36) (by @mattwarren ) 1ee786 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren ) 496ae1 Add support for benchmarking methods of generic classes (#44) (by @mattwarren ) ad12e1 Return of the Params (by @AndreyAkinshin ) f80613 Little cleanup (by @AndreyAkinshin ) 52a076 Little refactoring (Flow -> Toolchain) (by @AndreyAkinshin ) 2f383e Moar samples (by @mattwarren ) 30b162 Initial work on code for asm/IL viewing (by @mattwarren ) 6a8873 Initial support for printing Assembly code (by @mattwarren ) 8cd841 Print diagnostic info (with flag \"-printDiagnostics\") (by @mattwarren ) 236043 Adding missing CLRMD dependancies (by @mattwarren ) 58b7a3 Print the method when we have a \"call\" asm instruction (by @mattwarren ) 1dae2b Change Jit_GenericsMethod benchmark to reproduce on x64 both Legacy & RuyJit (by @alexandrnikitin ) 6ae157 Merge pull request #47 from alexandrnikitin/samples-Jit_GenericsMethod-x64repro (by @AndreyAkinshin ) c39b7c README: add gitter link (by @AndreyAkinshin ) b0768e Ensure we \"close\" the code section in the markdown we generate (by @mattwarren ) 6c9ae7 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren ) 9ed66d Show how you can write \"Performance\" Unit Tests (by @mattwarren ) 7c9c6d Helper methods for Performance Unit Tests (by @mattwarren ) 3a2c75 Make Perf Unit Test more robust!! (by @mattwarren ) d1ddd3 Ensure the Description is used when sorting (if available) (by @mattwarren ) 27d662 Moving assembly viewer into BenchmarkDotNet.Diagnostics (by @mattwarren ) 1ef961 Load BenchmarkDotNet.Diagnostics dynamically (by @mattwarren ) 7eb70a New plugin system (by @AndreyAkinshin ) 2114d7 Fix typos in API (by @AndreyAkinshin ) e0a488 Fix in PerformanceUnitTest (by @AndreyAkinshin ) 02cddd BenchmarkDotNet.Tests: upgrade xunit to 2.1 (by @AndreyAkinshin ) 3d8ff2 IntegrationTests: replace GetTestOutput by AccumulationLogger (by @AndreyAkinshin ) 5ebf69 IntegrationTests: upgrade xunit to 2.1 (by @AndreyAkinshin ) 280834 Diagnostic refactoring (by @AndreyAkinshin ) 79ee42 Custom toolchains (by @AndreyAkinshin ) 527df6 Analysers (by @AndreyAkinshin ) 3d8199 Fix in BuildTable (by @AndreyAkinshin ) 699588 Tidy up of Source Diagnoser code (part of #53) (by @mattwarren ) 5ab029 Better way of getting the called method name (part of #53) (by @mattwarren ) 37f468 Integration test for Source Diagnostics (see #53) (by @mattwarren ) da0093 Spelling mistakes and remove unused using stmts (by @mattwarren ) fbf409 Fix typo in README (by @ForNeVeR ) 4895c6 Merge pull request #61 from ForNeVeR/patch-1 (by @AndreyAkinshin ) dd5f1f Rename: exec -> execute (by @AndreyAkinshin ) 6826a9 BenchmarkSwitcher: update the promt message (by @AndreyAkinshin ) f2a63f Update README.md (by @AndreyAkinshin ) 54cfdc Samples/Program.cs: small fix (by @AndreyAkinshin ) a927e9 Set library version: 0.8.0 (by @AndreyAkinshin ) Contributors (5) Alexandr Nikitin ( @alexandrnikitin ) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) Friedrich von Never ( @ForNeVeR ) Matt Warren ( @mattwarren ) Thank you very much! BenchmarkDotNet v0.7.8 Milestone details In the v0.7.8 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 36 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (36) 6ede76 Reporting: better number formats for ops/sec. (by @ppanyukov ) 118bc9 Merge pull request #17 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) 994cbc Markdown friendly reporting (by @AndreyAkinshin ) 91bbb4 Reporting: use fixed precision for AvrTime and StdDev. (by @ppanyukov ) e9b8fe Merge pull request #18 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) 121c3d Reporting: uniform time units across all benchmarks. (by @ppanyukov ) 1cb520 Merge pull request #21 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) a4f53e Reporting: refactor use of BenchmarkTimeSpan. (by @ppanyukov ) 7fbf63 Merge pull request #24 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) c8c893 message for Obsolete warning which tells what to use now + updated README (by @adamsitnik ) b48756 Merge pull request #26 from adamsitnik/master (by @AndreyAkinshin ) 36f849 Add Jit_RegistersVsStack (by @AndreyAkinshin ) 32cafc Allow a [Setup] method to be used on Benchmarks (by @mattwarren ) 8a14a8 Missed out of last commit (by @mattwarren ) 0103b7 Integration tests for [Setup] method closes #23, closes #7 (by @mattwarren ) 1e7c25 Display MSBuild errors in the console output, see #22 (by @mattwarren ) 876303 Added new benchmark for Stopwatch v DateTime (by @mattwarren ) e5f748 New ReportExporter system (by @AndreyAkinshin ) e0fdbc Add BenchmarkDotNet.Visualizer (by @AndreyAkinshin ) 954d08 Fix bug in op/s reporting (by @mattwarren ) d9dcf4 Tidying up BenchmarkDotNet.Samples layout see #29 (by @mattwarren ) 7abb1b Making Visualizer samples point to the new location (see #29) (by @mattwarren ) 96d5b9 Speed up the integration tests, closes #23 (by @mattwarren ) 2568a1 Initial work on Params attribute (see #8) (by @mattwarren ) 47fad8 Ensure Benchmarks with Params show up properly in Reports (by @mattwarren ) 36e060 Integration tests and sample for Params attribute (by @mattwarren ) 76ad88 Fixing some spelling mistakes (by @mattwarren ) 81e6eb Update BenchmarkProgram.txt (by @mattwarren ) 4008cf Merge pull request #32 from PerfDotNet/mattwarren-exception-handling (by @mattwarren ) 9e893e Statistic improvements (by @AndreyAkinshin ) 9ce9f9 Ensure that Params attribute can work with static fields/properties (by @mattwarren ) 7c3782 Update README.md (by @AndreyAkinshin ) 5a1783 Update Array_HeapAllocVsStackAlloc.cs (by @mattwarren ) 50ff16 Allow just number param in RunCompetitions. (by @vkkoshelev ) 04c306 Merge pull request #34 from vedun-z/master (by @AndreyAkinshin ) a630dc Set library version: 0.7.8 (by @AndreyAkinshin ) Contributors (5) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Philip Panyukov ( @ppanyukov ) vkkoshelev ( @vkkoshelev ) Thank you very much! BenchmarkDotNet v0.7.7 Milestone details In the v0.7.7 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 14 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (14) c94525 Add Cpu_BranchPerdictor (by @AndreyAkinshin ) 44cbb0 Add Algo_Md5VsSha256 (by @AndreyAkinshin ) 4d789c Most significant bit and bool to int conversions. (by @redknightlois ) 09446b Updated to avoid using an array. (by @redknightlois ) b16153 Fixed a bug where converting a bool to int instead to byte (which is the nati... (by @redknightlois ) 52acca Merge pull request #15 from redknightlois/master (by @AndreyAkinshin ) 66cce4 Fix troubles with inlining (by @AndreyAkinshin ) a8e641 Fixes in Jit_BoolToInt (by @AndreyAkinshin ) cfbb88 Rename task parameters: Current -> Host (by @AndreyAkinshin ) 209b4f Rename Task to BenchmarkTask, fix #9 (by @AndreyAkinshin ) 74be9d Fix typos (by @AndreyAkinshin ) adc6c2 Fix Intro_01_MethodTasks (by @AndreyAkinshin ) 438042 Add BenchmarkRunner.RunUrl (by @AndreyAkinshin ) 72d606 Set library version: 0.7.7 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) Thank you very much! BenchmarkDotNet v0.7.6 Milestone details In the v0.7.6 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 9 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (9) 8e9942 Update README.md (by @NN--- ) 51ef26 Merge pull request #11 from NN---/patch-2 (by @AndreyAkinshin ) db8791 Fixed link to samples. (by @redknightlois ) 14ddf4 Merge pull request #12 from redknightlois/patch-1 (by @mattwarren ) d70b4c Accessibility and genericness checks added for benchmark methods. (by @krk ) 04ce12 Benchmark methods defined in nested classes are supported. (by @krk ) a5caba Improvements in log parser (by @AndreyAkinshin ) d750b9 Merge pull request #13 from krk/master (by @AndreyAkinshin ) eab4bd Set library version: 0.7.6 (by @AndreyAkinshin ) Contributors (5) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) Kerem Kat ( @krk ) Matt Warren ( @mattwarren ) NN ( @NN--- ) Thank you very much! BenchmarkDotNet v0.7.5 Milestone details In the v0.7.5 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) 957a01 Update samples (by @AndreyAkinshin ) 118e2f Add the Cpu_Ilp_RyuJit sample (by @AndreyAkinshin ) b7e564 Update copyrights (by @AndreyAkinshin ) b6cce3 v0.7.5: Improved project building (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! BenchmarkDotNet v0.7.4 Milestone details In the v0.7.4 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) c5e924 Update README (by @AndreyAkinshin ) 641c95 v0.7.4: New benchmark Invoker, new samples, refactoring, minor fixes (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! BenchmarkDotNet v0.7.3 Milestone details In the v0.7.3 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 1 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (1) 42e13b v0.7.3: Small bug fixes (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! BenchmarkDotNet v0.7.2 Milestone details In the v0.7.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) 19f1e2 Add templates for BenchmarkProjectGenerator (by @AndreyAkinshin ) 043c04 v0.7.2: BenchmarkMode.Throughput, OperationCountAttribute, minor improvements... (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! BenchmarkDotNet v0.7.1 Milestone details In the v0.7.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) b2bc76 A bugfix (MSBuild fail case) (by @AndreyAkinshin ) ce7f58 Improved SingleRun (by @AndreyAkinshin ) 295cc2 Current values for JitVersion, Platform, and Framework (by @AndreyAkinshin ) 744eba Set library version: 0.7.1 (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! BenchmarkDotNet v0.7.0 Milestone details In the v0.7.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 59 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (59) 7f1c49 Add ShiftVsMultiplyBenchmark (by @AndreyAkinshin ) 21298c Renaming (by @AndreyAkinshin ) 86aada Add ReverseSortProgram (by @AndreyAkinshin ) 5830ef Add MakeRefVsBoxingProgram (by @AndreyAkinshin ) fe121e Automatic adjustment WarmUpIterationCount (by @AndreyAkinshin ) d3dd9c Improved console output (by @AndreyAkinshin ) 5e5df2 Update IncrementProgram (by @AndreyAkinshin ) dca61d Change Average statistic to Median (by @AndreyAkinshin ) 9d57e6 Update README.md (by @AndreyAkinshin ) 7cca77 StaticFieldProgram -> ArrayIterationProgram (by @AndreyAkinshin ) e02906 Add ForeachArray and ForeachList programs (by @AndreyAkinshin ) 8e3f6e Add StandardDeviation calculation (by @AndreyAkinshin ) 8b0c50 Add BenchmarkSettings singleton with DetailedMode property (by @AndreyAkinshin ) eae5bf Add useful arguments for console application (by @AndreyAkinshin ) 6f15f0 Update README.md (by @AndreyAkinshin ) c1c44b Add StackFrameProgram (by @AndreyAkinshin ) bbc6e7 Update StackFrameProgram (by @AndreyAkinshin ) 5f8121 Set version number and add NuGet package metadata (by @AndreyAkinshin ) 9425cb Add ProcessorAffinity to settings (by @AndreyAkinshin ) bcc037 Add single result benchmark mode (--single) and disable warmup mode (--disabl... (by @AndreyAkinshin ) 4ce0b4 Add build.bat for Benchmarks project (by @AndreyAkinshin ) 69fbc7 Add --output-file option (by @AndreyAkinshin ) df2092 Update build system (by @AndreyAkinshin ) addd25 Update run.bat (by @AndreyAkinshin ) b5c154 Add Mono support to run.bat (by @AndreyAkinshin ) a4b42a Update build system (by @AndreyAkinshin ) 65bbf7 Benchmarks: add support of selecting target program via number (by @AndreyAkinshin ) d4317b Add MedianTicks to CompetitionResult report in DetailedMode fixed #1 (by @AndreyAkinshin ) 3999e0 Update README.md (by @AndreyAkinshin ) bd7452 Update EnvironmentTickCount hack (by @AndreyAkinshin ) cf7aa6 Add CultureInfo setting (by @AndreyAkinshin ) 16bb5e Set BenchmarkDotNet version: 0.5.1 (by @AndreyAkinshin ) 07cf52 Add CompetitionBase: now competitions can be created in form of unit tests. (by @mijay ) 284b78 Full refactoring (by @AndreyAkinshin ) 2943d9 Add BenchmarkDotNet.Samples project (by @AndreyAkinshin ) 572483 Merge branch 'dev' (by @AndreyAkinshin ) 324d99 Remove ReflectionVsExpressionCompetition (by @AndreyAkinshin ) ce5c67 Add CacheConsiousBinarySearchCompetition (by @AndreyAkinshin ) ba8725 Add SelectVsConvertAllCompetition (by @AndreyAkinshin ) 60b002 Set BenchmarkDotNet version: 0.5.2 (by @AndreyAkinshin ) 3a4213 Fix in GetBenchmarkMethodClean (by @AndreyAkinshin ) 73ee56 Add BitCountCompetition (by @AndreyAkinshin ) 72836a Add missed Clean in BenchmarkCompetitionTask, Fixed #4 (by @AndreyAkinshin ) 1258cb Big refactoring (by @AndreyAkinshin ) 03bf14 Attributes renaming (by @AndreyAkinshin ) 98a3cd Improved environment info (by @AndreyAkinshin ) fe6e4e New benchmarks: ArrayBoundEliminationCompetition, InstructionLevelParallelism... (by @AndreyAkinshin ) c89054 Fix in EnvironmentHelper.GetConfiguration() (by @AndreyAkinshin ) 90d260 Add icon (by @AndreyAkinshin ) beb681 Improved WarmUp (by @AndreyAkinshin ) 7a63b6 Big refactoring (by @AndreyAkinshin ) 8197e5 Update samples (by @AndreyAkinshin ) c8d348 Add BenchmarkProperties (by @AndreyAkinshin ) 97c73a Update Cpu_InstructionLevelParallelism (by @AndreyAkinshin ) 957714 Small fixes (by @AndreyAkinshin ) fdf4dd Update README (by @AndreyAkinshin ) 8ac1ab Merge branch 'big-refactoring' (by @AndreyAkinshin ) 18a256 Small fixes (by @AndreyAkinshin ) 20df13 NuGet version: 0.7.0 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Mitya Kononchuk ( @mijay ) Thank you very much!"
  },
  "changelog/index.html": {
    "href": "changelog/index.html",
    "title": "ChangeLog | BenchmarkDotNet",
    "keywords": "ChangeLog BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.0 BenchmarkDotNet v0.12.1 BenchmarkDotNet v0.12.0 BenchmarkDotNet v0.11.5 BenchmarkDotNet v0.11.4 BenchmarkDotNet v0.11.3 BenchmarkDotNet v0.11.2 BenchmarkDotNet v0.11.1 BenchmarkDotNet v0.11.0 BenchmarkDotNet v0.10.14 BenchmarkDotNet v0.10.13 BenchmarkDotNet v0.10.12 BenchmarkDotNet v0.10.11 BenchmarkDotNet v0.10.10 BenchmarkDotNet v0.10.9 BenchmarkDotNet v0.10.8 BenchmarkDotNet v0.10.7 BenchmarkDotNet v0.10.6 BenchmarkDotNet v0.10.5 BenchmarkDotNet v0.10.4 BenchmarkDotNet v0.10.3 BenchmarkDotNet v0.10.2 BenchmarkDotNet v0.10.1 BenchmarkDotNet v0.10.0 BenchmarkDotNet v0.9.9 BenchmarkDotNet v0.9.8 BenchmarkDotNet v0.9.7 BenchmarkDotNet v0.9.6 BenchmarkDotNet v0.9.5 BenchmarkDotNet v0.9.4 BenchmarkDotNet v0.9.3 BenchmarkDotNet v0.9.2 BenchmarkDotNet v0.9.1 BenchmarkDotNet v0.9.0 BenchmarkDotNet v0.8.2 BenchmarkDotNet v0.8.1 BenchmarkDotNet v0.8.0 BenchmarkDotNet v0.7.8 BenchmarkDotNet v0.7.7 BenchmarkDotNet v0.7.6 BenchmarkDotNet v0.7.5 BenchmarkDotNet v0.7.4 BenchmarkDotNet v0.7.3 BenchmarkDotNet v0.7.2 BenchmarkDotNet v0.7.1 BenchmarkDotNet v0.7.0 Full ChangeLog"
  },
  "changelog/v0.10.0.html": {
    "href": "changelog/v0.10.0.html",
    "title": "BenchmarkDotNet v0.10.0 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.0 Now BenchmarkDotNet is a part of .NET Foundation Job and Column API refactoring (see new documentation) Measurement engine improvements Horology enhancement (see TimeInterval and Frequency ) Introduced RankColumn which is based on WelchTTest (see 157aabc3 ) JsonExporters refactoring (see the Exporters/Json section in the documentation) Renamed JsonExporters classed and attributes JsonExporters with custom settings JsonExporters now includes information about the target type namespace (see #246 ). Add JetBrains.Annotations (see #253 ) RFC 4180 support in CSV exporters (see #241 ) Many bugfixes Milestone details In the v0.10.0 scope, 19 issues were resolved and 7 pull requests were merged. This release includes 85 commits by 7 contributors. Resolved issues (19) #30 Better information when we haven't got a valid measurement #121 Strange # of \"Launches\" chosen with Count.Auto #154 PathTooLong exception on custom config #185 Report if difference between 2 benchmarks is statistically significance #241 .csv results output does not play well with Excel or Google Sheets #244 DefaultConfig StatisticColumn values #246 No namespace information? #265 Add ability to specify that benchmark requires STAThread #266 Don't assume that TargetType has reference to BenchmarkDotNet (assignee: @adamsitnik ) #268 Print runtime of child processes in summary #271 Params attribute does not handle nullable types #272 [Setup] error when doing inheritance #276 System.EntryPointNotFoundException #280 Cannot run on OSX / Mono (System.Xml.XmlException: Root element is missing) #281 Results are exported twice for single run #288 IdleWarmup running off forever #291 [Bug] Incorrect results for targetCount:Auto #292 Support for Beta versions #296 [BUG] NRE in OutliersAnalyser Merged pull requests (7) #253 Mark [Benchmark] as implying implicit use (by @roji ) #267 Make shipped assemblies have CLSCompliant(true) applied (by @lahma ) #277 Changed diagnosers flow, reduced heap allocations in Engine to 0 (by @adamsitnik ) #278 Support Atlassian flavored wiki markup (by @lahma ) #286 Mutable Job implementation (by @ig-sinicyn ) #287 Fix docs: job API changed (by @ig-sinicyn ) #293 Presenters: IFormattable support (by @ig-sinicyn ) Commits (85) a8b4e7 JsonExporters refactoring (by @AndreyAkinshin ) e6a4ae JsonExporters: add information about namespaces, resolves #246 (by @AndreyAkinshin ) 29ee0a Add Namespace column (by @AndreyAkinshin ) 26c333 Better error message (by @arthrp ) 12b313 Merge pull request #251 from arthrp/master (by @AndreyAkinshin ) 03d00c Mark [Benchmark] as implying implicit use (by @roji ) 394a93 Merge pull request #253 from roji/resharper-annotations (by @AndreyAkinshin ) 4912ea Remove unnecessary specific shell reference (by @factormystic ) 023115 Merge pull request #254 from factormystic/patch-1 (by @AndreyAkinshin ) 972fee Big refactoring (by @AndreyAkinshin ) cf839a Improved ranks (by @AndreyAkinshin ) ef3ecf Extended TimeInterval and Frequency API (by @AndreyAkinshin ) dfcc98 Minor fixes (by @AndreyAkinshin ) fb3757 Improved CSV export, fixes #241 (by @AndreyAkinshin ) f490d1 further root folder cleanup #228 (by @adamsitnik ) f7a6a0 Added [MeansImplicitUse] and explanation to summary for SetupAttribute and Cl... (by @adamsitnik ) 56b1f2 Configuration fix in JitOptimizationsTests (by @AndreyAkinshin ) faac58 Introduce AnaylyzeLaunchVariance (by @AndreyAkinshin ) 9953a9 Smart statistics in StatisticsColumnProvider (by @AndreyAkinshin ) 2a6578 Minor fixes in docs (by @AndreyAkinshin ) 03fb04 Introduce UnrollFactor (by @AndreyAkinshin ) 137636 NewLine fix in OutputLogger (by @AndreyAkinshin ) b35d52 Unique column support (by @AndreyAkinshin ) 24e944 Don't assume that TargetType has reference to BenchmarkDotNet, fixes #266 (by @adamsitnik ) 69330a Make shipped assemblies have CLSCompliant(true) applied (by @lahma ) fb8402 Merge pull request #267 from lahma/features/cls-compliancy (by @adamsitnik ) 0944b5 Make exported HTML valid, add alternating color to result table (by @lahma ) 748a2c Merge pull request #269 from lahma/features/html-export-enhancements (by @adamsitnik ) afff51 ExecutionValidator should not throw on overridden [Setup] methods, fixes #272 (by @adamsitnik ) ab9db4 Support nullable types as [Params], fixes #271 (by @adamsitnik ) ce4994 support for [STAThread], fixes #265 (by @adamsitnik ) 13fa5c move ConsoleHandler to separate file for better readability (by @adamsitnik ) 0e8e82 Print runtime of child processes in summary, fixes #268 (by @adamsitnik ) 491a28 Print more info about runtime of child processes in summary (and in a nicer w... (by @adamsitnik ) 0580a5 updated docs for #265 (by @adamsitnik ) f9baa6 catch native exceptions when determining clock type, #276 (by @adamsitnik ) 93a23d Check OS version in WindowsClock, fixed #276 (by @AndreyAkinshin ) 8d65fe changed diagnosers flow, possibility to hook up before jitting, after setup a... (by @adamsitnik ) f346ff added predefined attributes for diagnosers (by @adamsitnik ) e7cc6b Support Atlassian flavored wiki markup (by @lahma ) 376bd8 reduce memory allocated by Engine during run to increase MemoryDiagnoser accu... (by @adamsitnik ) b5ab55 display results when runing when no diagnoser is attached (by @adamsitnik ) 7ae2b5 Improved idle method for primitive types (by @AndreyAkinshin ) e1213a Fix NRE in BuildJobRuntimes (by @AndreyAkinshin ) 572fa4 Make code CLS-Compliant, fix CS3015 warning (by @AndreyAkinshin ) 4070a1 preload all settings in ctors, introduced IEngineFactory (by @adamsitnik ) 2f0df7 make Engine use InvocationCount (by @adamsitnik ) 8a7a12 calculate Statistics without allocations! makes the code look bad, but saves ... (by @adamsitnik ) d8fa70 remove last allocations from Engine.Run (by @adamsitnik ) f2a106 perform Jitting after first Setup call, better naming, test fix (by @adamsitnik ) be3ce3 introduce general catch with hopes to help with #280 (by @adamsitnik ) 3c5e70 post code review changes (by @adamsitnik ) 16e258 possibility to define custom Engine (by @adamsitnik ) afa586 Merge pull request #277 from PerfDotNet/diagnosersFlow (by @adamsitnik ) 534189 export files only once, not twice, fixes #281 (by @adamsitnik ) a733b5 Mutable Job implementation (by @ig-sinicyn ) 259647 Merge pull request #286 from ig-sinicyn/feature-mutable-characteristics (by @AndreyAkinshin ) c184b8 Fix docs: job API changed (by @ig-sinicyn ) 47b152 Merge pull request #287 from ig-sinicyn/fix-docs-jobs-updated (by @AndreyAkinshin ) 868ffc Jobs: WithXxx() extension methods added back, docs updated (by @ig-sinicyn ) eede54 Jobs: .With() methods now create new instances of the Job. (by @ig-sinicyn ) 40f160 Test fixed (by @ig-sinicyn ) fd92f7 Jobs: helper for .With() methods (by @ig-sinicyn ) 307b72 Merge pull request #289 from ig-sinicyn/features-jobs-with (by @AndreyAkinshin ) d576f5 Presenters: IFormattable support (by @ig-sinicyn ) 8647e7 Fix #291 (by @AndreyAkinshin ) 49c000 Merge pull request #293 from ig-sinicyn/fix-presenter-culture (by @AndreyAkinshin ) 684334 Merge pull request #278 from lahma/features/atlassian-wiki-markup (by @AndreyAkinshin ) 7f3ca5 Make BenchmarkRunnerCore.Run public (by @AndreyAkinshin ) 10a91e Allow using newer versions of Microsoft.NETCore.App, fixes #292 (by @adamsitnik ) 134d74 Misc improvements in Exporters (by @AndreyAkinshin ) 33c63f Respect RemoveOutliers in the RunResults (by @AndreyAkinshin ) 5e022b Fix #291, part 2 (by @AndreyAkinshin ) 4b6ea9 Improved name for the Id CharacteristicColumn (by @AndreyAkinshin ) af6f8a Fix some compilation warnings (by @AndreyAkinshin ) 2f8584 Analysers refactoring + OutliersAnalyser (by @AndreyAkinshin ) b11935 Make BenchmarkRunnerCore public (by @AndreyAkinshin ) 781740 Specify generated id for the default job (by @AndreyAkinshin ) 846255 JobTests.Test01Create fix (by @AndreyAkinshin ) 9f9544 Check if there is no MainTarget measurements in OutliersAnalyser, fixes #296 (by @AndreyAkinshin ) 503b04 Proper exception in GetStatistics for empty input, see #296 (by @AndreyAkinshin ) c667aa Fix path to logo (by @AndreyAkinshin ) 0b91c3 Fix null check in JobMode.ApplyCore (by @AndreyAkinshin ) 2edb56 Copyrights and links update (by @AndreyAkinshin ) 2edb9a Set library version: 0.10.0 (by @AndreyAkinshin ) Contributors (7) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Arthur ( @arthrp ) factormystic ( @factormystic ) ig-sinicyn ( @ig-sinicyn ) Marko Lahma ( @lahma ) Shay Rojansky ( @roji ) Thank you very much! Additional details Date: November 10, 2016 Milestone: v0.10.0 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.0 Online Documentation: https://dotnet.github.io/BenchmarkDotNet/"
  },
  "changelog/v0.10.1.html": {
    "href": "changelog/v0.10.1.html",
    "title": "BenchmarkDotNet v0.10.1 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.1 MemoryDiagnoser got improved. The changes: Memory Diagnoser is now part of BenchmarkDotNet.Core.dll, and it's enabled by default MemoryDiagnoser is 100% accurate about allocated memory when using default settings or Job.ShortRun or any longer job. (see #284 ) Memory Diagnoser no longer includes allocations from Cleanup/Setup methods (see #186 ) the results are now scaled so they are stable across the runs. (see #133 ) .NET Core 1.1+ support, we no longer support 1.0, we target netcoreapp1.1 now. Reason: we wanted to use GC.GetAllocatedBytesForCurrentThread in MemoryDiagnoser which is available only in 1.1+ Improved information about environment in summary Minor bugfixes Milestone details In the v0.10.1 scope, 9 issues were resolved and 2 pull requests were merged. This release includes 38 commits by 2 contributors. Resolved issues (9) #133 High differences between run for GC Diagnoser (assignee: @adamsitnik ) #186 GC Diagnoser should not include allocations done by Setup method (assignee: @adamsitnik ) #200 be accurate about allocated bytes/op (assignee: @adamsitnik ) #208 Troubles with MemoryDiagnoserTests (assignee: @adamsitnik ) #298 PlatformNotSupportedException when reading ProcessorAffinity on MacOS (assignee: @adamsitnik ) #301 netcoreapp1.1 support (assignee: @adamsitnik ) #309 Diagnosers don't export data to the measurements.csv files (assignee: @adamsitnik ) #312 RuntimeInformation can be made static and internal (assignee: @AndreyAkinshin ) #313 Bug in Generator (interface as a return type) (assignee: @AndreyAkinshin ) Merged pull requests (2) #284 built-in accurate and cross platform Memory Diagnoser (by @adamsitnik ) #314 Improved information about job environments in summary (by @AndreyAkinshin ) Commits (38) 23f3b2 built-in accurate and cross platform Memory Diagnoser, fixes #186, fixes #200 (by @adamsitnik ) 4cabc2 don't try to use AppDomain's Monitoring in Mono since it's not implemented there (by @adamsitnik ) 99c21e scale GC collections count / op, makes MemoryDiagnoser output stable for benc... (by @adamsitnik ) e91255 use per mille to make the Memory Diagnoser output more human-friendly + reduc... (by @adamsitnik ) a0536d Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik ) ade1be preallocate results list in more safe, but still ugly way (by @adamsitnik ) 102282 closed the ugly code in separate class (by @adamsitnik ) 7825b7 Update links in docs (by @AndreyAkinshin ) aaf720 Fix typo (by @AndreyAkinshin ) 1e2d38 update to netcoreapp1.1 in order to get universal cross platform memory diagn... (by @adamsitnik ) e69e80 don't show Gen 1 and Gen 2 columns if empty for all benchmarks (by @adamsitnik ) b10a84 PlatformNotSupportedException when reading ProcessorAffinity on MacOS, fixes ... (by @adamsitnik ) 2a529a update to .NET Core 1.1, fixes #301 (by @adamsitnik ) e6ccee always show Gen 0 column, display Gen 0/1/2 per 1k op (by @adamsitnik ) 3bcc59 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik ) a09810 make public things readonly, expensive things lazy and extend's validators in... (by @adamsitnik ) eae2cd added documentation and smarter bytes formatting (by @adamsitnik ) 1208c3 Merge branch 'master' into universalMemoryDiagnoser (by @adamsitnik ) f1f231 Merge pull request #284 from dotnet/universalMemoryDiagnoser (by @AndreyAkinshin ) 6300a2 include MemoryDiagnoser's results in CsvMeasurementsExporter, fixes #309 (by @adamsitnik ) ddb37e don't use spaces in columns names in CSV, #309 (by @adamsitnik ) 112f62 Fix stupid bug with condition for optional MedianColumn (by @AndreyAkinshin ) 60127c Remove Cpu_Ilp_RyuJit.cs because it's obsolete (by @AndreyAkinshin ) 401456 Print full information about a GenerateException (by @AndreyAkinshin ) 0b9177 Support of benchmark methods with an interface as a return type, fixed #313 (by @AndreyAkinshin ) b42b9e Improved information about job environments in summary (by @AndreyAkinshin ) 92f1db Improved information about job environments in summary, part 2 (by @AndreyAkinshin ) 5d8dd7 Merge pull request #314 from dotnet/summary (by @AndreyAkinshin ) d279f6 Make RuntimeInformation static internal, fix #312 (by @AndreyAkinshin ) 1df6ca Minor API improvements in BenchmarkSwitcher (by @AndreyAkinshin ) c12daf Dot't show the median column for the N=1 case (by @AndreyAkinshin ) 19caa2 RyuJit is always avaiable for .NET Core (by @adamsitnik ) 13e12c make JitOptimizationsValidator work for .NET Core (needed properties are avai... (by @adamsitnik ) c17b43 hide the AllocatedBytes column for Mono, show Gen 0 only if any of the benchm... (by @adamsitnik ) 29ac91 updated docs about Diagnosers in the Overview ;) (by @adamsitnik ) cc974e Improved information about job environments in summary, part 3 (by @AndreyAkinshin ) 8846af Update docs (by @AndreyAkinshin ) 37b126 Set library version: 0.10.1 (by @AndreyAkinshin ) Contributors (2) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Date: December 04, 2016 Milestone: v0.10.1 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.1"
  },
  "changelog/v0.10.10.html": {
    "href": "changelog/v0.10.10.html",
    "title": "BenchmarkDotNet v0.10.10 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.10 Highlights: Disassembly Diagnoser (read more here: Disassembling .NET Code with BenchmarkDotNet ) ParamsSources .NET Core x86 support Environment variables and Mono args support Better environment description More: additional sections in the documentation, bug fixes, build script improvements, internal refactoring. Overview post: BenchmarkDotNet v0.10.10 Milestone details In the v0.10.10 scope, 34 issues were resolved and 18 pull requests were merged. This release includes 95 commits by 11 contributors. Resolved issues (34) #160 Make ClrMd Source diagnoser working with new ClrMD api (assignee: @adamsitnik ) #167 Detect virtual machine environment (assignee: @lukasz-pyrzyk ) #262 Runtime knobs (assignee: @adamsitnik ) #310 Support 32bit benchmarks for .NET Core (assignee: @adamsitnik ) #350 ParamsSource (assignee: @adamsitnik ) #437 Add DisassemblyDiagnoser for outputting disassembled JITed code. (assignee: @adamsitnik ) #466 MSBuild parameters are not passed to generated benchmark project (assignee: @adamsitnik ) #495 Attributes put on base methods are not considered in derived class (assignee: @lukasz-pyrzyk ) #500 Borken compilation for net46 projects when .NET Framework 4.7 is installed (assignee: @adamsitnik ) #505 JsonExporterBase doesn't include MemoryDiagnoser stats in output #511 [bug] Bug in GetTargetedMatchingMethod() logic #513 IterationSetup not run in Job.InProcess #516 Get a compilation error \"CS1009: Unrecognized escape sequence\" when using verbatim strings #519 BenchmarkSwitcher.RunAllJoined throws InvalidOperationException (assignee: @AndreyAkinshin ) #526 Remove project.json support (assignee: @adamsitnik ) #529 No namespace in export filenames can lead to data loss #530 Build error on Appveyor with recent changes. #533 When I clone, build, and run BenchmarkDotNet.Samples I get an error #534 Allow the users to compare 32 vs 64 RyuJit for .NET Core (assignee: @adamsitnik ) #535 No way to set RuntimeFrameworkVersion in multiple-version config (assignee: @adamsitnik ) #536 Strange disassembly ordering/truncation (assignee: @adamsitnik ) #537 Can't benchmark a netstandard2.0 project (assignee: @adamsitnik ) #538 Duplicate using causing benchmark not to work (assignee: @adamsitnik ) #539 Target .NET Core 2.0 to take advantage of the new APIs (assignee: @adamsitnik ) #540 Artifacts for disassembler projects (assignee: @adamsitnik ) #542 Problems with Disassembler + Job.Dry (assignee: @adamsitnik ) #555 Test \"CanDisassembleAllMethodCalls\" fails on Ubuntu (assignee: @adamsitnik ) #556 Table in report is broken in VSCode markdown viewer (assignee: @adamsitnik ) #558 Warn the users when running Benchmarks from xUnit with shadow copy enabled (assignee: @adamsitnik ) #559 DissassemblyDiagnoser jit/arch info seems to be wrong (assignee: @adamsitnik ) #561 Strange behaviour when benchmark project is build in debug mode (assignee: @adamsitnik ) #562 DisassemblyDiagnoser crashes on overloaded benchmark (assignee: @adamsitnik ) #564 [Bug] Benchmarking a method doesn't run global setup when filter is applied (assignee: @adamsitnik ) #571 Allow users to use non compile-time constants as Parameters (assignee: @adamsitnik ) Merged pull requests (18) #507 Fix a typo in Jobs.md (by @aidmsu ) #508 Fixed some typos and grammar (by @lukasz-pyrzyk ) #512 Warning about antivirus software after benchmark failure (by @lukasz-pyrzyk ) #514 #495 - Unit test for reading attributes from the base class (by @lukasz-pyrzyk ) #515 Fix #513 - IterationSetup not run in Job.InProcess (by @ig-sinicyn ) #518 Fixed information about MemoryDiagnoser. (by @cincuranet ) #520 XML Exporter documentation and samples (by @Teknikaali ) #525 adding validator for setup cleanup attributes (by @ipjohnson ) #527 Detecting virtual machine hypervisor, #167 (by @lukasz-pyrzyk ) #531 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m ) #532 Fix type of local in EmitInvokeMultipleBody (by @pentp ) #547 Fix markdown headers (by @jawn ) #548 Fix condition in package reference list and update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system (by @Ky7m ) #549 Project files cleanup (by @Ky7m ) #552 Fix exporters to use fully qualified filenames (by @Teknikaali ) #563 Remove leading space character in a MD table row, #556 (by @rolshevsky ) #565 Single point of full config creation (by @ig-sinicyn ) #569 Update cakebuild scripts (by @Ky7m ) Commits (95) 682820 Fix typo in Jobs.md (by @aidmsu ) e82a8b Fixed some typos and grammar (by @lukasz-pyrzyk ) a0e9b9 Disassembly Diagnoser: displaying ASM, IL and C# for any JIT (by @adamsitnik ) 57e0f0 recursive disassembling (by @adamsitnik ) 1975ae return structured results from Disassembler (by @adamsitnik ) 9ae365 Warning about antivirus software after benchmark failure (#512) (by @lukasz-pyrzyk ) 74b41e Unit test for reading attributes from the base class, fixes #495 (by @lukasz-pyrzyk ) 3bab2d Fix #513 - IterationSetup not run in Job.InProcess (#515) (by @ig-sinicyn ) 769a39 use the IL instructions to detect more calls (by @adamsitnik ) b69537 use InstructionPointer to combine asm with hardware counters (by @adamsitnik ) 200244 Fixed information about MemoryDiagnoser. (by Jiri Cincura) 848a1a handling the lovely edge cases (Cecil vs ClrMD differences in naming types an... (by @adamsitnik ) 40049b single text representation of asm is a range of IPs! (by @adamsitnik ) 56e252 XML Exporter documentation and samples (#520) (by @Teknikaali ) c18597 eliminate duplicates (ClrMD fault), be more defensive for edge cases (by @adamsitnik ) a9262f allow the users to specify recursive depth limit (50MB output for simple lock... (by @adamsitnik ) fbe329 Support params which include slashes, fixes #516 (by @AndreyAkinshin ) f2b9c0 Fix RunAllJoined, fixes #519 (by @AndreyAkinshin ) 983764 UX ;) (by @adamsitnik ) c010de adding validator for setup cleanup attributes (by @ipjohnson ) 424723 Merge pull request #525 from ipjohnson/master (by @adamsitnik ) 7b680a prefer unit tests over integration tests if possible (by @adamsitnik ) 93dc6e Remove project.json support, fixes #526 (by @adamsitnik ) 19f22b Merge pull request #518 from cincuranet/docs (by @adamsitnik ) fe2db1 configurable, runtime specific diagnosers, hard part transparent to end users (by @adamsitnik ) fb60e5 disassembly diagnoser for Mono (by @adamsitnik ) 55ce0d smart diagnoser can choose the right disassembler (by @adamsitnik ) 46c911 one test to verify all scenarios (by @adamsitnik ) d06086 minor improvements (by @adamsitnik ) 116119 group instructions into maps for better visualization (by @adamsitnik ) d19b1e test fix: split on any new line ;) (by @adamsitnik ) 647a67 Merge branch 'asm' (by @adamsitnik ) 91c8e4 move disassembler stuff to resources of Core project to make it super easy to... (by @adamsitnik ) 363900 Remove --no-build argument for dotnet test & pack commands. (by @Ky7m ) 22e993 Disable parallel build option (by @Ky7m ) 9c327c Merge pull request #531 from Ky7m/removes-no-build-argument (by @adamsitnik ) 20db28 the docs for Disassembly Diagnoser, #437 (by @adamsitnik ) 13732b added asm report with navigation (by @adamsitnik ) 33ee03 fix type of local in EmitInvokeMultipleBody (by @pentp ) 7d943f Merge pull request #532 from pentp/master (by @adamsitnik ) 4d173d RyuJit 32bit support for .NET Core, fixes #310, fixes #533 (by @adamsitnik ) 5f5237 test fix (set platform in explicit way to avoid lack of 32-bit .NET Core sdk ... (by @adamsitnik ) f359c9 allow the users to set custom RuntimeFrameworkVersion, fixes #535 (by @adamsitnik ) 264150 disassembler: print the results in machine code order, not il, part of #536 (by @adamsitnik ) 0088bd Detecting virtual machine hypervisor, #167 (#527) (by @lukasz-pyrzyk ) 007444 print all returns (maps with negative ILOffset are not always prolog or epilo... (by @adamsitnik ) aebc32 empty methods for LegacyJit64 have only maps with negative ILOffset, #536 (by @adamsitnik ) ba7489 docs for Toolchains, closes #537 (by @adamsitnik ) 8c4f53 allow the users to specify custom build configuration, #466, close #528 (by @adamsitnik ) eb80b2 Environment Variables support, #262 (by @adamsitnik ) ab7045 test fixes ;) (by @adamsitnik ) 455c60 allow the users to specify custom arguments (Mono, MsBuild), #466, #262 (by @adamsitnik ) e03384 make sure that all new custom settings are presented in human friendly way, #262 (by @adamsitnik ) cc8d07 enforce TreatWarningsAsErrors=False in auto-generated csproj to override glob... (by @adamsitnik ) 97ab49 target .NET Core 2.0 to take full advantage of the new API, fixes #539 (by @adamsitnik ) 8b2c7e check if reference assemblies are installed when choosing the default .NET fr... (by @adamsitnik ) feabd1 bump the .NET Core version, #539 (by @adamsitnik ) a21f86 for .NET Core 1.1 we should run only the Backward Compatibility tests. #539 (by @adamsitnik ) b7a966 typo fix (by @adamsitnik ) 73a30a docs: Customizing Mono, Env Variables & minor updates, fixes #262 (by @adamsitnik ) 612b41 exclude Artifacts for disassembler projects, fixes #540 (by @adamsitnik ) 360326 typo, #540 (by @adamsitnik ) f3e4ae show nice error when Job.Dry is used for Disassembler, fixes #542 (by @adamsitnik ) c6bbda allow to specify custom dotnet cli path to compare RyuJit 32 vs 64 for .NET C... (by @adamsitnik ) a0c7e5 Add info about Redstone 3,4 in WindowsBrandVersions (by @AndreyAkinshin ) d42262 Additional info about WindowsBrandVersions (by @AndreyAkinshin ) cd0a1f Improve formatting in WindowsBrandVersions (by @AndreyAkinshin ) 1cd844 Fix OsBrandStringTests.WindowsIsPrettified (by @AndreyAkinshin ) f00787 Fix markdown headers (by @jawn ) 363814 Merge pull request #547 from jawn/patch-1 (by @adamsitnik ) 405c4c Update dotnet cli version from 1.0.4 to 2.0.0 for non-Windows system. (#548) (by @Ky7m ) 97a9b2 Fix compiler warning connected to problem with the XML tag. (by @Ky7m ) 24585d Remove PackageTargetFallback element. (by @Ky7m ) 174c19 Merge pull request #549 from Ky7m/csproj-files-cleanup (by @AndreyAkinshin ) 84a4e2 Fix exporters to use fully qualified filenames (#552), fixes #529 (by @Teknikaali ) a7578a disable Disassembler tests for non-Windows OS, fixes #555 (by @adamsitnik ) a147dd Remove leading space character in a MD table row, fixes #556 (by @rolshevsky ) 9c194c DisassemblyDiagnoser crashes on overloaded benchmark, fixes #562 (by @adamsitnik ) 9076a6 give users nice warning when they run into shadow copy issues, fixes #558 (by @adamsitnik ) 1670ca the build fix ;) (by @adamsitnik ) d5854d Include UBR in Windows versions (by @AndreyAkinshin ) 1fcfee display correct runtime info in exported disassembly result, fixes #559 (by @adamsitnik ) de45ad Single point of full config creation (#565) (by @ig-sinicyn ) 395a52 make sure filters don't exclude Setup/Cleanup methods, fixes #564 (by @adamsitnik ) 4276ac fail when running benchmarks in Debug with DefaultConfig, fixes #561 (by @adamsitnik ) 0145f8 Fix build number for Windows 10 Fall Creators Update (by @AndreyAkinshin ) 7f7a7c Update cakebuild scripts (#569) (by @Ky7m ) cff577 introduce ParamsSource attribute, fixes #350, part of #256 (by @adamsitnik ) 3af915 introduce IParam to support complex, not-compile time constants as parameters... (by @adamsitnik ) 4a877f build the disassemblers before .Core, but don't add the dependency to them to... (by @adamsitnik ) 188850 specify all the embedded resources in explicit way to avoid some crazy MSBuil... (by @adamsitnik ) b5fbbf Typo fix (by @AndreyAkinshin ) eb90ce Update message in JitOptimizationsValidator (by @AndreyAkinshin ) 6c1137 Updated DotSettings (by @AndreyAkinshin ) 3d0dfe Set library version: 0.10.10 (by @AndreyAkinshin ) Contributors (11) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Andrey Dorokhov ( @aidmsu ) Anssi Kettunen ( @Teknikaali ) Bernard Vander Beken ( @jawn ) Ian Johnson ( @ipjohnson ) ig-sinicyn ( @ig-sinicyn ) Igor Fesenko ( @Ky7m ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) Pent Ploompuu ( @pentp ) Rostislav Olshevsky ( @rolshevsky ) Thank you very much! Additional details Date: November 03, 2017 Milestone: v0.10.10 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.10 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.10"
  },
  "changelog/v0.10.11.html": {
    "href": "changelog/v0.10.11.html",
    "title": "BenchmarkDotNet v0.10.11 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.11 Highlights ByRef and Stack-only support ( #492 , sample ) .NET Core 2.1 support ( #587 ) Improved LINQPad support Smart logic for precision in ScaledColumn ( #509 , #590 ) Better macOS version detection ( 15d72388 ) Minor fixes and improvements Milestone details In the v0.10.11 scope, 6 issues were resolved and 8 pull requests were merged. This release includes 18 commits by 8 contributors. Resolved issues (6) #509 Better formatting for the Scaled column #579 Improve error message about non-optimized dependencies (assignee: @adamsitnik ) #580 How to get benchmarks running from LINQPad? (assignee: @adamsitnik ) #587 Support netcoreapp2.1 (assignee: @eerhardt ) #588 Broken appveyor build #593 BenchmarkDotNet is not working with LinqPad (assignee: @adamsitnik ) Merged pull requests (8) #492 ByRef and Stack-only support (by @adamsitnik ) #575 xUnit runner upgrade and small tests refactoring (by @Ky7m ) #584 Fixed typo. (by @cincuranet ) #589 Add support for netcoreapp2.1 (by @eerhardt ) #590 Add precision to Scaled Column (by @Chrisgozd ) #591 Fix CI build (by @Ky7m ) #592 Removed a xunit workaround because an issue has been fixed (by @AlekseiKudelia ) #597 Fix typo in WithCustomBuildConfiguration API (by @benjamin-hodgson ) Commits (18) 2a2e6c ByRef and Stack-only support (#492) (by @adamsitnik ) 676c77 xUnit runner upgrade and small tests refactoring (#575) (by @Ky7m ) 7a89cd Fixed typo. (by @cincuranet ) dd28b2 add better error text for non-optimized dlls + add it to FAQ, fixes #579 (by @adamsitnik ) 67e659 detect LINQPad problems and tell the user how to change them, fixes #580 (by @adamsitnik ) 543bd6 don't warn about non-optimized LINQPad dependency (it's OK), #580 (by @adamsitnik ) 8a94f2 Add support for netcoreapp2.1 (by @eerhardt ) fb39db Merge pull request #589 from eerhardt/SupportNetCoreApp21 (by @adamsitnik ) ef11f0 Add CoverageFilterXml in DotSettings (by @AndreyAkinshin ) 962b6a Update DotSetttings (by @AndreyAkinshin ) 717b62 BenchmarkDotNet.Horology cleanup (by @AndreyAkinshin ) d1720b Upgrade version to 2.0.3 and explicitly specify fx version for .netcoreapp2.0 (by @Ky7m ) 94d47a Removed a xunit workaround because an issue has been fixed (by @AlekseiKudelia ) 15d723 More details in GetOsVersion on macOS (by @AndreyAkinshin ) 696f89 Add precision to Scaled Column (#590) (by @Chrisgozd ) e54924 Fix typo in WithCustomBuildConfiguration API (by @benjamin-hodgson ) 8de978 Merge pull request #597 from benjamin-hodgson/patch-1 (by @adamsitnik ) af1510 Set library version: 0.10.11 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) AlekseiKudelia ( @AlekseiKudelia ) Andrey Akinshin ( @AndreyAkinshin ) Benjamin Hodgson ( @benjamin-hodgson ) Christopher Gozdziewski ( @Chrisgozd ) Eric Erhardt ( @eerhardt ) Igor Fesenko ( @Ky7m ) Jiri Cincura ↹ ( @cincuranet ) Thank you very much! Additional details Date: December 01, 2017 Milestone: v0.10.11 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.11 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.11"
  },
  "changelog/v0.10.12.html": {
    "href": "changelog/v0.10.12.html",
    "title": "BenchmarkDotNet v0.10.12 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.12 Overview post: BenchmarkDotNet v0.10.12 Highlights Improved DisassemblyDiagnoser: BenchmarkDotNet contains an embedded disassembler so that it can print assembly code for all benchmarks; it's not easy, but the disassembler evolves in every release. Improved MemoryDiagnoser: it has a better precision level, and it takes less time to evaluate memory allocations in a benchmark. New TailCallDiagnoser: now you get notifications when JIT applies the tail call optimizations to your methods. Better environment info: when your share performance results, it's very important to share information about your environment. The library generates the environment summary for you by default. Now it contains information about the amount of physical CPU, physical cores, and logic cores. If you run a benchmark on a virtual machine, you will get the name of the hypervisor (e.g., Hyper-V, VMware, or VirtualBox). Better summary table: one of the greatest features of BenchmarkDotNet is the summary table. It shows all important information about results in a compact and understandable form. Now it has better customization options: you can display relative performance of different environments (e.g., compare .NET Framework and .NET Core) and group benchmarks by categories. Milestone details In the v0.10.12 scope, 15 issues were resolved and 10 pull requests were merged. This release includes 42 commits by 9 contributors. Resolved issues (15) #273 Create a tail call diagnoser #442 Is it possible to configure benchmark to assign rank for runtime? (assignee: @AndreyAkinshin ) #543 Run Disassembly Diagnoser without extra run (assignee: @adamsitnik ) #546 Synthesizing labels for jump targets (assignee: @adamsitnik ) #574 Display VM hypervisor in summary section (assignee: @lukasz-pyrzyk ) #582 Print amount of logical and physical core (assignee: @morgan-kn ) #599 Proper HTML escaping of BenchmarkAttribute Description #606 Improve Memory Diagnoser (assignee: @adamsitnik ) #608 Properly escaping generated markdown (assignee: @AndreyAkinshin ) #612 Disassembler DisassembleMethod fails with \"Object reference not set to an instance of an object.\", (assignee: @adamsitnik ) #617 Allow baseline per category (assignee: @AndreyAkinshin ) #618 Enable ApprovalTests in .NET Core 2.0 tests (assignee: @AndreyAkinshin ) #621 Try to search for missing references if build fails (assignee: @adamsitnik ) #622 Support of new GC settings (assignee: @adamsitnik ) #623 RPlotExporter uses wrong path to csv measurements (assignee: @AndreyAkinshin ) Merged pull requests (10) #573 Сreate a tail call diagnoser (by @GeorgePlotnikov ) #576 Display VM name in summary section, fixes #574 (by @lukasz-pyrzyk ) #595 Migrate all project to new project system. (by @mfilippov ) #598 Added info about the new TailCallDiagnoser (by @GeorgePlotnikov ) #603 Fix HTML Encoding for Html Exporter (by @Chrisgozd ) #605 Grammar (by @onionhammer ) #607 Print amount of logical and physical core #582 (by @morgan-kn ) #615 Quick fix Disassembler.Program.GetMethod when more than one method found just return null (by @nietras ) #619 Logical group support, fixes #617 (by @AndreyAkinshin ) #620 New README.md (by @AndreyAkinshin ) Commits (42) 6f587d Migrate all project to new project system. (by @mfilippov ) 47ba57 added info about the new TailCallDiagnoser (by @GeorgePlotnikov ) c1a4b2 Сreate a tail call diagnoser (#573) (by @GeorgePlotnikov ) ebe3e2 Merge pull request #598 from GeorgePlotnikov/patch-1 (by @adamsitnik ) 6249f0 some polishing of the JIT diagnosers (by @adamsitnik ) 119231 Fix HTML Encoding for Html Exporter (#603), fixes #599 (by @Chrisgozd ) fe3f30 Disassembly Prettifier, fixes #546 (by @adamsitnik ) 3eb63f Merge pull request #595 from mfilippov/new-fs-vb-proj (by @adamsitnik ) 16d03f make our F# samples work for .NET Core 2.0 (by @adamsitnik ) d06de7 bring back our old Visual Basic and F# integration tests (by @adamsitnik ) 63249b \"Kaby Lake R\" and \"Coffee Lake\" support in ProcessorBrandStringHelper (by @AndreyAkinshin ) a8a09e disassembly prettifier: highlighting references to labels, jumping to next on... (by @adamsitnik ) e6d747 Grammar (by @onionhammer ) fef4aa Merge pull request #605 from onionhammer/patch-1 (by @adamsitnik ) ffacd7 don't require extra run for DisassemblyDiagnoser, fixes #543, #542 (by @adamsitnik ) bcac26 revert last commit change (run global setup regardless of Jitting) (by @adamsitnik ) 3e87d8 don't perform an extra run to get GC stats for .NET Core, part of #550 (by @adamsitnik ) f87dbc obtain GC stats in separate iteration run, no overhead, support for iteration... (by @adamsitnik ) e5fe0f update to C# 7.1 so we can use all the latest features (by @adamsitnik ) bc50b2 build benchmarks in Parallel, part of #550 (by @adamsitnik ) e59590 Display VM name in summary section, fixes #574 (#576) (by @lukasz-pyrzyk ) 8908f8 fix GetMethod (by @nietras ) 4ca82d Merge pull request #615 from nietras/disassembler-more-than-one-method-fix (by @adamsitnik ) 387ae5 be more defensive when trying to read source code with disassembler, part of ... (by @adamsitnik ) 703815 docs: how to contribute to disassembler (by @adamsitnik ) 242671 Enable ApprovalTests in .NET Core 2.0 tests, fixes #618 (by @AndreyAkinshin ) c4d21b Print amount of logical and physical core #582 (#607) (by @morgan-kn ) e33e84 Add HtmlReady dialect for MarkdownExporter, fixes #608 (by @AndreyAkinshin ) cf167b Enable html escaping for GitHub markdown dialect, fixes #608 (by @AndreyAkinshin ) 8bb28b Logical group support, fixes #617 (by @AndreyAkinshin ) ae87c6 Merge pull request #619 from dotnet/logical-groups (by @adamsitnik ) 14e90b parallel build post fix: don't write the compilation errors to NullLogger, re... (by @adamsitnik ) db4ae8 Try to search for missing references if build fails, fixes #621 (by @adamsitnik ) 0eba0f Support of new GC settings, fixes #622 (by @adamsitnik ) e31b2d Revert Samples/Program.cs (by @AndreyAkinshin ) 7f126b Add logs in RPlotExporter (by @AndreyAkinshin ) f8a447 Fix path to csv in RPlotExporter, fixes #623 (by @AndreyAkinshin ) 273f50 New plots in RPlotExporter (by @AndreyAkinshin ) f293f0 New README.md (#620) (by @AndreyAkinshin ) 5e3366 Update copyright year in docs (by @AndreyAkinshin ) ab7458 Update index in docs (by @AndreyAkinshin ) 4616d4 Set library version: 0.10.12 (by @AndreyAkinshin ) Contributors (9) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Christopher Gozdziewski ( @Chrisgozd ) Erik O'Leary ( @onionhammer ) George Plotnikov ( @GeorgePlotnikov ) Irina Ananeva ( @morgan-kn ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) Mikhail Filippov ( @mfilippov ) nietras ( @nietras ) Thank you very much! Additional details Date: January 15, 2018 Milestone: v0.10.12 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.12 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.12"
  },
  "changelog/v0.10.13.html": {
    "href": "changelog/v0.10.13.html",
    "title": "BenchmarkDotNet v0.10.13 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.13 Overview post: BenchmarkDotNet v0.10.13 Milestone details In the v0.10.13 scope, 15 issues were resolved and 9 pull requests were merged. This release includes 50 commits by 8 contributors. Resolved issues (15) #541 Mono Support for DisassemblyDiagnoser (assignee: @morgan-kn ) #614 Build fails with \"'Microsoft.NETCore.App', version '1.1.2' was not found\" probably due to 1.1.4 runtime not being available #626 Support Visual Basic project files (.vbroj) targeting .NET Core (assignee: @adamsitnik ) #630 Bug: Statistics.DivMean - NullReferenceException (assignee: @AndreyAkinshin ) #631 Bug: Generic benchmark class fails for DisassemblyDiagnoser with \"Sequence contains no matching element\" (assignee: @adamsitnik ) #632 ParamsSource no longer sorted in results (assignee: @AndreyAkinshin ) #634 Extend SummaryOrderPolicy (assignee: @adamsitnik ) #636 Unable to run Runner.exe --method MethodName (assignee: @adamsitnik ) #640 Disassembler fails with generic instance (assignee: @adamsitnik ) #643 BenchmarkDotNet should respect LangVersion project setting (assignee: @adamsitnik ) #644 BenchmarkDotNet.Mathematics.RankHelper again. (assignee: @AndreyAkinshin ) #648 BenchmarkDotNet requires dotnet cli toolchain to be installed (assignee: @adamsitnik ) #651 Support ANY CoreFX and CoreCLR builds (assignee: @adamsitnik ) #652 BenchmarkSwitcher should support generic types with parameterless public ctors (assignee: @adamsitnik ) #653 Proper way to run BenchmarkDotNet on macOS/Linux (assignee: @adamsitnik ) Merged pull requests (9) #624 Upgrade build tools (by @Ky7m ) #625 Fix xunit warnings connected to usage of Assert.Equal() to check for Null (by @Ky7m ) #633 HostEnvironmentInfo: remove LogicalCoreCount (by @morgan-kn ) #637 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn ) #639 Portability.Cpu tests improvements (by @morgan-kn ) #642 sync DataContracts to CopiedDataContracts (by @morgan-kn ) #645 Fixing --help display for options (by @ENikS ) #646 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAttribute (by @ENikS ) #666 Plots...Examples...Added A config example in F# (by @ScottHutchinson ) Commits (50) a26e82 Upgrade build tools: (by @Ky7m ) 1643cb Merge pull request #624 from Ky7m/upgrade-build-tools (by @adamsitnik ) abae51 Fix xunit warnings connected to usage of Assert.Equal() to check for null val... (by @Ky7m ) fb68bc support Visual Basic .NET Core projects, fixes #626 (by @adamsitnik ) 067a33 Remove redundant properties in common.props (by @AndreyAkinshin ) 80deb9 BuildNumber fix in common.props (by @AndreyAkinshin ) 87b458 Add CONTRIBUTING.md (by @AndreyAkinshin ) 8bcf42 Add CODE_OF_CONDUCT.md (by @AndreyAkinshin ) d3867d HostEnvironmentInfo: remove LogicalCoreCount (#633) (by @morgan-kn ) 06e66a Specify PLACE_SIMPLE_EMBEDDED_STATEMENT_ON_SAME_LINE in DotSettings (by @AndreyAkinshin ) d8ac43 Mono Support for DisassemblyDiagnoser #541 (by @morgan-kn ) 4356da Merge pull request #637 from morgan-kn/MonoSupportForDisassemblyDiagnoser (by @AndreyAkinshin ) 7572f4 Fix paths to images in docs (by @AndreyAkinshin ) f076df Portability.Cpu tests improvements (by morgan_kn) da6499 Merge pull request #639 from morgan-kn/TestsImprovment (by @AndreyAkinshin ) 5dd1a5 Disassembly Diagnoser: support for generic types, fixes #640 fixes #631 (by @adamsitnik ) 3c0e71 diassembly diangoser: different methods can have same metadata id, add type i... (by @adamsitnik ) 294801 test fix ;) (by @adamsitnik ) 9e66bb sync DataContracts to CopiedDataContracts (by @morgan-kn ) 690f34 Merge pull request #642 from morgan-kn/sync (by @adamsitnik ) e1e3e2 don't use type.Fullname for file names, it's too long for generics (by @adamsitnik ) 43d7c2 we restore before build, so build does need to restore too (it's new default ... (by @adamsitnik ) 9d4c33 trying harder to trick the JIT (#640, #631) (by @adamsitnik ) f8f70f Natural ordering for logical groups, fixes #632 (by @AndreyAkinshin ) a2ec34 copy LanguageVersion to the output .csproj, fixes #643 (by @adamsitnik ) 31e6dd Fixing --help display for options (#645), fixes #636 (by @ENikS ) 45ace9 Allow sorting by the Method name in DefaultOrderProvider and OrderProviderAtt... (by @ENikS ) 8811f2 Fix typo in docs/guide/Contributing/Disassembler.md (by @AndreyAkinshin ) 7da7b9 allow the users to customize Artifacts Path, #377 (by @adamsitnik ) 7554bf validate CustomDotNetCliPath, fixes #648 (by @adamsitnik ) 683964 Support ANY CoreFX and CoreCLR builds, fixes #651 (by @adamsitnik ) 695386 support also only custom CoreFX scenario (default runtime), part of #651 (by @adamsitnik ) eb4dcf allow the users to copy some files after the publish, part of #651 (by @adamsitnik ) b076a3 Add Newtonsoft.Json in the README (by @AndreyAkinshin ) b4eef5 better generics support, fixes #652 (by @adamsitnik ) 77fd46 Handle null values in Statistics.DivMean and Statistics.DivVariance, fixes #630 (by @AndreyAkinshin ) e547f8 Fix NRE in RankColumn, fixes #644 (by @AndreyAkinshin ) 28aa94 allow the users to choose .NET 4.7.1 (by @adamsitnik ) 503570 Fixed image link (by @svick ) 93cc85 Merge pull request #655 from svick/patch-1 (by @adamsitnik ) d33cde Fixed code block formatting (by @svick ) cb7c09 Merge pull request #657 from svick/patch-1 (by @adamsitnik ) 650b4a host Mono process should be able to build .NET Core child process, fixes #653 (by @adamsitnik ) d1dcab List formatting for FAQ (by @svick ) fe52e3 Merge pull request #663 from svick/faq-formatting (by @adamsitnik ) 7792cb Example in F#: with corrected code formatting (by @ScottHutchinson ) e6b225 Merge pull request #666 from ScottHutchinson/patch-2 (by @AndreyAkinshin ) f90207 Allow restore and build command override (#670) (by @BonnieSoftware ) 4443cd Update example in README (by @AndreyAkinshin ) de0b68 Set library version: 0.10.13 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) BonnieSoftware ( @BonnieSoftware ) Eugene Sadovoi ( @ENikS ) Igor Fesenko ( @Ky7m ) Irina Ananeva ( @morgan-kn ) Petr Onderka ( @svick ) Scott Hutchinson ( @ScottHutchinson ) Thank you very much! Additional details Date: March 02, 2018 Milestone: v0.10.13 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.13 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.13"
  },
  "changelog/v0.10.14.html": {
    "href": "changelog/v0.10.14.html",
    "title": "BenchmarkDotNet v0.10.14 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.14 Per-method parameterization ( Read more ) Console histograms and multimodal disribution detection Many improvements for Mono disassembly support on Windows ( Read more ) Many bugfixes Milestone details In the v0.10.14 scope, 8 issues were resolved and 11 pull requests were merged. This release includes 47 commits by 8 contributors. Resolved issues (8) #256 Per-method parameterization (assignee: @AndreyAkinshin ) #429 Detect multimodal distributions (assignee: @AndreyAkinshin ) #496 Integration with TravisCI (assignee: @jongalloway ) #684 Horology.ClockTests.ChronometerTest fails on Travis CI (macOS) (assignee: @AndreyAkinshin ) #689 DisassemblyDiagnoser for Mono does not work on Windows and Linux (assignee: @morgan-kn ) #691 Cannot run F# benchmarks when benchmark returns F# generic (assignee: @adamsitnik ) #697 Copy custom setting from app.config in multitarget projects (assignee: @adamsitnik ) #706 Support private builds of .NET Runtime (assignee: @adamsitnik ) Merged pull requests (11) #577 Arguments (by @adamsitnik ) #647 Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin ) #674 Cleanup suggested by VS2017 Code Analysis (plus one typo) (by @shoelzer ) #675 Fix IDE0034: 'default' expression can be simplified (by @shoelzer ) #676 Correct NodeTime text which links to NodaTime api (by @MishaHusiuk ) #681 Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) #682 Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) #683 Integration with TravisCI (by @Ky7m ) #694 Fix 689 (by @morgan-kn ) #695 Rename Program to UniqueProgramName to avoid conflicts, fixes #691 (by @adamsitnik ) #696 Build system: Update dotnet SDK and dotnet runtime. Enable FastTests netcoreapp1.1 on non-Windows. (by @Ky7m ) Commits (47) 41aeea Histograms and multimodal distribution detection, fixes #429 (by @AndreyAkinshin ) 960e58 Handle measurements with zero operations (by @AndreyAkinshin ) 19cddd Fix typo in BaselineScaledColumn.cs (by @dfederm ) a99594 Merge pull request #673 from dfederm/dfederm/fix-typo (by @AndreyAkinshin ) 5b3425 Cleanup suggested by VS2017 Code Analysis (plus one typo) (#674) (by @shoelzer ) 16b611 Fix IDE0034: 'default' expression can be simplified (by @shoelzer ) 048b32 Merge pull request #675 from shoelzer/master (by @AndreyAkinshin ) 9d5f71 Correct NodeTime text which links to NodaTime lib (by @MishaHusiuk ) c450c7 Merge pull request #676 from MishaHusiuk/patch-1 (by @adamsitnik ) 9fad52 Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) 3d906f Fix typo (Perdictor -> Predictor) (by @dmitry-ra ) d1a48e Merge pull request #681 from dmitry-ra/master (by @AndreyAkinshin ) 4ccd35 Merge pull request #682 from dmitry-ra/patch-1 (by @AndreyAkinshin ) f743a1 CakeBuild 0.24.0 -> 0.26.1 (by @Ky7m ) c5eb40 Remove postProjects from solution file. (by @Ky7m ) e60387 Pass correct configuration to test settings (by @Ky7m ) 224ab8 Disable public sign option for F# project (by @Ky7m ) ee98f3 Limit Max CPU count for msbuild workers (by @Ky7m ) 17031d Fix readme file (by @Ky7m ) 6fbae8 One more update to readme file (by @Ky7m ) cb90f2 disable Travis failing test #684 to unblock #683 (by @adamsitnik ) 782ca7 Merge pull request #683 from Ky7m/Integration-with-TravisCI (by @adamsitnik ) eebf92 Merge branch 'master' into multimodal (by @adamsitnik ) 10511b Merge pull request #647 from dotnet/multimodal (by @adamsitnik ) 57bc17 Fix bug in ClockTests.ChronometerTest, fixes #684 (by @AndreyAkinshin ) 7c4b14 Arguments (#577), fixes #256 (by @adamsitnik ) 40771c Update dotnet SDK (2.1.4 -> 2.1.101) and dotnet runtime (1.1.6 -> 1.1.7). (by @Ky7m ) 88a9db Merge pull request #696 from Ky7m/build-runtime-update (by @adamsitnik ) 4ac6ad we need different name than typical \"Program\" to avoid problems with referenc... (by @adamsitnik ) 1178d6 Update build badges (by @AndreyAkinshin ) 24ed1f ProcessHelper: handle null Data values in OutputDataReceived, fix #689 (by @morgan-kn ) 7a3d2b MonoDisassembler improvements (by @morgan-kn ) f1a0f5 Merge pull request #694 from morgan-kn/Fix689 (by @AndreyAkinshin ) 428905 .NET Core apps are .dlls (not .exes), fixes #697 (by @adamsitnik ) befbc8 Add FAQ notes about #692 (by @AndreyAkinshin ) b4504b Support private builds of .NET Runtime, fixes #706 (by @adamsitnik ) c93e1e Introduce separate logic for Windows10 brand strings (by @AndreyAkinshin ) 685766 Shortify Windows 10 brand strings in the summary (by @AndreyAkinshin ) 9bdd0c Shortify cpu info in summary (by @AndreyAkinshin ) 2288ad Prettify macOS brand string (by @AndreyAkinshin ) 8a0b48 Handle tailed nop instructions in mono disasm output (by @AndreyAkinshin ) d80834 Advanced DryJob attributes (by @AndreyAkinshin ) 9a37ad Handle invalid mono disasm outputs (by @AndreyAkinshin ) 21d6d7 Add IntroDisasm (by @AndreyAkinshin ) 5e37b5 Add \"Disassembly Diagnoser for Mono on Windows\" in docs (by @AndreyAkinshin ) c2c4e8 set COMPLUS_Version env var for private Clr builds even if no env vars were d... (by @adamsitnik ) 88b088 Set library version: 0.10.14 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) David Federman ( @dfederm ) Dmitry Razumikhin ( @dmitry-ra ) Igor Fesenko ( @Ky7m ) Irina Ananeva ( @morgan-kn ) MishaHusiuk ( @MishaHusiuk ) Steve Hoelzer ( @shoelzer ) Thank you very much! Additional details Date: April 09, 2018 Milestone: v0.10.14 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.14 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.14"
  },
  "changelog/v0.10.2.html": {
    "href": "changelog/v0.10.2.html",
    "title": "BenchmarkDotNet v0.10.2 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.2 Closed #307 : culture invariant statistics output Closed #321 : persist optimized, auto-generated dll compiled from url/plain code Closed #322 : always restore the console foreground color Closed #337 : Better detection of Rscript.exe in RPlotExporter Closed #345 : fix bug in WelchTTestPValueColumn for DryJob VS 2017 compatibility fix fix bold markup for Atlassian exporter Improved precision of nanobenchmarks Minor infrastructure changes and misc fixes Milestone details In the v0.10.2 scope, 10 issues were resolved and 3 pull requests were merged. This release includes 30 commits by 7 contributors. Resolved issues (10) #295 Fix CLS-compliant warnings in Diagnostics (assignee: @adamsitnik ) #307 Output: interpolated strings & culture (assignee: @alinasmirnova ) #319 [Request] some API to public? (assignee: @adamsitnik ) #321 BenchmarkRunner.RunUrl throws BenchmarkSystem.IO.FileNotFoundException (assignee: @adamsitnik ) #327 Unable to use ClassicToolchain in explicit way (assignee: @adamsitnik ) #332 default color of terminal is changed after the run is completed (assignee: @adamsitnik ) #335 Support benchmarking startup performance (assignee: @AndreyAkinshin ) #337 Problematic mechanism/docs for locating Rscript.exe #340 [FeatureRequest] Enable Characteristic-based properties for non-job types. (assignee: @ig-sinicyn ) #345 Fail to run IntroAdvancedStats in dry mode (assignee: @AndreyAkinshin ) Merged pull requests (3) #338 Fix typo (by @roji ) #339 Better detection of Rscript in RPlotExporter (by @roji ) #341 Base types for characteristic objects: (by @ig-sinicyn ) Commits (30) e7c398 Fixes parentheses error (by Josef Ottosson) 2655b3 Merge pull request #318 from joseftw/patch-1 (by @adamsitnik ) 4115a2 make GcStats and Net46Toolchain internal members public, fixes #319 (by @adamsitnik ) 52f953 ignore the CLS compilant errors for Diagnosers package, fixes #295 (by @adamsitnik ) d96b68 Improved Consumer (by @AndreyAkinshin ) 943c49 CLSCompliant fixes in Consumer (by @AndreyAkinshin ) f4bdae specify the .NET Core sdk version in explicit way to get the solution working... (by @adamsitnik ) df8c55 always restore the console foreground color, fixes #332 (by @adamsitnik ) 24dea4 fix bold markup for Atlassian exporter (by @lahma ) 4d3c75 persist optimized, auto-generated dll compiled from url/plain code, fixes #321 (by @adamsitnik ) 2e92a2 allow to set Classic/Roslyn tool chain in explicit way, fixes #327 (by @adamsitnik ) aabece Merge pull request #329 from lahma/features/atlassian-bold-format (by @adamsitnik ) 91152c ExportToFiles now accepts console logger (by @roji ) 299375 Base types for characteristic objects: (by @ig-sinicyn ) afc65d Better detection of Rscript.exe in RPlotExporter (by @roji ) 15869b Merge pull request #339 from roji/rscript-detect (by @AndreyAkinshin ) 9f6a82 Merge pull request #341 from ig-sinicyn/feature-characteristic-object (by @AndreyAkinshin ) 432adf Fix typo (by @roji ) cfa015 Merge pull request #338 from roji/dependencies-typo (by @AndreyAkinshin ) 4d953f Temporary rollback of the link to appveyor (by @AndreyAkinshin ) 1f5a6e Update year in docs footer (by @AndreyAkinshin ) 183ab6 Fix warning in RoslynToolchain (by @AndreyAkinshin ) 6fd9f3 Used ToStr to make statistics builder culture invariant (fixed #307) (by @alinasmirnova ) 3a3100 Merge pull request #346 from alinasmirnova/master (by @AndreyAkinshin ) 7ee2f1 Fix in WelchTTestPValueColumn for DryJob, fixes #345 (by @AndreyAkinshin ) 795f4a Disable jitting for RunStrategy=ColdStart, fixes #335 (by @AndreyAkinshin ) 5b5a8c Fixed typo (by @lukasz-pyrzyk ) 54519c Merge pull request #347 from lukasz-pyrzyk/master (by @adamsitnik ) fbac75 Introduced Dummy actions (by @AndreyAkinshin ) 484f53 Set library version: 0.10.2 (by @AndreyAkinshin ) Contributors (7) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) ig-sinicyn ( @ig-sinicyn ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) Marko Lahma ( @lahma ) Shay Rojansky ( @roji ) Thank you very much! Additional details Date: January 21, 2017 Milestone: v0.10.2 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.2"
  },
  "changelog/v0.10.3.html": {
    "href": "changelog/v0.10.3.html",
    "title": "BenchmarkDotNet v0.10.3 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.3 New .csprojs support for .NET Core. Also for F# ( #366 )! New plots and RPlotExporter (density plots for each job; cumulative mean plots) Fixed exporter order (now RPlotExporer uses the actual measurements instead of previous version) Xplat improvments in RuntimeInformation Introduced RunStrategy.Monitoring Possibility to set custom path for Mono ( #306 ) Possibility to set any .NET Core version >= 1.1 ( #336 ) MemoryDiagnoser is now disabled by default (Breaking changes!!) ( #369 ) Milestone details In the v0.10.3 scope, 10 issues were resolved and 2 pull requests were merged. This release includes 79 commits by 3 contributors. Resolved issues (10) #300 Switch back from project.json and xproj to csproj, support dotnet cli preview 3 (assignee: @adamsitnik ) #306 Custom path for mono (assignee: @adamsitnik ) #320 Results table should be a GitHub Flavored Markdown table (assignee: @alinasmirnova ) #322 First benchmark always fails when running on .NET Core with -c release (assignee: @adamsitnik ) #336 allow the users to choose the target .NET Core version (1.2, 2.0 etc) (assignee: @adamsitnik ) #366 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild) (assignee: @adamsitnik ) #369 Consider to disable MemoryDiagnoser by default (assignee: @adamsitnik ) #372 Troubles with ClrJob from CoreCLR project (assignee: @adamsitnik ) #374 BenchmarkDotNet doesn't understand netcoreapp2.0 (assignee: @adamsitnik ) #375 Troubles with dotnet pack (assignee: @adamsitnik ) Merged pull requests (2) #355 Fixed typo in IntroBasic.cs (by @mmayr-at ) #357 Farewell project json (by @adamsitnik ) Commits (79) 8099a5 Print process.StartInfo in Executor (by @AndreyAkinshin ) abd931 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 5c8c75 toolchains should not require parameterless ctors, the real fix for #327 (by @adamsitnik ) b22cf2 allow the users to choose the target .NET Core version, fixes #336 (by @adamsitnik ) f99c82 .net core toolchain: root folder detection bug fix (by @adamsitnik ) c7aba1 experimental .NET Core support for the new VS 2017 csproj files, #300 (by @adamsitnik ) bca146 Additional density plots in RPlotExporter (by @AndreyAkinshin ) 4bb147 Additional cummean plots in RPlotExporter (by @AndreyAkinshin ) 8bf40c Implement top sort in CompositeExporter (by @AndreyAkinshin ) ad771d Always print the AllocationColumn in the Summary table (if MemoryDiagnoser is... (by @AndreyAkinshin ) 8a1f0e Fix order of exporters in ExporterDependencyTests (by @AndreyAkinshin ) a7366e xproj to csproj auto migration (by @adamsitnik ) cec3e2 xproj to csproj: manual changes (conditional recursive dependencies not suppo... (by @adamsitnik ) 74006d xproj to csproj: I did not ask for the .NET Standard dependency (by @adamsitnik ) bf7093 xproj to csproj: manual changes (conditional dependencies not supported anymo... (by @adamsitnik ) 4e060f xproj to csproj: manual changes (simple case not supported) (by @adamsitnik ) 59602c remove F# .NET Core samples (not working now) (by @adamsitnik ) 2488ae cleanup (by @adamsitnik ) d7925b get our toolchain up and running, thanks to @cesarbs (by @adamsitnik ) e719e7 Update IntroBasic.cs (by @mmayr-at ) 1ef000 Merge pull request #355 from mmayr-at/patch-1 (by @AndreyAkinshin ) 5cf1dc making diagnosers, ctrl+c, custom priority and affinity work for the new csprojs (by @adamsitnik ) d0f334 getting net46 toolchain work again for new .csprojs when called from .NET Cor... (by @adamsitnik ) d1bf9b removing old project.json workarounds (by @adamsitnik ) e0b134 taking advantage of the csproj (by @adamsitnik ) 001b3f appveyor stuff (by @adamsitnik ) 63d674 don't introduce limit for .sln file search depth (by @adamsitnik ) 81adbb make VS stop complaining about root namespace for BenchmarkDotNet.Core project (by @adamsitnik ) 2eee5f let's round it to reduce the side effects of Allocation quantum (by @adamsitnik ) f38e93 a project that targets AnyCPU cany be referenced by any other executable (32 ... (by @adamsitnik ) 8ed5a4 post code review changes (by @adamsitnik ) 50c938 add possibility to use RetainVMGarbageCollection config switch (by @adamsitnik ) ca1bc8 final Cleanup and some renaming ;) (by @adamsitnik ) a26d61 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 008819 getting all the test runnable again (by @adamsitnik ) a66913 trying to get the versioning done right (by @adamsitnik ) c6f245 the updated docs (by @adamsitnik ) f1a1fd update to the latest xUnit 2.2 + minor cleanup (by @adamsitnik ) 262c87 appveyor config + minor bug fixes (by @adamsitnik ) 1a7bd4 Support the new .fsprojs targetting .NET Core (F# + .NET Core + MSBuild), fix... (by @adamsitnik ) e8f6ac support projects without .sln file (dotnet cli only) (by @adamsitnik ) 1b71c5 update our tests to net452 because XUnit VS runner 2.2 does no longer support... (by @adamsitnik ) 6121ad disable shadow copy for our integration tests (by @adamsitnik ) 54375c warn the users when code optimization was not enabled (debug build can be opt... (by @adamsitnik ) 03ed32 stop using --binaries option which started producing new folder for every re... (by @adamsitnik ) 27f280 dotnet cli like to not release used files for a while.. (by @adamsitnik ) 7886ad Merge pull request #357 from dotnet/farewellProjectJson (by @AndreyAkinshin ) 751f64 Xplat RuntimeInformation.GetProcessorName() (by @AndreyAkinshin ) b327b7 tell why dotnet command failed + how much time it took to execute (by @adamsitnik ) b740bb WindowsVersion on CoreCLR (by @AndreyAkinshin ) 5b879b Lazty HostEnvironmentInfo.OsVersion (by @AndreyAkinshin ) 76d081 Lazy HostEnvironmentInfo.OsVersion, fix in ToFormattedString() (by @AndreyAkinshin ) 5dafb9 do not restore or build the dependent projects, just the auto-generated one (by @adamsitnik ) 5c1914 better troubleshooting: when dll is not found but somehow build has succeeded... (by @adamsitnik ) 322998 using csproj to tell msbuild where to put output so appveyor custom settings ... (by @adamsitnik ) e2a8fa post code review changes (by @adamsitnik ) 6fe93d MinIterationTimeAnalyser (by @AndreyAkinshin ) 3ac892 RunStrategy.Monitoring (by @AndreyAkinshin ) f412b9 Docs: add FAQ section about supported version of Visual Studio (by @AndreyAkinshin ) 67a007 fixing ProjectJsonToolchains after recent CsProjToolchain optimizations (by @adamsitnik ) 2b5c6e Improved RuntimeInformation.GetProcessorName() (by @AndreyAkinshin ) a44638 Improved RuntimeInformation.GetOsVersion() (by @AndreyAkinshin ) f58e06 Improved RuntimeInformation.GetRuntimeVersion() for Mono (by @AndreyAkinshin ) fdca26 Minor RuntimeInformation fixes (by @AndreyAkinshin ) 2a2168 Fix bug in ExternalToolsHelper (by @AndreyAkinshin ) 9dfd95 Custom path for mono, fixes #306 (by @adamsitnik ) 448b07 disable MemoryDiagnoser by default, BREAKING CHANGE, fixes #369 (by @adamsitnik ) 125b71 docs for Custom Mono Paths, #306 (by @adamsitnik ) a3d6e0 docs/FAQ: Add section about new .NET Core Console App in VS2017 (by @AndreyAkinshin ) b04195 give users the AnyCpu hint when they struggle with BadImageFormatException, f... (by @adamsitnik ) 7de671 generate the projects in the bin folder, not solution's root (by @adamsitnik ) 1d52ae docs/FAQ: add another question (by @AndreyAkinshin ) 06aaa0 copy NetCoreAppImplicitPackageVersion and RuntimeFrameworkVersion settings to... (by @adamsitnik ) f1fe16 shame on me for not building the code for all TFMs before pushing (by @adamsitnik ) fe33dd GitHub Markdown: every table row should start with \"|\" , fixes #320 (by @adamsitnik ) 7d0d73 remove old results, otherwise, the file will be overwritten and remaining old... (by @adamsitnik ) 80348b Change Hint color to DarkCyan #376 (by @AndreyAkinshin ) 0b35ec Increase MinIterationTime (Accuracy improvement) (by @AndreyAkinshin ) cdee09 Set library version: 0.10.3 (by @AndreyAkinshin ) Contributors (3) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Michael Mayr ( @mmayr-at ) Thank you very much! Additional details Date: March 01, 2017 Milestone: v0.10.3 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.3"
  },
  "changelog/v0.10.4.html": {
    "href": "changelog/v0.10.4.html",
    "title": "BenchmarkDotNet v0.10.4 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.4 New logo Update to Roslyn 2.0, drop .NET 4.5 support ( #303 ) Initial support of HardwareCounters (Windows only) Initial experimental support of in-process benchmarks Optional configs for BenchmarkSwitcher ( #391 , #392 ) Host API interface ( #356 ) Improved measurements for async benchmarks ( #415 ) Improved precision level (MinIterationTimes is 500ms instead of 200ms; introduced AccuracyMode.MaxAbsoluteError and AccuracyMode.MaxRelativeError instead of AccuracyMode.MaxStdErrRelative ; logic which select amount of iterations uses confidence intervals instead of standard errors; the Error column (half of CI99.9%) is shown by default instead of StdErr) Introduced ISummaryStyle , raw data in CSV reports ( #118 , #146 , #396 ) Handle cases when report files are existed and locked ( #414 , #416 ) MarkdownExporter right-justifies numeric columns ( #421 ) Better colors for console output ( #376 ) Column legends Add information about CPU microarchitecture for well-known processors to summary Fix AssemblyInformationalVersionAttribute ( #382 ) Fix incorrect method filtering in BenchmarkSwitcher ( #365 ) Fix OS Version in Summary for Windows 10 ( #351 ) Fix OS Version on Mono Fix --class and --method filtering ( #249 ) Fix --exporters option ( #189 ) Fix escaping logic in CsvExporter ( #294 , #409 ) Fix MacOS detection Minor bugfixes and API improvements Milestone details In the v0.10.4 scope, 23 issues were resolved and 14 pull requests were merged. This release includes 103 commits by 8 contributors. Resolved issues (23) #118 Raw data in CSV reports (assignee: @AmadeusW ) #146 Ability to specify units / easier comparison (assignee: @AmadeusW ) #159 Warn user if no Columns were defined (assignee: @adamsitnik ) #189 --exporters option appears not to be working (assignee: @adamsitnik ) #249 --class and --method should combine as \"AND\" filtering (assignee: @adamsitnik ) #294 [Suggestion] CSVHelper.Escape() method should check for actual separator value (assignee: @alinasmirnova ) #303 Update to Roslyn 2.0 when RTM is shipped to nuget.org (assignee: @adamsitnik ) #351 Fix OS Version in Summary for Windows 10 (assignee: @adamsitnik ) #352 Troubles with CoreJob on Linux (assignee: @adamsitnik ) #365 [Minor bug] Benchmark switcher: incorrect method filtering (assignee: @adamsitnik ) #376 Pick better background colors for output (assignee: @AndreyAkinshin ) #382 AssemblyInformationalVersion doesn't work (assignee: @AndreyAkinshin ) #388 Precise Machine Counter Diagnoser (assignee: @adamsitnik ) #391 BenchmarkSwitcher should take an optinal IConfig #393 Troubles with ClrJob in .NET Core applications (assignee: @adamsitnik ) #395 Could not load file or assembly 'System.Reflection.Metadata' (assignee: @adamsitnik ) #401 Exceptions in Roslyn.Builder (assignee: @adamsitnik ) #406 BenchmarkDotNet with netcoreapp2.0 requires using RuntimeFrameworkVersion directly in the project file (assignee: @adamsitnik ) #410 Troubles with Classic applications on nightly BenchmarkDotNet (assignee: @adamsitnik ) #412 HardwareCounter.InstructionRetired failing with ArgumentNullException. Build 82 (assignee: @adamsitnik ) #415 Allocations for async methods measures BenchmarkDotNet (assignee: @adamsitnik ) #419 Suspicious warnings about MemoryMappedFiles (assignee: @adamsitnik ) #424 Make InliningDiagnoser filtering more flexible (assignee: @adamsitnik ) Merged pull requests (14) #356 Feature: host API interface (by @ig-sinicyn ) #379 Feature: in-process benchmarks (by @ig-sinicyn ) #392 Add an optional config to BenchmarkSwitcher. (by @ILMTitan ) #396 Allow users to pick, show and hide measurement units in the reports and exports. (by @AmadeusW ) #400 fix spelling error: misspredict => mispredict (by @stevedesmond-ca ) #405 Make RoslynToolchain types public (by @cdmihai ) #407 Propagate benchmark to hooks (by @cdmihai ) #408 Small fixes before approval tests (by @alinasmirnova ) #409 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova ) #416 Exports file to temporary location if target is locked (by @AmadeusW ) #421 MarkdownExporter right-justifies numeric columns (by @stevedesmond-ca ) #423 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova ) #430 Fix unix OS detection. (by @mfilippov ) #432 Fix macOS detection (by @mfilippov ) Commits (103) bd790c Simplify BenchmarkDotNet.IntegrationTests.Classic.ReferencesTests (by @AndreyAkinshin ) bf9f4e Feature: host API interface (by @ig-sinicyn ) f85ffe Merge pull request #356 from ig-sinicyn/feature-host-api (by @AndreyAkinshin ) 8ffff0 Feature: in-process benchmarks (by @ig-sinicyn ) 51fc0c Feature: in-process benchmarks, FixAffinity() helper (by @ig-sinicyn ) c5179f Feature: in-process benchmarks, review fixes (by @ig-sinicyn ) 6c5990 Feature: in-process benchmarks, review fixes, part 2 (by @ig-sinicyn ) c6b046 Feature: in-process benchmarks, STA & priority on full .Net FW (by @ig-sinicyn ) cc2c89 Feature: in-process benchmarks, env validation in toolchain, intro example ad... (by @ig-sinicyn ) 101a80 Improved versioning system (by @AndreyAkinshin ) 846532 Update links to appveyor (by @AndreyAkinshin ) 5464e4 Improved versioning system, part 2 (by @AndreyAkinshin ) e39a50 Merge pull request #379 from ig-sinicyn/feature-inprocess (by @adamsitnik ) ae4cc8 AssemblyInformationalVersion fix in common.props, resolves #382 (by @AndreyAkinshin ) d036f9 Precise Machine Counter Diagnoser #388 (by @adamsitnik ) 390442 Improved invocationCount behavior in SimpleJobAttribute (by @AndreyAkinshin ) 7b61ed add possibility to set Hardware Counters per class in runtime-independent way... (by @adamsitnik ) 6e208c Add an optional config to BenchmarkSwitcher. (by ILMTitan) 935d23 Merge pull request #392 from ILMTitan/master (by @adamsitnik ) 6b9a88 update to Roslyn 2.0, drop .NET 4.5 support, fixes #303 (by @adamsitnik ) ea4c55 BenchmarkDotNet.IntegrationTests.csproj: fix formatting (by @AndreyAkinshin ) 20a537 Update year in LICENSE.md (by @AndreyAkinshin ) 878796 Update logo (by @AndreyAkinshin ) faba77 Update README.md (by @AndreyAkinshin ) 6dce74 Update logo in README.md (by @AndreyAkinshin ) 7a750f Another fix in README.md (by @AndreyAkinshin ) 1caa0d fix spelling error: misspredict => mispredict (by @stevedesmond-ca ) 742912 use Array.Empty and Task.Completed (after upgrading to .NET 4.6) (by @adamsitnik ) 0dafac there is no need to set up with latest VS, fixes #393 (by @adamsitnik ) f5d88e Catch exceptions in BenchmarkDotNet.Running.BenchmarkRunnerCore.Run (by @AndreyAkinshin ) fa176f Merge pull request #400 from stevedesmond-ca/missspelling (by @AndreyAkinshin ) 90c3b1 Docs improvements (by @AndreyAkinshin ) 84c524 Mark SimpleJobAttribute with AllowMultiple (by @AndreyAkinshin ) 531804 Update README.md (by @AndreyAkinshin ) 7f2221 Make RoslynToolchain types public (#405) (by @cdmihai ) be8c33 Improved confidence intervals (by @AndreyAkinshin ) 767811 Propagate benchmark to hooks (#407) (by @cdmihai ) ec5e54 All exporters should not use static environment info (by @alinasmirnova ) 2b8a9e Culculate csv separator when it is needed, not in constructor (by @alinasmirnova ) 95aeb5 clean up (by @alinasmirnova ) 2e74c2 Name field for all exporters (by @alinasmirnova ) badb0b Merge pull request #408 from alinasmirnova/small-fixes (by @AndreyAkinshin ) 9da9ca search for .NET Core 2.0 settings in imported props files, fixes #406 (by @adamsitnik ) 2b08c5 filter sealed, generic and abstract classes from BenchmarkSwitcher, fixes #365 (by @adamsitnik ) 14ad55 print correct OS version in summary, fixes #351 (by @adamsitnik ) b86f48 BenchmarkDotNet does not support running .NET Core benchmarks when host proce... (by @adamsitnik ) 11b51b refactoring in TypeParser (by @adamsitnik ) 8047a7 use AND when filtering with args from command line, fixes #249 (by @adamsitnik ) 3cf8d8 handle cmd line arguments without '=', fixes #189 (by @adamsitnik ) cdc71f test fix after recent changes, #249 (by @adamsitnik ) 97c211 detect situation when users want to use Hardware Counters with InProcessToolc... (by @adamsitnik ) ba972b Warn user if no Columns were defined, fixes #159 (by @adamsitnik ) 2520f2 migrate old csprojs to the new format to get the tests running in common way,... (by @adamsitnik ) dd1b4d Improvements in StatisticsTests (by @AndreyAkinshin ) 07d149 emptyEnumerable.All(whatever) returns true (by @adamsitnik ) 0d61a7 improve dynamic diagnoser loading (case when diagnosers NuGet pacakge is inst... (by @adamsitnik ) 5a6937 Ignore BenchmarkProject.json in BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 5895c4 Improvements in TypeParserTests (by @AndreyAkinshin ) 1124ae BenchmarkDotNet.Tests: cleanup (by @AndreyAkinshin ) d37ef4 CSVHelper.Escape() method should check for actual separator value (by @alinasmirnova ) 43643c move hardwareCounters from Job to Config, fixes #412 (by @adamsitnik ) 303fff pass config from runner => executor => diagnoser #412 (by @adamsitnik ) 5b432e Addded approval tests for exporters (by @alinasmirnova ) ac6507 Added more info in mock summary (by @alinasmirnova ) a59b17 MockEnvironmentInfo for approval tests (by @alinasmirnova ) 610f3b Awaiting Tasks should not interfere allocation results, fixes #415 (by @adamsitnik ) cf16f6 I forgot about aligning, #415 (by @adamsitnik ) 2860d2 help the .NET framework to resolve assemblies when binding redirects are miss... (by @adamsitnik ) e7ad36 don't log false alarms, fixes #419 (by @adamsitnik ) 803081 Allow users to pick, show and hide measurement units in the reports and expor... (by @AmadeusW ) fa3128 Exports file to temporary location if target is locked (#416) (by @AmadeusW ) c923ba MarkdownExporter right-justifies numeric columns (#421) (by @stevedesmond-ca ) aa290d Add column legends (by @AndreyAkinshin ) 8d8db5 Handle case when there are no columns with legends (by @AndreyAkinshin ) dc201c Add empty line before legends (by @AndreyAkinshin ) ff7fc9 Approved files (by @alinasmirnova ) 3f6372 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova ) 7d23d1 Merge remote-tracking branch 'upstream/master' (by @alinasmirnova ) 57cbbb Merge branch 'new-test-sdk-version' (by @alinasmirnova ) c0c563 Updated Microsoft.Net.Test.Sdk (by @alinasmirnova ) 539834 Updated spproved files according last changes in md exporter (by @alinasmirnova ) f117f0 Added *.received and *.orig in .gitignore (by @alinasmirnova ) 0d7e72 Make InliningDiagnoser filtering more flexible, fixes #424 (by @adamsitnik ) d25eb0 allow to set InProcessToolchain via attribute /cc @ig-sinicyn (by @adamsitnik ) 8cf041 Mock strings in mock environment info (by @alinasmirnova ) 0db804 Changed file naming in approval files (by @alinasmirnova ) 29aeaf correct Idle implementation for Task-returning benchmarks, fixes #418 (by @adamsitnik ) c81aa5 the missing docs for Hardware Counters, fixes #388 (by @adamsitnik ) 6076e2 Improved precision (by @AndreyAkinshin ) 72b3a6 Show \"NA\" for statistic columns with double.NaN values (by @AndreyAkinshin ) ea2222 Processor brand string prettifying (by @AndreyAkinshin ) 678d43 Added approval files info links to docs (by @alinasmirnova ) 33911c Merge remote-tracking branch 'upstream/master' (by @alinasmirnova ) d4c928 Fixed approval tests according to recent changes in master (by @alinasmirnova ) eb9f4f Fix typos in docs (by @AndreyAkinshin ) 271b27 Merge pull request #348 from alinasmirnova/master (by @AndreyAkinshin ) 152f3e Parsing Gulftown processor brand strings (by @AndreyAkinshin ) 74d793 Minor improvements in docs (by @AndreyAkinshin ) 764bd3 Minor improvements in docs, part 2 (by @AndreyAkinshin ) 0a251b Fix unix OS detection. (by @mfilippov ) 5c3b39 Fix typo in PlatformID (by @mfilippov ) 7f3d06 Always use PlatformAbstractions in RuntimeInformation.GetOsVersion() (by @AndreyAkinshin ) 46d34f Set library version: 0.10.4 (by @AndreyAkinshin ) Contributors (8) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Amadeusz Wieczorek ( @AmadeusW ) Andrey Akinshin ( @AndreyAkinshin ) ig-sinicyn ( @ig-sinicyn ) Mihai Codoban ( @cdmihai ) Mikhail Filippov ( @mfilippov ) Steve Desmond ( @stevedesmond-ca ) Thank you very much! Additional details Date: April 21, 2017 Milestone: v0.10.4 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.4"
  },
  "changelog/v0.10.5.html": {
    "href": "changelog/v0.10.5.html",
    "title": "BenchmarkDotNet v0.10.5 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.5 Fixed SizeUnit presentation in the summary table ( #434 ) In MemoryDiagnoser, now 1kB = 1024B (instead of 1000 in v0.10.4) ( #434 ) Fix false allocations detection ( #436 9b44de70 ) Hide ScaledSD column for small values ( da857ad7 ) Autoselecting amount of digits after the decimal point ( #404 ) Milestone details In the v0.10.5 scope, 3 issues were resolved and 2 pull requests were merged. This release includes 16 commits by 4 contributors. Resolved issues (3) #404 Autoselecting amount of digits after the decimal point (assignee: @AndreyAkinshin ) #428 Cleanup NuGet.Config (assignee: @adamsitnik ) #434 Allocation output suddenly is 0 GB (assignee: @AndreyAkinshin ) Merged pull requests (2) #435 Joined approved files according to cultures (by @alinasmirnova ) #436 Fix false allocations detection (by @ig-sinicyn ) Commits (16) d9eefd NuGet feeds cleanup, fixes #428 (by @adamsitnik ) 2a95b0 Fix SizeUnit presentation, fixes #434 (by @AndreyAkinshin ) 8eca28 Add a note about kilobytes in docs (by @AndreyAkinshin ) ae483e Separate approved files only for cultures, not for exporters (by @alinasmirnova ) 78a6a0 Improved legend for MemoryDiagnoser (by @AndreyAkinshin ) 47ae20 SizeUnitTests (by @AndreyAkinshin ) 9b44de fix false allocations detection (by @ig-sinicyn ) ffd535 Merge pull request #436 from ig-sinicyn/fix_allocations_on_run (by @adamsitnik ) 87c2bd Inclusive ConfidenceInterval.Contains (by @AndreyAkinshin ) da857a Don't show the ScaledSD column if values are small (by @AndreyAkinshin ) e0cf24 Add DefaultColumnProvidersTests (by @AndreyAkinshin ) f2baa3 Fix typo in DefaultColumnProvidersTests (by @AndreyAkinshin ) 117560 Fix BaselineScaledColumnTest.ColumnsWithBaselineGetsScaled (by @AndreyAkinshin ) 3a1fb7 Implement BestAmountOfDecimalDigits for statistics columns in SummaryTable, f... (by @AndreyAkinshin ) 4201ee Fix ToolchainTest.CustomToolchainsAreSupported (by @AndreyAkinshin ) cba245 Set library version: 0.10.5 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) ig-sinicyn ( @ig-sinicyn ) Thank you very much! Additional details Date: April 26, 2017 Milestone: v0.10.5 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.5"
  },
  "changelog/v0.10.6.html": {
    "href": "changelog/v0.10.6.html",
    "title": "BenchmarkDotNet v0.10.6 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.6 Removed buggy allocation from Engine which was spoiling the results of MemoryDiagnoser for micro benchmarks. This part of the code is now guarded with very strict integration tests, it should never happen again. We now also exclude the side effects of the Allocation Quantum. This bug was serious, you must update to 0.10.6 ( #439 ) Support of the PackageTargetFallback setting which allows to reference components that target old framework monikers (like dotnet5.4 or portable-net45+win8 ) ( #438 ) Added InstructionRetiredPerCycleColumn which shows up automatically when HardwareCounter.InstructionRetired and HardwareCounter.TotalCycles are used. Support benchmark classes without namespace ( #446 ) Fix problem with RPlotExporter and quoted directories in %PATH% ( #446 ) Show Windows brand version in summary Milestone details In the v0.10.6 scope, 3 issues were resolved and 1 pull requests were merged. This release includes 11 commits by 3 contributors. Resolved issues (3) #438 Need to Update Autogenerated csproj file (assignee: @adamsitnik ) #439 Question - This benchmark apparently allocates, but why? (assignee: @adamsitnik ) #446 ArgumentNullException if RPlotExporter is used (assignee: @AndreyAkinshin ) Merged pull requests (1) #444 Added line separator at the end in JsonExporters (by @alinasmirnova ) Commits (11) 3c1f09 copy the PackageTargetFallback setting if present in csproj to support older ... (by @adamsitnik ) ffab7d remove allocation from Engine, make sure tests detect breaking change in the ... (by @adamsitnik ) 7c9a0f consider Allocation Quantum side effects to have correct results for micro be... (by @adamsitnik ) 4af5f3 Added line separator in JsonExporters (by @alinasmirnova ) 8ac913 added Instruction Retired per Cycle (IPC) to the predefined columns for Pmc D... (by @adamsitnik ) 0898c3 post code review changes (by @adamsitnik ) b4d68e 'kB' -> 'KB' (by @AndreyAkinshin ) 23bd4f Handle null values in CsvHelper.Escape (by @AndreyAkinshin ) 77ed63 RPlotExporter.FindInPath: handle exceptions, trim quotes #446 (by @AndreyAkinshin ) 626e3a Show Windows brand versions in summary (by @AndreyAkinshin ) 247634 Set library version: 0.10.6 (by @AndreyAkinshin ) Contributors (3) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Date: May 12, 2017 Milestone: v0.10.6 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.6 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.6"
  },
  "changelog/v0.10.7.html": {
    "href": "changelog/v0.10.7.html",
    "title": "BenchmarkDotNet v0.10.7 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.7 LINQPad support (5.22.05+) ( #66 , #445 ) Benchmark filters and categories ( #248 ) Updated setup/cleanup attributes: [GlobalSetup] , [GlobalCleanup] , [IterationSetup] , [IterationCleanup] ( #270 , #274 , #325 , #456 ) Better Value Types support ( afa803d0 ) Building Sources on Linux: it's possible to build the solution (with unloaded F#/VB projects), run samples (for both net46/netcoreapp1.1), run unit tests (for netcoreapp1.1 only) Fix minor bugs in JsonExporter ( #451 ) Milestone details In the v0.10.7 scope, 6 issues were resolved and 1 pull requests were merged. This release includes 24 commits by 4 contributors. Resolved issues (6) #66 Friendliness to LinqPad (assignee: @adamsitnik ) #248 Support a \"category\" attribute for selecting benchmarks (assignee: @AndreyAkinshin ) #270 Add support for Cleanup and Setup between benchmarks (assignee: @AndreyAkinshin ) #274 Support for run-once Setup and Clean-up with Parameters available (assignee: @AndreyAkinshin ) #325 Setup & Cleanup versions of attribute which would run before/after each benchmark iteration (assignee: @AndreyAkinshin ) #445 Missing reference to Microsoft.CodeAnalysis.CSharp when using BenchmarkDotNet in Linqpad (assignee: @adamsitnik ) Merged pull requests (1) #451 Fix minor bugs in JsonExporter (by @Teknikaali ) Commits (24) a54645 handle the LINQPad shadow copying, #445, #66 (by @adamsitnik ) fe3032 Add Filters (by @AndreyAkinshin ) 2e7427 Add categories (by @AndreyAkinshin ) f96346 Add categories filters (by @AndreyAkinshin ) 34f808 Support category filters in BenchmarkSwitcher (by @AndreyAkinshin ) 786afe Implement join mode in BenchmarkSwitcher (by @AndreyAkinshin ) a77a77 Post code review changes (by @AndreyAkinshin ) cc7006 Fix minor bugs in JsonExporter (#451) (by @Teknikaali ) 4dd789 Rename Setup/Cleanup to GlobalSetup/GlobalCleanup (by @AndreyAkinshin ) 21369c Introduce IterationSetup/IterationCleanup (by @AndreyAkinshin ) 0e9be7 Add IterationSetupCleanupAnalyser (by @AndreyAkinshin ) 4f3703 docs: update structure (by @AndreyAkinshin ) 5fe564 docs: add info about RunStrategy.Monitoring and new Setup/Cleanup attributes (by @AndreyAkinshin ) 87ce0f Mark ProcessPropertiesTests as WindowsOnly (by @AndreyAkinshin ) 7e479e Fix typo in File_StreamVsMemoryMapperVewStream.cs (by @AndreyAkinshin ) 975514 Wrong xml doc comment (by @ig-sinicyn ) 165b13 Merge pull request #455 from ig-sinicyn/patch-1 (by @adamsitnik ) afa803 better Value Types support (by @adamsitnik ) d16ddb workaround for weird AppVeyor behavior (by @adamsitnik ) 9f3d68 support recursive nesting for returned types (by @adamsitnik ) b7668e Add tests/runCoreTests.sh (by @AndreyAkinshin ) 3cceb6 runCoreTests.sh: fix output file for integration-tests (by @AndreyAkinshin ) a21421 Make some tests Windows-only (by @AndreyAkinshin ) 00a156 Set library version: 0.10.7 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Anssi Kettunen ( @Teknikaali ) ig-sinicyn ( @ig-sinicyn ) Thank you very much! Additional details Date: June 05, 2017 Milestone: v0.10.7 Overview post: http://aakinshin.net/blog/post/bdn-v0_10_7/ NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.7 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.7"
  },
  "changelog/v0.10.8.html": {
    "href": "changelog/v0.10.8.html",
    "title": "BenchmarkDotNet v0.10.8 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.8 Legend for time units ( #349 , #459 , f14e508e ) XML exporter ( #157 , #452 , a0148db8 ) .NET Framework 4.7 support ( #461 , 3f2b5c3c , 5513873a ) Public API for AllocationQuantum ( #450 , #462 , a0148db8 ) Milestone details In the v0.10.8 scope, 5 issues were resolved and 3 pull requests were merged. This release includes 8 commits by 4 contributors. Resolved issues (5) #157 Implement export to xml #349 What the report title and value means? (assignee: @AndreyAkinshin ) #450 [Minor feature request] Please make GcStats.AllocationQuantum public #459 [Question] What does the unit of measurement us stand for #461 .NET Framework 4.7 support (assignee: @adamsitnik ) Merged pull requests (3) #452 Feature: XML Exporter (by @Teknikaali ) #455 Wrong xml doc comment (by @ig-sinicyn ) #462 make allocation quantum public, deal with a spelling error and expose… (by @RichLinnell ) Commits (8) f14e50 Add legend for time units (by @AndreyAkinshin ) e59550 Add info about OrderProviders in docs (by @AndreyAkinshin ) 6fc245 Fix ConfigPassingTest (by @AndreyAkinshin ) ef0583 Feature: XML Exporter (#452) (by @Teknikaali ) 3f2b5c .NET 4.7 support from .NET Core host process on Windows, fixes #461 (by @adamsitnik ) a0148d make allocation quantum public, deal with a spelling error and expose allocat... (by @RichLinnell ) 551387 add Windows check to our CsProjClassicNetToolchain (by @adamsitnik ) 971565 Set library version: 0.10.8 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Anssi Kettunen ( @Teknikaali ) Rich Linnell ( @RichLinnell ) Thank you very much! Additional details Date: June 09, 2017 Milestone: v0.10.8 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.8"
  },
  "changelog/v0.10.9.html": {
    "href": "changelog/v0.10.9.html",
    "title": "BenchmarkDotNet v0.10.9 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.10.9 Migrate from custom build scripts to Cake (C# Make) ( #426 , #475 , thanks @Ky7m ) Target Setup methods for specific Benchmarks ( #469 , #501 , thanks @ipjohnson ) Many improvements in XmlExporter ( #476 , #488 , thanks @Teknikaali ) Add MemoryDiagnoser results to JsonExporter output ( #453 , #478 , thanks @Teknikaali ) Detect correct version of .NET Core (+ improved presentation for information about runtime) ( #448 , ed586585...ed586585 ) Fix UnauthorizedAccessException ( #380 , #390 , #490 , #491 , 8505abb5 ) Fix app.config generation ( #499 , dc6dc411 ) Fix incorrect order of IterationCleanup and Benchmark jitting ( #481 , #503 ) Fix test scripts for MacOS+zsh ( 1177c8 ) Unix-related ProcessorAffinity fixes ( #474 , 26d44411 ) Minor fixes in docs ( #465 , #467 , #473 , #480 , #483 , thanks @mtschneiders , @davkean , @aarondandy , @AmadeusW ) Temporary hacks for appveyor connectivity incident ( #497 , #506 ) Additional warnings for incorrect Configs ( #482 , eb84825f ) Additional warnings for F# methods with spaces ( #479 , 3c2c8dec , 7ba1c809 , 3ca39afe ) Milestone details In the v0.10.9 scope, 13 issues were resolved and 14 pull requests were merged. This release includes 37 commits by 10 contributors. Resolved issues (13) #380 Problem running benchmark due to \"could not copy\" during build (assignee: @adamsitnik ) #390 Crashing benchmark (assignee: @adamsitnik ) #426 Migrate from custom build scripts to Cake (C# Make) #448 Detect correct version of .NET Core (assignee: @AndreyAkinshin ) #453 MemoryDiagnoser and JsonExporter #469 [Suggestion] Specify Setup per benchmark (assignee: @AndreyAkinshin ) #474 PlatformNotSupportedException when reading ProcessorAffinity on non-Windows platforms (assignee: @AndreyAkinshin ) #479 Invalid C# code generated for valid F# identifiers (assignee: @adamsitnik ) #481 Iteration cleanup runs before the benchmark (assignee: @AndreyAkinshin ) #482 Benchmark seems to hang when no logger is defined (assignee: @adamsitnik ) #490 BDN.Generated.exe is locking files when killed with ctrl+c (assignee: @adamsitnik ) #491 UnauthorizedAccessException preventing report to be written (assignee: @adamsitnik ) #499 Opting into app-compat switches in a benchmark doesn't work (assignee: @adamsitnik ) Merged pull requests (14) #465 Small correction in Filters.md (by @mtschneiders ) #467 Small improvements to FAQ.md (by @mtschneiders ) #471 Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders ) #473 Adds ISummaryStyle information to the Exporters guide (by @AmadeusW ) #475 Cake (C# Make) integration. Migration from custom build scripts. (by @Ky7m ) #476 Improve Xml exporter's discoverability (by @Teknikaali ) #478 Add MemoryDiagnoser results to JsonExporter output (by @Teknikaali ) #480 Fix links to Overview/FAQ (by @davkean ) #483 Update jobs docs (by @aarondandy ) #488 Improve XmlExporter (by @Teknikaali ) #497 Add temporary solution to address connectivity issues to nuget.org (by @Ky7m ) #501 Target Setup methods for specific Benchmarks (by @ipjohnson ) #503 Make sure IterationCleanup is run after Jitting (by @smitpatel ) #506 Removes a temporary solution related to connectivity issues to nuget (by @Ky7m ) Commits (37) 0b5657 Small correction in comments (by @mtschneiders ) b1ad2c Merge pull request #465 from mtschneiders/patch-1 (by @adamsitnik ) 3bb154 Small corrections to FAQ.md (by @mtschneiders ) 1a8559 Merge pull request #467 from mtschneiders/patch-2 (by @adamsitnik ) fc4dfe Corrected typos in Filters.md and IntroFilters.cs (by @mtschneiders ) cb5072 Remove UpgradeLog.htm (by @AndreyAkinshin ) 7013bd Adds ISummaryStyle information to the Exporters guide (by @AmadeusW ) 345af7 wording (by @AmadeusW ) a114ea Merge pull request #473 from AmadeusW/docs/exporters (by @adamsitnik ) 26d444 Unix-related ProcessorAffinity fixes (fix #474) (by @AndreyAkinshin ) 2d8a53 Improve Xml exporter's discoverability (#476) (by @Teknikaali ) baebf9 Add MemoryDiagnoser results to JsonExporter output (#478) (by @Teknikaali ) 32993c Fix links to Overview/FAQ (by @davkean ) 8e712c Merge pull request #480 from davkean/FixLinks (by @adamsitnik ) 43405d Update jobs docs (by @aarondandy ) 1bacac Merge pull request #483 from aarondandy/docs-changes (by @adamsitnik ) 3c2c8d print nice error for F# methods that contain whitespaces, fixes #479 (by @adamsitnik ) 7ba1c8 post code review #479 (by @adamsitnik ) 3ca39a even more post code review #479 (by @adamsitnik ) eb8482 warn the users if no logger, columns or exporters were defined, fixes #482 (by @adamsitnik ) 8505ab unique file names by default, are removed after printing the results, fix #49... (by @adamsitnik ) 3e74aa Improve XmlExporter (#488) (by @Teknikaali ) 6e2577 Cake (C# Make) integration. Migration from custom build scripts. (#475) (by @Ky7m ) 6e6fcc Add temporary solution to address connectivity issues to nuget.org https://ap... (by @Ky7m ) dc6dc4 all runtime settings, that do not belong to Job must be rewritten by default ... (by @adamsitnik ) ed5865 Rename \"dotnet cli version\" to \".NET Core SDK\", see #448 (by @AndreyAkinshin ) 857f2b Detecting the correct version of .NET Core, fixing #448 (by @AndreyAkinshin ) 7ec001 Don't print information about unknown timers in HostEnvironmentInfo (by @AndreyAkinshin ) 4c3c82 Add missing space in HostRuntimeInfo (by @AndreyAkinshin ) da8226 Print actual information about .NET Framework version in summary, see #448 (by @AndreyAkinshin ) cea199 Fix MultipleRuntimesTest.SingleBenchmarkCanBeExecutedForMultpleRuntimes (by @AndreyAkinshin ) db56bc Make sure IterationCleanup is run after Jitting (by @smitpatel ) 3df90f Merge pull request #503 from smitpatel/orderingissue (by @adamsitnik ) 1177c8 Improve tests/runCoreTests.sh (by @AndreyAkinshin ) 976900 Removes a temporary solution related to connectivity issues to nuget.org http... (by @Ky7m ) 557246 Target Setup methods for specific Benchmarks (#501) (by @ipjohnson ) 80d70a Set library version: 0.10.9 (by @AndreyAkinshin ) Contributors (10) Aaron Dandy ( @aarondandy ) Adam Sitnik ( @adamsitnik ) Amadeusz Wieczorek ( @AmadeusW ) Andrey Akinshin ( @AndreyAkinshin ) Anssi Kettunen ( @Teknikaali ) David Kean ( @davkean ) Ian Johnson ( @ipjohnson ) Igor Fesenko ( @Ky7m ) Mateus Artur Schneiders ( @mtschneiders ) Smit Patel ( @smitpatel ) Thank you very much! Additional details Date: July 28, 2017 Milestone: v0.10.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.10.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.10.9"
  },
  "changelog/v0.11.0.html": {
    "href": "changelog/v0.11.0.html",
    "title": "BenchmarkDotNet v0.11.0 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.11.0 This is one of the biggest releases of BenchmarkDotNet ever. There are so many improvements. We have new documentation, many performance improvements, Job Mutators, better user experience, correct Ctrl+C handling, better generic benchmarks support, more scenarios for passing arguments to benchmarks, awesome support of console arguments, unicode support, LLVM support in MonoDisassembler, and many-many other improvements and bug fixes! A big part of the features and bug fixes were implemented to meet the enterprise requirements of Microsoft to make it possible to port CoreCLR, CoreFX, and CoreFXLab to BenchmarkDotNet. The release would not be possible without many contributions from amazing community members. This release is a combined effort. We build BenchmarkDotNet together to make benchmarking .NET code easy and available to everyone for free! New documentation We have many improvements in our documentation! The new docs include: DocFX under the hood Detailed changelogs which includes all commits, merged pull requests and resolved issues API references Code samples for main features: we generate it automatically based on the BenchmarkDotNet.Samples project; it means that all samples can always be compiled (no more samples with outdated API) Better UI Documentation versioning: now it's possible to look at the documentation for recent BenchmarkDotNet versions Performance improvements BenchmarkDotNet needs to be capable of running few thousands of CoreFX and CoreCLR benchmarks in an acceptable amount of time. The code itself was already optimized so we needed architectural and design changes to meet this requirement. Generate one executable per runtime settings To ensure that the side effects of one benchmark run does not affect another benchmark run BenchmarkDotNet generates, builds and runs every benchmark in a dedicated process. So far we were generating and building one executable per benchmark, now we generate and build one executable per runtime settings. So if you want to run ten thousands of benchmarks for .NET Core 2.1 we are going to generate and build single executable, not ten thousand. If you target multiple runtimes the build is going to be executed in parallel. Moreover, if one of the parallel builds fail it's going to be repeated in a sequential way. Previously the time to generate and build 650 benchmarks from our Samples project was one hour . Now it's something around 13 seconds which means 276 X improvement for this particular scenario. You can see the changes here . Don't execute long operations more than once per iteration BenchmarkDotNet was designed to allow for very accurate and stable micro-benchmarking. One of the techniques that we use is manual loop unrolling. In practice, it meant that for every iteration we were executing the benchmark at least 16 times (the default UnrollFactor value). It was of course not desired for the very time-consuming benchmarks. So far this feature was always enabled by default and users would need to configure UnrollFactor=1 to disable it. Now BenchmarkDotNet is going to discover such scenario and don't perform manual loop unrolling for the very time-consuming benchmarks. BenchmarkDotNet uses Job.IterationTime setting (the default is 0.5s) in the Pilot Experiment stage to determine how many times given benchmark should be executed per iteration. Example: public class Program { static void Main() => BenchmarkRunner.Run<Program>(); [Benchmark] public void Sleep1s() => Thread.Sleep(TimeSpan.FromSeconds(1)); } Time to run with the previous version: 374 seconds . With 0.11.0 it's 27 seconds which gives us almost 14 X improvement. A good example of benchmarks that are going to benefit from this change are computer game benchmarks and ML.NET benchmarks. You can see the changes here and here . Exposing more configuration settings The default settings were configured to work well with every scenario. Before running the benchmark, BenchmarkDotNet does not know anything about it. This is why it performs many warmup iterations before running the benchmarks. When you author benchmarks and run them many times you can come up with custom settings that produce similar results but in a shorter manner of time. To allow you to do that we have exposed: Job.MinIterationCount (default value is 15) Job.MaxIterationCount (default value is 100) Job.MinWarmupIterationCount (default value is 6) Job.MaxWarmupIterationCount (default value is 50) User Experience One of the biggest success factors of BenchmarkDotNet is a great user experience. The tool just works as expected and makes your life easy. We want to make it even better! .NET Standard 2.0 We have ported BenchmarkDotNet to .NET Standard 2.0 and thanks to that we were able to not only simplify our code and build process but also merge BenchmarkDotNet.Core.dll and BenchmarkDotNet.Toolchains.Roslyn.dll into BenchmarkDotNet.dll . We still support .NET 4.6 but we have dropped .NET Core 1.1 support. More information and full discussion can be found here . Note: Our BenchmarkDotNet.Diagnostics.Windows package which uses EventTrace to implement ETW-based diagnosers was also ported to .NET Standard 2.0 and you can now use all the ETW diagnosers with .NET Core on Windows. We plan to add EventPipe support and make this page fully cross-platform and Unix compatible soon. Using complex types as benchmark arguments So far we have required the users to implement IParam interface to make the custom complex types work as benchmark arguments/parameters. This has changed, now the users can use any complex types as arguments and it will just work ( more ). public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); public IEnumerable<object> Arguments() { yield return new Point2D(10, 200); } [Benchmark] [ArgumentsSource(nameof(Arguments))] public int WithArgument(Point2D point) => point.X + point.Y; } public class Point2D { public int X, Y; public Point2D(int x, int y) { X = x; Y = y; } public override string ToString() => $\"[{X},{Y}]\"; } Note : If you want to control what will be displayed in the summary you should override ToString . If IterationSetup is provided run benchmark once per iteration When Stephen Toub says that something is buggy , it most probably is. BenchmarkDotNet performs multiple invocations of benchmark per every iteration. When we have exposed the [IterationSetup] attribute many users were expecting that the IterationSetup is going to be invoked before every benchmark execution. It was invoked before every iteration, and iteration was more than one benchmark call if the user did not configure that explicitly. We have changed that and now if you provide an [IterationSetup] method it is going to be executed before every iteration and iteration will invoke the benchmark just once. public class Test { public static void Main() => BenchmarkRunner.Run<Test>(); [IterationSetup] public void MySetup() => Console.WriteLine(\"MySetup\"); [Benchmark] public void MyBenchmark() => Console.WriteLine(\"MyBenchmark\"); } Before: MySetup MyBenchmark MyBenchmark MyBenchmark MyBenchmark (...) After: MySetup MyBenchmark MySetup MyBenchmark MySetup MyBenchmark (...) Note: If you want to configure how many times benchmark should be invoked per iteration you can use the new [InvocationCountAttribute] . Job Mutators Job represents a set of settings to run the benchmarks. We run every benchmark for every job defined by the user. The problem was that so far many jobs were just added to the config instead of being merged with other jobs. An example: [ClrJob, CoreJob] [GcServer(true)] public class MyBenchmarkClass Resulted in 3 jobs and 3 benchmark executions: ClrJob , CoreJob and GcServer(true) for current runtime. Now all Jobs and their corresponding attributes marked as mutators are going to be applied to other jobs, not just added to the config. So in this particular scenario, the benchmarks from MyBenchmarkClass are going to be executed for .NET with Server GC enabled and .NET Core with Server GC enabled. Mutators are great when you want to have a single, global config for all benchmarks and apply given settings only to selected types. You can find out more about mutators here . Ctrl+C When the user: presses Ctrl+C presses Ctrl+Break logs off closes console window We are now going to close any existing ETW session created by BenchmarkDotNet and restore console colors ( read more ). Handle OutOfMemoryException more gracefully When our benchmark hits OutOfMemoryException we print some nice explanation: public class Program { static void Main(string[] args) => BenchmarkRunner.Run<Program>(); private List<object> list = new List<object>(); [Benchmark] public void AntiPattern() => list.Add(new int[int.MaxValue / 2]); } OutOfMemoryException! BenchmarkDotNet continues to run additional iterations until desired accuracy level is achieved. It's possible only if the benchmark method doesn't have any side-effects. If your benchmark allocates memory and keeps it alive, you are creating a memory leak. You should redesign your benchmark and remove the side-effects. You can use `OperationsPerInvoke`, `IterationSetup` and `IterationCleanup` to do that. Trimming long strings We used to display the values \"as is\" which was bad for long strings. Now the values are trimmed ( more ). public class Long { [Params(\"text/plain,text/html;q=0.9,application/xhtml+xml;q=0.9,application/xml;q=0.8,*/*;q=0.7\")] public string Text; [Benchmark] public int HashCode() => Text.GetHashCode(); } Method Text HashCode text/(...)q=0.7 [86] More features Generic benchmarks BenchmarkDotNet supports generic benchmarks, all you need to do is to tell it which types should be used as generic arguments ( read more ). [GenericTypeArguments(typeof(int))] [GenericTypeArguments(typeof(char))] public class IntroGenericTypeArguments<T> { [Benchmark] public T Create() => Activator.CreateInstance<T>(); } Arguments We now support more scenarios for passing arguments to benchmarks: passing arguments to asynchronous benchmarks ( more ) passing generic types passing arguments by reference passing jagged arrays ( more ) types with implicit cast operator to stack only types can be passed as given stack-only types to Benchmarks ( more ) Example: public class WithStringToReadOnlySpan { [Benchmark] [Arguments(\"some string\")] public void AcceptsReadOnlySpan(ReadOnlySpan<char> notString) } Console Arguments BenchmarkSwitcher supports various console arguments ( PR ), to make it work you need to pass the args to switcher: class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } Note: to get the most up-to-date info about supported console arguments run the benchmarks with --help . Filter The --filter or just -f allows you to filter the benchmarks by their full name ( namespace.typeName.methodName ) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Note : If you would like to join all the results into a single summary , you need to use --join . Categories You can also filter the benchmarks by categories: --anyCategories - runs all benchmarks that belong to any of the provided categories --allCategories - runs all benchmarks that belong to all provided categories Diagnosers -m , --memory - enables MemoryDiagnoser and prints memory statistics -d , --disassm - enables DisassemblyDiagnoser and exports diassembly of benchmarked code Runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Clr, Mono, Core and CoreRT. Example: run the benchmarks for .NET and .NET Core: dotnet run -c Release -- --runtimes clr core More arguments -j , --job (Default: Default) Dry/Short/Medium/Long or Default -e , --exporters GitHub/StackOverflow/RPlot/CSV/JSON/HTML/XML -i , --inProcess (Default: false) Run benchmarks in Process -a , --artifacts Valid path to accessible directory --outliers (Default: OnlyUpper) None/OnlyUpper/OnlyLower/All --affinity Affinity mask to set for the benchmark process --allStats (Default: false) Displays all statistics (min, max & more) --attribute Run all methods with given attribute (applied to class or method) Other small improvements Unicode support: now you can enable support of Unicode symbols like μ or ± with [EncodingAttribute.Unicode] , an example: BenchmarkDotNet.Samples.IntroEncoding (see #735 ) Better benchmark validation (see #693 , #737 ) Improve .NET Framework version detection : now we support .NET Framework 4.7.2 (see #743 ) OutlierModes: now it's possible to control how to process outliers, an example Sample: IntroOutliers (see #766 ) LLVM support in MonoDisassembler (see a7426e ) Grand API renaming we try not to change public API, but sometimes it's necessary because we want to get a consistent and understandable API in v1.0.0. (see #787 ) Many-many small improvements and bug fixes Milestone details In the v0.11.0 scope, 65 issues were resolved and 34 pull requests were merged. This release includes 214 commits by 11 contributors. Resolved issues (65) #136 Fastcheck for correctness of benchmark implementations #175 Add .NET Core support for Diagnostics package (assignee: @adamsitnik ) #368 Memory leak and crash with [Setup] (assignee: @adamsitnik ) #420 Make BenchmarkDotNet.Core runtime independent (assignee: @adamsitnik ) #464 Iteration setup / cleanup should not be called for Idle() (assignee: @adamsitnik ) #484 Broken HTTPS on site (assignee: @jongalloway ) #487 Please consider using 'µs' instead of 'us' #551 List of structs and OutOfMemoryException #583 BenchmarkDotNet.Samples refactoring (assignee: @AndreyAkinshin ) #586 IParam interface improvement (assignee: @adamsitnik ) #638 Config with ryujit but it doesnt actually use ryujit? (assignee: @morgan-kn ) #649 Searching docs leads to 404 page (assignee: @AndreyAkinshin ) #665 Handle OutOfMemoryException more gracefully (assignee: @adamsitnik ) #671 Why does BenchmarkRunner generate an isolated project per each benchmark method/job/params? (assignee: @adamsitnik ) #698 Port to .NET Standard 2.0, drop .NET Core 1.1 support (assignee: @adamsitnik ) #699 Generate one executable per runtime settings (assignee: @adamsitnik ) #700 Improve local CoreCLR support (assignee: @adamsitnik ) #701 Extend exported json file with FullName using xunit naming convention for integration purpose (assignee: @adamsitnik ) #710 Use DocFX as a documentation generator (assignee: @AndreyAkinshin ) #712 [Params] with arrays as params throws System.Reflection.TargetInvocationException (assignee: @adamsitnik ) #713 How to specify the invocation/launch count per type when using Config for multiple runtimes? (assignee: @adamsitnik ) #718 CoreRT support (assignee: @adamsitnik ) #719 If fail to build in Parallel due to file access issues, try to build sequentially (assignee: @adamsitnik ) #720 Add SummaryOrderPolicy.Declared #724 Allocated Memory results are not scaled with OperationPerInvoke (assignee: @adamsitnik ) #726 Improve building guideline #729 Handle Ctrl+C/Break (assignee: @adamsitnik ) #730 IterationSetup is not running before each benchmark invocation (assignee: @adamsitnik ) #733 IOException when running in OneDrive Folder (assignee: @adamsitnik ) #734 Handle missing Mono runtime more gracefully (assignee: @adamsitnik ) #736 Reduce number of initial pilot ops to 1 or make it configurable (assignee: @adamsitnik ) #738 Params string containing characters like quotes is not being escaped properly (assignee: @adamsitnik ) #741 Give users nice warning when T in generic benchmark is not public #745 It should be possible to specify the generic arguments by using attributes #747 Better docs that explain what is target/launch/iteration/invocation count (assignee: @adamsitnik ) #748 Very long string params/arguments should be trimmed (assignee: @adamsitnik ) #749 WithId(…) is ignored unless it’s at the end of the fluent calls chain. (assignee: @adamsitnik ) #763 Make MaxIterationCount configurable, keep current value as default (assignee: @adamsitnik ) #765 Add .NET Core 2.2 support (assignee: @adamsitnik ) #769 ArgumentsSource does not support Jagged Arrays (assignee: @adamsitnik ) #774 Make it possible to use Span and other ByRefLike types with implicit cast operators as benchmark argument (assignee: @adamsitnik ) #778 CS0104: 'Job' is an ambiguous reference between 'BenchmarkDotNet.Jobs.Job' and 'Nest.Job' (assignee: @adamsitnik ) #779 StackOnlyTypesWithImplicitCastOperatorAreSupportedAsArguments doesn't work on .NET Core 2.0 (assignee: @adamsitnik ) #787 Grand renaming #793 job=core for BenchmarkSwitcher (assignee: @adamsitnik ) #794 Don't exclude allocation quantum side effects for .NET Core 2.0+ (assignee: @adamsitnik ) #795 Broken BenchmarkSwitcher (assignee: @adamsitnik ) #797 Allocated is not divided by OperationsPerInvoke (assignee: @adamsitnik ) #802 AdaptiveHistogramBuilder.BuildWithFixedBinSize error when running benchmarks (assignee: @AndreyAkinshin ) #804 What is the point of BuildScriptFilePath ? (assignee: @adamsitnik ) #809 Make it possible to configure Min and Max Warmup Iteration Count (assignee: @adamsitnik ) #810 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .NET Core 2.2 (assignee: @adamsitnik ) #811 Question/Suggestion is GcStats forcing a GC.Collect when it doesn't need to (assignee: @adamsitnik ) #812 When will the next release be available on NuGet? (assignee: @adamsitnik ) #813 Problems with MemoryDiagnoserTests on Mono and .NET Core 2.0 (assignee: @adamsitnik ) #814 For type arguments we should display simple, not-trimmed name (assignee: @adamsitnik ) #816 BenchmarkDotNet.Autogenerated.csproj is not working on .NET Core 2.1 (assignee: @adamsitnik ) #817 Autogenerated project is missing dependencies (assignee: @adamsitnik ) #818 Arguments should be passed to asynchronous benchmarks (assignee: @adamsitnik ) #820 set DOTNET_MULTILEVEL_LOOKUP=0 when custom dotnet cli path is provided (assignee: @adamsitnik ) #821 ArgumentsAttribute causes an error when used with a string containing quotes (assignee: @adamsitnik ) #823 Allow to set multiple Setup/Cleanup targets without string concatenation (assignee: @adamsitnik ) #827 An easy way to run a specific benchmark class via command line (assignee: @adamsitnik ) #829 Error message for wrong command line filter (assignee: @adamsitnik ) #832 Compilation Error CS0119 with ParamsSource (assignee: @adamsitnik ) Merged pull requests (34) #693 Jit runtime validation (by @morgan-kn ) #717 V11 (by @adamsitnik ) #725 Extend exported json file with FullName using xunit naming convention for integration purpose (by @adamsitnik ) #727 Building guideline improvement (by @Rizzen ) #728 BenchmarkReport Exporter (by @Rizzen ) #735 Unicode support (by @Rizzen ) #737 Return value validator (by @ltrzesniewski ) #740 Follow up to #737 (by @ltrzesniewski ) #742 Add .NET Framework 4.7.2 version constant (by @epeshk ) #743 Improve .NET Framework version detection (by @epeshk ) #744 BenchmarkClass Validator (by @Rizzen ) #746 Addition to #743: use HasValue instead of casting (by @epeshk ) #750 Addition to #744: Using single variable in test instead of two (by @Rizzen ) #752 Update HowItWorks.md (by @Tornhoof ) #753 Ability to pass multiple assemblies. (by @paulness ) #754 generate IParams for users in smart way (by @adamsitnik ) #757 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (by @afmorris ) #758 Generic Benchmark Attribute (by @Rizzen ) #760 don't execute long operations more than once per iteration (by @adamsitnik ) #761 stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (by @adamsitnik ) #764 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, run benchmark once per iteration to avoid user confusion (by @adamsitnik ) #766 Introduce OutlierMode (by @AndreyAkinshin ) #771 have two main actions: with unroll and without, for no unroll icrease the step by 1 in pilot (not *2) (by @adamsitnik ) #781 Initial DocFX support, fixes #710 (by @AndreyAkinshin ) #783 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin ) #785 Improve filtering from console args (by @adamsitnik ) #789 docs: add changelog (by @AndreyAkinshin ) #790 add link to inprocesstoolchain (by @IanKemp ) #796 docs: multiversion combobox (by @AndreyAkinshin ) #799 Cpu info improvement (by @Rizzen ) #800 job Mutators (by @adamsitnik ) #824 Use 3rd party lib for console args parsing + support globs for filtering (by @adamsitnik ) #830 Read StandardOutput in a smart way to avoid infinite loops (by @houseofcat ) #833 initial release notes (by @adamsitnik ) Commits (214) defa7e port to .NET Standard 2.0 (by @adamsitnik ) 626b03 keep .NET 4.6 in case somebody is on full framework, but not using .NET Standard (by @adamsitnik ) ae4e22 merge BenchmarkDotNet.Toolchains.Roslyn into BenchmarkDotNet.Core (by @adamsitnik ) 260704 update TraceEvent, port BenchmarkDotNet.Diagnostics.Windows to .NET Standard,... (by @adamsitnik ) 324973 remove .NET Core 1.1 support, update tests (by @adamsitnik ) 64d732 get it working (by @adamsitnik ) 54b829 remove .NET Core 1.1 from the CI jobs (by @adamsitnik ) ebf3d9 ups ;) (by @adamsitnik ) 42d9ae Merge branch 'master' into annotations (by @adamsitnik ) bc9975 cleanup (by @adamsitnik ) 96dd4f merge BenchmarkDotNet and BenchmarkDotNet.Core (by @adamsitnik ) 2dc21b group the benchmarks by runtime settings into partitions, #699 (by @adamsitnik ) fbb283 generate one .cs with all types inside, #699 (by @adamsitnik ) 334af2 build single exe, #699 (by @adamsitnik ) b958a1 run selected type from all types in exe #699 (by @adamsitnik ) 4f5714 polishing the code, #699 (by @adamsitnik ) 0c26a4 reverting some magic .sln change which has most probably broken the Travis bu... (by @adamsitnik ) c8a368 restore to a dedicated temp folder, rebuild only bare minumum, store everythi... (by @adamsitnik ) bd04bd better debugging experience (#699): when building only 1 thing at a time, pri... (by @adamsitnik ) fcf691 Improved local CoreCLR/CoreFX support, tested on all OSes #700, #702 (by @adamsitnik ) 7fbd6c allow the users to define an extra nuget feed, don't force clear tag for loca... (by @adamsitnik ) ad0fc8 Merge branch 'master' into v11 (by @adamsitnik ) 8070e4 Merge remote-tracking branch 'origin/master' into v11 (by @adamsitnik ) 0cccba post code review fixes, part of #175 (by @adamsitnik ) 4acc15 new Runtime and Toolchain for CoreRT, #718 (by @adamsitnik ) 657f05 don't use Expressions in Engine to avoid .NET Native compiler errors, #718 (by @adamsitnik ) 8c93cf the .NET Native compiler complained about some dependencies from referenced p... (by @adamsitnik ) c8ba5c If fail to build in Parallel due to file access issues, try to build sequenti... (by @adamsitnik ) 7173f7 CoreRT does not support reflection yet, so we need to target .NET Core 2.1 to... (by @adamsitnik ) 889270 trying to install Clang 3.9 for CoreRT tests purpose, #718 (by @adamsitnik ) 967167 code review fixes, #718 (by @adamsitnik ) 94863a Merge pull request #717 from dotnet/v11 (by @adamsitnik ) 448752 Improved docs for Disassembly Diagnoser (by @adamsitnik ) 600e5f add FromAssemblyAndTypes method to make it possible to auto-detect all benchm... (by @adamsitnik ) 289292 Allocated Memory must be scaled with OperationPerInvoke, fixes #724 (by @adamsitnik ) 1aa414 Actual Building Guide (by @Rizzen ) cfd9fa Merge pull request #727 from Rizzen/master (by @adamsitnik ) 7cfe09 Created Exporter and moved logic into (by @Rizzen ) b9ff75 Merge pull request #728 from Rizzen/BenchmarkReportExporter (by @adamsitnik ) adea8f support by ref Arguments (by @adamsitnik ) 0ecd7e ignore auto-generated files cleanup errors, #733 (by @adamsitnik ) cf5cd6 Handle missing Mono runtime more gracefully, fixes #734 (by @adamsitnik ) 49495f Remove unused usings (by @AndreyAkinshin ) 160516 Return value validator (#737), fixes #136 (by @ltrzesniewski ) 396f0a Follow up to #737 (#740) (by @ltrzesniewski ) 9dc4e8 Add .NET Framework 4.7.2 release number constant to GetCurrentVersionBasedOnW... (by @epeshk ) 06ff2d Update link to manual with .NET Framework version constants (by @epeshk ) f7d9ac Don't check Reference Assemblies folder existence for .NET Framework version ... (by @epeshk ) ebc1f6 Remove hardcoded Program Files directory location (by @epeshk ) 490304 Refactor framework version determining, extract logic from CsProjClassicNetTo... (by @epeshk ) cbea7e Fix Program Files path on x86 systems (by @epeshk ) 8071c8 ProgramFilesX86DirectoryPath field (by @epeshk ) f1d726 Merge pull request #743 from epeshk/frameworkVersion (by @AndreyAkinshin ) a36442 use HasValue instead of casting (by @epeshk ) c7efcc Merge pull request #746 from epeshk/frameworkVersion (by @adamsitnik ) 58f704 Give users nice warning when T in generic benchmark is not public, fixes #741 (by @Rizzen ) 66f958 when dotnet build --no-restore fails, try to run with restore (by @adamsitnik ) 52067c custom job Id should be preserved, fixes #749 (by @adamsitnik ) 24ec6e Very long string params/arguments should be trimmed, fixes #748 (by @adamsitnik ) b2e5b6 Params string containing characters like quotes is must be escaped properly, ... (by @adamsitnik ) 10865c Better docs that explain what is target/launch/iteration/invocation count by ... (by @adamsitnik ) 32ed86 Addition to #744: Using single variable instead of two (by @Rizzen ) f2a71f Merge pull request #750 from Rizzen/744_addition (by @adamsitnik ) eabfdd Update HowItWorks.md (by @Tornhoof ) 8fc754 Merge pull request #752 from Tornhoof/patch-1 (by @adamsitnik ) 2d79b6 Ability to pass multiple assemblies. (by @paulness ) ba07b0 Merge pull request #753 from paulness/feature-allow-multiple-assemblies-to-be... (by @adamsitnik ) d1b037 generate IParams for users in smart way (by @adamsitnik ) 4665ec Merge pull request #754 from dotnet/noIParam (by @adamsitnik ) 02c7c0 Generic Benchmark Attribute (#758), fixes #745 (by @Rizzen ) 7caf28 Add SummaryOrderPolicy.Defined to return benchmarks as instantiated (#757), f... (by @afmorris ) 449002 renamed Defined to Declared to keep consistency, renamed GenericBenchmark to ... (by @adamsitnik ) 8855a2 Jit runtime validation (#693) (by @morgan-kn ) 41614b stop the ETW session on Ctrl+C + restore console colors ;), fixes #729 (#761) (by @adamsitnik ) b0c251 Make MaxIterationCount configurable, keep current value as default, fixes #763 (by @adamsitnik ) 6f693e warn the users (once!) that if they run less than 15 iterations, the Multimod... (by @adamsitnik ) a9664f don't execute long operations more than once per iteration (#760), fixes #736 (by @adamsitnik ) 7e8448 if IterationSetup is provided, and InvocationCount and UnrollFactor are not, ... (by @adamsitnik ) a40c75 explain the users why they did hit OOM, fixes #665, #368, #551 (by @adamsitnik ) e66bb0 arrays can be arguments and params, fixes #712 (by @adamsitnik ) 94b83e don't call IterationSetup and Cleanup for Idle, fixes #464 (by @adamsitnik ) 90f9ca Add .NET Core 2.2 support, fixes #765 (by @adamsitnik ) 132048 Better mValue formatting in MultimodalDistributionAnalyzer (by @AndreyAkinshin ) 5f08c2 Merge pull request #764 from dotnet/iterationSetupRunOnce (by @AndreyAkinshin ) 2b5dde Introduce OutlierMode (by @AndreyAkinshin ) 226716 OutliersAnalyserTests (by @AndreyAkinshin ) cabef0 support Jagged Arrays for ArgumentsSource, fixes #769 (by @adamsitnik ) 808a9d support generic by ref arguments with an ugly hack due to reflection limitati... (by @adamsitnik ) ea9f70 remove the ugly hack (by @adamsitnik ) cb4291 make it possible to use arrays of types with no public parameterless ctor (li... (by @adamsitnik ) 272e42 diassembly diagnoser: handle case where two different methods have same meta... (by @adamsitnik ) ea16d1 update preview dependencies to 4.5.0 (by @adamsitnik ) 97ddd6 Make it possible to use Span as benchmark argumen, fixes #774 (by @adamsitnik ) 4863be more generic solution for #774 (by @adamsitnik ) f63726 update build to use rc1 (to fix the build) (by @adamsitnik ) a38c70 make it possible to pass array(s) of reference types as arguments (by @adamsitnik ) 306adc use full Job type name to avoid naming conflicts, fixes #778 (by @adamsitnik ) e92c5b use DOTNET_MULTILEVEL_LOOKUP and IgnoreCorLibraryDuplicatedTypes to fix the... (by @adamsitnik ) 4e9844 Trimming the argument values makes them actually shorter #748 cc @ahsonkhan (by @adamsitnik ) 846d80 Merge branch 'master' of https://github.com/dotnet/BenchmarkDotNet (by @adamsitnik ) 3c3b47 have two main actions: with unroll and without, for no unroll icrease the ste... (by @adamsitnik ) 56f02c use full names in the auto-generated code to avoid possible conflicts (I just... (by @adamsitnik ) e75c44 Update documentations for WithOutlierMode (by @AndreyAkinshin ) 1840ae Merge pull request #766 from dotnet/outliers (by @AndreyAkinshin ) 5ae4bc Fixed BrandString support for Windows 10.0.17134 (by @AndreyAkinshin ) 4d6dfe BrandString support for macOS Mojave (by @AndreyAkinshin ) 426fbc Initial DocFX support, fixes #710 (by @AndreyAkinshin ) fe00d7 Merge pull request #781 from dotnet/docfx (by @AndreyAkinshin ) f0c06e Allow to pass string as ReadOnlySpan only for .NET Core 2.1 where the i... (by @adamsitnik ) bbe273 make netcoreapp2.1 default for .NET Core 2.1 + expose few things which are re... (by @adamsitnik ) bd22b3 BenchmarkDotNet.Samples refactoring, fixes #583 (by @AndreyAkinshin ) 149e5e Merge pull request #783 from dotnet/docfx-samples (by @AndreyAkinshin ) 237e36 Flat namespace for BenchmarkDotNet.Attributes (by @AndreyAkinshin ) 24d2fe Remove obsolete namespaces in IntegrationTests (by @AndreyAkinshin ) cb25a7 docs: Visual Studio-like style for code snippets (by @AndreyAkinshin ) 914922 docs: add samples for baselines (by @AndreyAkinshin ) 159e85 docs: fix year in license (by @AndreyAkinshin ) 0b02d0 docs: add IntroEnvVars (by @AndreyAkinshin ) 4b0f38 Unicode support (#735) (by @Rizzen ) 971236 Unicode support: cleanup (by @AndreyAkinshin ) 7c43da CommonExtensions cleanup (by @AndreyAkinshin ) 04c0ad Fix link to rplot.png in README.md (by @AndreyAkinshin ) b16b83 docs: samples for setup and cleanup (by @AndreyAkinshin ) c05ac6 add link to inprocesstoolchain (#790) (by @IanKemp ) 44ea0f docs: add changelog (#789) (by @AndreyAkinshin ) 8a31aa docs: save changelog details for old versions in repo (by @AndreyAkinshin ) edd0a3 docs: customizing-runtime.md (by @AndreyAkinshin ) edf7f6 Improve filtering from console args (#785) (by @adamsitnik ) d9e18d a type can have no namespace (by @adamsitnik ) 4bbffe docs: update docfx version (by @AndreyAkinshin ) 52e769 Don't exclude allocation quantum side effects for .NET Core 2.0+, fixes #794 (by @adamsitnik ) 24f8da Cake targets for DocFX (by @AndreyAkinshin ) db0724 docs: add api/index.md (by @AndreyAkinshin ) 026c00 docs: statistics (by @AndreyAkinshin ) ae5baf docs: misc fixes (by @AndreyAkinshin ) fa5cf5 docs: multiversion combobox (by @AndreyAkinshin ) a49cf9 docs: add full contributor list (by @AndreyAkinshin ) 803686 always use FQDN to avoid any possible duplicates, #529 strikes back after a year (by @adamsitnik ) 315530 make sure DisassemblyDiagnoser output is exported, fixes bug introduced in #785 (by @adamsitnik ) 167476 docs: improved diagnosers.md (by @AndreyAkinshin ) b7f9aa docs: improved choosing-run-strategy (by @AndreyAkinshin ) 5da534 remove MultimodalDistributionAnalyzer hint introduced in #763 (by @adamsitnik ) 376339 Merge pull request #796 from dotnet/docs-versions (by @adamsitnik ) 57005f Extend exported json file with FullName using xunit naming convention for int... (by @adamsitnik ) 9c0a2e docs: improved exporters.md (by @AndreyAkinshin ) 22f553 docs: better sample generation (by @AndreyAkinshin ) 734635 docs: improved columns.md (by @AndreyAkinshin ) a82562 docs: improved configs.md (by @AndreyAkinshin ) e7a458 docs: InProcess samples (by @AndreyAkinshin ) 602562 docs: imrpovded order-providers.md (by @AndreyAkinshin ) 8576c5 docs: fix the rest of WithoutDocs samples (by @AndreyAkinshin ) 13b44e docs: rename changelog-generator to _changelog (by @AndreyAkinshin ) 9a9648 docs: fix link to InProcessToolchain (by @AndreyAkinshin ) 5716c1 escape tabs and enters in the exported benchmark id (to keep it in sync with ... (by @adamsitnik ) 4be9bf MemoryDiagnoser handles IterationSetup and Cleanup since #606, removing old i... (by @adamsitnik ) f92532 add --job=core to command line arguments, fixes #793 (by @adamsitnik ) 1c656d update the docs with the change in IterationSetup behavior, #764 (by @adamsitnik ) 6fd39b job Mutators (#800)fixes #713 (by @adamsitnik ) 8954dc Rename: OrderProvider -> Orderer (#787) (by @AndreyAkinshin ) 7b47c6 Rename: Benchmark -> BenchmarkCase (#787) (by @AndreyAkinshin ) cc6f1b Rename: Target -> Descriptor (#787) (by @AndreyAkinshin ) 17bb68 Rename: EnvMode -> EnvironmentMode (#787) (by @AndreyAkinshin ) 73a6cc Rename: Infrastructure.EnvironmentVariables -> Environment.EnvironmentVariabl... (by @AndreyAkinshin ) 6118f1 Huge IterationMode renaming (#787) (by @AndreyAkinshin ) 035452 Handle super narrow distributions in AdaptiveHistogramBuilder, fixes #802 (by @AndreyAkinshin ) b705b3 print Processor Affinity as a bitmask in the summary (by @adamsitnik ) 0db126 fix MacOs build where the default affinity is 0 or we can't read it for some ... (by @adamsitnik ) 5e6e33 make sure the characteristic names match the properties names + rename Target... (by @adamsitnik ) f4cd0d Baseline improvements (#787) (by @AndreyAkinshin ) 124a52 Fix tests (#787) (by @AndreyAkinshin ) e8bf99 fix mac test, make sure IsMutator does not flow to applied job (by @adamsitnik ) 95750c Make it possible to configure Min and Max Warmup Iteration Count, fixes #809 (by @adamsitnik ) 99e753 handle new *Ansi events to make Inlining and TailCall Diagnosers work with .N... (by @adamsitnik ) 62e75c docs: update articles/contributing/documentation (by @AndreyAkinshin ) 41c5f9 Cake: update DocFX (2.36.2->2.37) (by @AndreyAkinshin ) e4b37c Cake: update .NET Core SDK (2.1.300-rc1-008673->2.1.300) (by @AndreyAkinshin ) ad1645 Cpu info improvement (#799) (by @Rizzen ) 61e95e [Params] exported to json should be delimited by \", \" #701 (by @adamsitnik ) 4cd1df handle the types as arguments to match xunit naming convention for porting pu... (by @adamsitnik ) ff6613 for type parameters we should display non-trimmed type name without namespace... (by @adamsitnik ) 89f195 explain how we measure GC stats in the docs, fixes #811 (by @adamsitnik ) c7731c Arguments should be passed to asynchronous benchmarks, fixes #818 (by @adamsitnik ) 0f9c48 add info about Min/Max counts to docs (by @adamsitnik ) 33e568 fix MemoryDiagnoserTests issues, fixes #813 (by @adamsitnik ) 844e95 set DOTNET_MULTILEVEL_LOOKUP=0 to get customDotNetCli path working, fixes #820 (by @adamsitnik ) 7e2d54 if iteration cleanup is provided, the benchmark should be executed once per i... (by @adamsitnik ) 2132d0 allow to set summary style in fluent way (by @adamsitnik ) dfea69 allow to set multuple targets for attributes without string concatenation, fi... (by @adamsitnik ) 6267b2 Use 3rd party lib for console args parsing + support globs for filtering (#824) (by @adamsitnik ) 9c269f make sure the generic type arguments are displayed in the summary, not `1 (by @adamsitnik ) c7d0b9 don't duplicate the jobs when parsing config (by @adamsitnik ) d7825e show generic type name in a joined summary (by @adamsitnik ) 528c9c make sure the config parsing and job merging works as expected (by @adamsitnik ) a7426e LLVM support in MonoDisassembler (by @AndreyAkinshin ) c724e9 Fix typos (by @AndreyAkinshin ) cdbb37 allow to filter benchmarks by simple type name, fixes #827 (by @adamsitnik ) eac833 Read StandardOutput in a smart way to avoid infinite loops (#830), #828 (by @houseofcat ) a298c2 Error message for wrong command line filter, fixes #829 (by @adamsitnik ) a7ecda initial release notes (#833) (by @adamsitnik ) 36bf7c Rename: General -> Actual (#787) (by @AndreyAkinshin ) a1ec4b Add _changelog/details/v0.11.0.md (by @AndreyAkinshin ) 558cae Improved docs for v0.11.0 (by @AndreyAkinshin ) e45f69 docs: update main.js (by @AndreyAkinshin ) 53e576 Update links to docs in README (by @AndreyAkinshin ) 3a8990 update links in docs/index.md (by @AndreyAkinshin ) 5ad710 Repair obsolete logo link (by @AndreyAkinshin ) e38afb Cake: update DocFX (2.37->2.37.1) (by @AndreyAkinshin ) 5b8f91 docs: add analytics scripts in template (by @AndreyAkinshin ) 3ec8f7 docs: add redirects to v0.10.14 (by @AndreyAkinshin ) a00bf6 docs: update how-it-works (by @AndreyAkinshin ) 73980e docs: add redirect for index.htm (by @AndreyAkinshin ) fad583 docs: update changelog for v0.11.0 (by @AndreyAkinshin ) 74d552 Update list of NuGet packages in changelog/footer/v0.11.0 (by @AndreyAkinshin ) 74084f Set library version: 0.11.0 (by @AndreyAkinshin ) Contributors (11) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Evgeny Peshkov ( @epeshk ) Ian Kemp ( @IanKemp ) Irina Ananeva ( @morgan-kn ) Lucas Trzesniewski ( @ltrzesniewski ) Mark Tkachenko ( @Rizzen ) Paul Ness ( @paulness ) Stefan ( @Tornhoof ) Tony Morris ( @afmorris ) Tristan (HouseCat) Hyams ( @houseofcat ) Thank you very much! Additional details Date: July 23, 2018 Milestone: v0.11.0 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.0"
  },
  "changelog/v0.11.1.html": {
    "href": "changelog/v0.11.1.html",
    "title": "BenchmarkDotNet v0.11.1 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.11.1 This release includes some minor improvements and bug fixes: Fixed RPlotExporter ( #852 , #855 ). In v0.11.0, the plot generation was broken because of the huge renaming in #787 . ArgumentsSource now supports additional types like Type ( #840 ), BigInteger ( #850 ), DateTime ( #853 ), and special double values like double.NaN ( #851 ) Generated projects ignore Directory.Build.props and Directory.Build.targets files #854 Now it's possible to run benchmarks with CoreRun ( de152c , #857 ) Milestone details In the v0.11.1 scope, 7 issues were resolved and 2 pull requests were merged. This release includes 29 commits by 4 contributors. Resolved issues (7) #840 ArgumentsSource doesn't work with System.RuntimeType (assignee: @AndreyAkinshin ) #850 Handle BigIntegers arguments properly (assignee: @adamsitnik ) #851 Handle double special values like NaN etc (assignee: @adamsitnik ) #852 BuildPlots script generates empty pictures (assignee: @AndreyAkinshin ) #853 ArgumentsSource containing IFormattable leads to Compile Exceptions (assignee: @adamsitnik ) #855 Empty plot (assignee: @AndreyAkinshin ) #857 Improve user experience for working with local CoreFX builds (assignee: @adamsitnik ) Merged pull requests (2) #839 Small Typo in changelog (by @Tornhoof ) #854 Exclude Directory.Build.props/targets from generated csproj files (by @agocke ) Commits (29) c37aa8 Postrelease update of v0.11.0 changelog (by @AndreyAkinshin ) b7f7fc Handle private types in GetCorrectCSharpTypeName, fixes #840 (by @AndreyAkinshin ) 522158 Handle private types in GetCorrectCSharpTypeName (part 2), fixes #840 (by @AndreyAkinshin ) 64acde small typo (#839) (by @Tornhoof ) 521c22 Add travis_wait for build.sh (by @AndreyAkinshin ) a8a0da Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 9ab58a Introduce BenchmarkDotNet.Samples.csproj.DotSettings (by @AndreyAkinshin ) 3ce9fe BenchmarkDotNet.Samples Cleanup (by @AndreyAkinshin ) a04a23 Cleanup: spelling issues in BenchmarkDotNet (by @AndreyAkinshin ) c37784 Cleanup: code style issues in BenchmarkDotNet (by @AndreyAkinshin ) 5f8452 Cleanup: Redundancies in Code issues in BenchmarkDotNet (by @AndreyAkinshin ) a76f43 Cleanup: Common Practices and Code Improvements in BenchmarkDotNet (by @AndreyAkinshin ) 2d0629 Cleanup: Redundancies in Symbol Declarations Issues in BenchmarkDotNet (by @AndreyAkinshin ) 5a7689 Cleanup: Constraints Violations Issues in BenchmarkDotNet (by @AndreyAkinshin ) 02df24 Cleanup: Language Usage Opportunities in BenchmarkDotNet (by @AndreyAkinshin ) 93ed39 Cleanup: Potential Code Quality Issues in BenchmarkDotNet (by @AndreyAkinshin ) 538f56 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin ) 559773 Cleanup: more issues in BenchmarkDotNet (by @AndreyAkinshin ) 29471e add support for BigIntegers + include namespace of the arugments, fixes #850 (by @adamsitnik ) 2aff9f Handle double and float special values like NaN, PositiveInfinity etc, fixes ... (by @adamsitnik ) 1a68ed properties of SummaryStyle must have public setter (by @adamsitnik ) 5cfb5b support DateTimes for [Arguments/Params Source], fixes #853 (by @adamsitnik ) 2be698 Fix RPlots, fixes #852 (by @AndreyAkinshin ) 7ee3cf Exclude Directory.Build.props/targets from generated csproj files (by @agocke ) 20e901 Merge pull request #854 from agocke/fix-csproj-template (by @adamsitnik ) de152c allow the users to run benchmarks with CoreRun, #857 (by @adamsitnik ) f00ac0 Increase travis timeout (by @AndreyAkinshin ) 071e58 docs: add changelog for v0.11.1 (by @AndreyAkinshin ) c5e586 Set library version: 0.11.1 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Andy Gocke ( @agocke ) Stefan ( @Tornhoof ) Thank you very much! Additional details Date: August 22, 2018 Milestone: v0.11.1 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.1"
  },
  "changelog/v0.11.2.html": {
    "href": "changelog/v0.11.2.html",
    "title": "BenchmarkDotNet v0.11.2 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.11.2 This release includes many PRs from the Hacktoberfest. We are very grateful to all the contributors who spent their time to help us make BenchmarkDotNet even better! Highlights In this release, we have many improvements in different areas: Diagnosers EtwProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file) Execution: Comparing NuGet packages (now it's possible to compare different versions of the same package) .NET Core 3.0 support Deferred Execution Validator Command-line: --list : List of benchmarks --info : Print environment info --runtimes : Choosing execution runtimes ( --runtimes net472 netcoreapp2.1 will executed a benchmark on .NET 4.7.2 and .NET Core 2.1) Options for number of invocations and iterations Custom default settings for console argument parser Case-insensitive filter Benchmarking with different CoreRun instances Hardware counters command-line support Exporters: Markdown output for DisassemblyDiagnoser Diff view for disassembler output Improved LINQPad support (colored monospaced logs) Better CPU brand strings Attributes: Async [GlobalSetup] and [GlobalCleanup] support Introduced [ParamsAllValues] Selecting Baseline across Methods and Jobs Statistics: Better statistical tests (Welch's t-test and Mann-Whitney U-test) ZeroMeasurementAnalyser RatioColumn Other: Azure Pipelines support for internal builds Many minor bug fixes Improved documentation New tests Diagnosers EtwProfiler EtwProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a trace file which can be opened with PerfView or Windows Performance Analyzer . EtwProfiler uses TraceEvent library which internally uses Event Tracing for Windows (ETW) to capture stack traces and important .NET Runtime events. Before the process with benchmarked code is started, EtwProfiler starts User and Kernel ETW sessions. Every session writes data to it's own file and captures different data. User session listens for the .NET Runtime events (GC, JIT etc) while the Kernel session gets CPU stacks and Hardware Counter events. After this, the process with benchmarked code is started. During the benchmark execution all the data is captured and written to a trace file. Moreover, BenchmarkDotNet Engine emits it's own events to be able to differentiate jitting, warmup, pilot and actual workload when analyzing the trace file. When the benchmarking is over, both sessions are closed and the two trace files are merged into one. You can find more details in the documentation and in the blog post by Adam Sitnik. #878 EtwProfiler Diagnoser (by @adamsitnik ) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik ) Execution Comparing NuGet packages Now it's possible to compare performance of several versions of the same NuGet package. An example: [Config(typeof(Config))] public class IntroNuGet { // Specify jobs with different versions of the same NuGet package to benchmark. // The NuGet versions referenced on these jobs must be greater or equal to the // same NuGet version referenced in this benchmark project. // Example: This benchmark project references Newtonsoft.Json 9.0.1 private class Config : ManualConfig { public Config() { var baseJob = Job.MediumRun.With(CsProjCoreToolchain.Current.Value); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.2\").WithId(\"11.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"11.0.1\").WithId(\"11.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.3\").WithId(\"10.0.3\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.2\").WithId(\"10.0.2\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"10.0.1\").WithId(\"10.0.1\")); Add(baseJob.WithNuGet(\"Newtonsoft.Json\", \"9.0.1\").WithId(\"9.0.1\")); } } [Benchmark] public void SerializeAnonymousObject() => JsonConvert.SerializeObject( new { hello = \"world\", price = 1.99, now = DateTime.UtcNow }); } See also: Sample: IntroNuGet #290 Question: Any official way to benchmark same method between different assembly versions? #931 Same NuGet version used when benchmarking different packages #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza ) #932 Partition benchmark run info based on added nuget packages (by @blairconrad ) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza ) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad ) cf84a4 NuGet casing fix (by @AndreyAkinshin ) .NET Core 3.0 support Now it's possible to run benchmarks on preview versions of .NET Core 3.0. #874 .NET Core 3.0 support (assignee: @adamsitnik ) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik ) Deferred Execution Validator In LINQ, execution of a query is usually deferred until the moment when you actually request the data. If your benchmark just returns IEnumerable or IQueryable it's not measuring the execution of the query, just the creation. This is why we decided to warn you about this issue whenever it happens: Benchmark IntroDeferredExecution.Wrong returns a deferred execution result (IEnumerable<Int32>). You need to either change the method declaration to return a materialized result or consume it on your own. You can use .Consume() extension method to do that. Don't worry! We are also providing you with a Consume extension method which can execute given IEnumerable or IQueryable and consume its results. All you need to do is to create a Consumer instance, preferably store it in a field (to exclude the cost of creating Consumer from the benchmark itself) and pass it to Consume extension method. Do not call .ToArray() because it's an expensive operation and it might dominate given benchmark! See also: Sample: IntroDeferredExecution #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik ) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik ) Command-line In this release, we have tons of improvements for command-line experience. --list : List of benchmarks The --list allows you to print all of the available benchmark names. Available options are: flat - prints list of the available benchmarks: --list flat BenchmarkDotNet.Samples.Algo_Md5VsSha256.Md5 BenchmarkDotNet.Samples.Algo_Md5VsSha256.Sha256 BenchmarkDotNet.Samples.IntroArguments.Benchmark BenchmarkDotNet.Samples.IntroArgumentsSource.SingleArgument BenchmarkDotNet.Samples.IntroArgumentsSource.ManyArguments BenchmarkDotNet.Samples.IntroArrayParam.ArrayIndexOf BenchmarkDotNet.Samples.IntroArrayParam.ManualIndexOf BenchmarkDotNet.Samples.IntroBasic.Sleep [...] tree - prints tree of the available benchmarks: --list tree BenchmarkDotNet └─Samples ├─Algo_Md5VsSha256 │ ├─Md5 │ └─Sha256 ├─IntroArguments │ └─Benchmark ├─IntroArgumentsSource │ ├─SingleArgument │ └─ManyArguments ├─IntroArrayParam │ ├─ArrayIndexOf │ └─ManualIndexOf ├─IntroBasic │ ├─Sleep [...] The --list option works with the --filter option. Examples: --list flat --filter *IntroSetupCleanup* prints: BenchmarkDotNet.Samples.IntroSetupCleanupGlobal.Logic BenchmarkDotNet.Samples.IntroSetupCleanupIteration.Benchmark BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkA BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkB BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkC BenchmarkDotNet.Samples.IntroSetupCleanupTarget.BenchmarkD --list tree --filter *IntroSetupCleanup* prints: BenchmarkDotNet └─Samples ├─IntroSetupCleanupGlobal │ └─Logic ├─IntroSetupCleanupIteration │ └─Benchmark └─IntroSetupCleanupTarget ├─BenchmarkA ├─BenchmarkB ├─BenchmarkC └─BenchmarkD #905 Implement --list #914 Implement --list - fixes #905 (by @wojtpl2 ) #916 Update console-args.md - add information about --list option (by @wojtpl2 ) 330f66 Implement --list - fixes #905 (#914) (by @wojtpl2 ) 6c7521 Update console-args.md - add information about --list option (#916) (by @wojtpl2 ) --info : Print environment info Some of our users really like the info we print about hardware and OS. Now we have the --info console line argument which does not run the benchmarks, but simply prints the info. BenchmarkDotNet=v0.11.1.786-nightly, OS=Windows 10.0.17134.285 (1803/April2018Update/Redstone4) Intel Xeon CPU E5-1650 v4 3.60GHz, 1 CPU, 12 logical and 6 physical cores Frequency=3507500 Hz, Resolution=285.1033 ns, Timer=TSC .NET Core SDK=3.0.100-alpha1-009642 [Host] : .NET Core 3.0.0-preview1-27004-04 (CoreCLR 4.6.27003.04, CoreFX 4.6.27003.02), 64bit RyuJIT #904 Implement --info #907 fixes #904 Implement --info (by @lahma ) 4be28d fixes #904 Implement --info (#907) (by @lahma ) --runtimes : Choosing execution runtimes The --runtimes or just -r allows you to run the benchmarks for selected Runtimes. Available options are: Mono, CoreRT, Core, Clr net46, net461, net462, net47, net471, net472, netcoreapp2.0, netcoreapp2.1, netcoreapp2.2, netcoreapp3.0. Example: run the benchmarks for .NET 4.7.2 and .NET Core 2.1: dotnet run -c Release -- --runtimes net472 netcoreapp2.1 #913 .NET Core Toolchains improvements (by @adamsitnik ) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik ) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik ) Options for number of invocations and iterations --launchCount - how many times we should launch process with target benchmark. The default is 1. --warmupCount - how many warmup iterations should be performed. If you set it, the minWarmupCount and maxWarmupCount are ignored. By default calculated by the heuristic. --minWarmupCount - minimum count of warmup iterations that should be performed. The default is 6. --maxWarmupCount - maximum count of warmup iterations that should be performed. The default is 50. --iterationTime - desired time of execution of an iteration. Used by Pilot stage to estimate the number of invocations per iteration. 500ms by default. --iterationCount - how many target iterations should be performed. By default calculated by the heuristic. --minIterationCount - minimum number of iterations to run. The default is 15. --maxIterationCount - maximum number of iterations to run. The default is 100. --invocationCount - invocation count in a single iteration. By default calculated by the heuristic. --unrollFactor - how many times the benchmark method will be invoked per one iteration of a generated loop. 16 by default --runOncePerIteration - run the benchmark exactly once per iteration. False by default. Example: run single warmup iteration, from 9 to 12 actual workload iterations. dotnet run -c Release -- --warmupCount 1 --minIterationCount 9 --maxIterationCount 12 #902 More command line args (by @adamsitnik ) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik ) Custom default settings for console argument parser If you want to have a possibility to specify custom default Job settings programmatically and optionally overwrite it with console line arguments, then you should create a global config with single job marked as .AsDefault and pass it to BenchmarkSwitcher together with the console line arguments. Example: run single warmup iteration by default. static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, GetGlobalConfig()); static IConfig GetGlobalConfig() => DefaultConfig.Instance .With(Job.Default .WithWarmupCount(1) .AsDefault()); // the KEY to get it working Now, the default settings are: WarmupCount=1 but you might still overwrite it from console args like in the example below: dotnet run -c Release -- --warmupCount 2 Case-insensitive filter The --filter or just -f allows you to filter the benchmarks by their full name ( namespace.typeName.methodName ) using glob patterns. Examples: Run all benchmarks from System.Memory namespace: -f System.Memory* Run all benchmarks: -f * Run all benchmarks from ClassA and ClassB -f *ClassA* *ClassB* Now this filter expression is case-insensitive. #864 Make the filter case insensitive (assignee: @adamsitnik ) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik ) Benchmarking with different CoreRun instances CoreRun is a simpler version of dotnet run , used for developing CoreCLR and CoreFX. Typically when working on the performance of .NET Core a developer has more than 1 copy of CoreRun. Example: CoreRun before my changes, and after my changes. This change allows to simply run same benchmark for few different CoreRuns to compare the perf in easy way. Sample usage: dotnet run -c Release -f netcoreapp2.1 -- -f *Empty.method --job dry --coreRun C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root\\CoreRun.exe C:\\Projects\\coreclr_upstream\\bin\\tests\\Windows_NT.x64.Release\\Tests\\Core_Root_beforeMyChanges\\CoreRun.exe Sample output: #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik ) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik ) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik ) Hardware counters command-line support --counters CacheMisses+InstructionRetired 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik ) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik ) Exporters Markdown output for DisassemblyDiagnoser Now DisassemblyDiagnoser generates markdown version of the assembly listing. #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik ) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik ) Diff view for disassembler output Now we have PrettyGithubMarkdownDiffDisassemblyExporter which can generates nice diffs between assembly listings. This mode can be activated via the --disasmDiff command line argument or the printDiff: true argument of DisassemblyDiagnoserConfig . An output example (Diff between SumLocal and SumField on .NET Core 2.1.4 (CoreCLR 4.6.26814.03, CoreFX 4.6.26814.02), 64bit RyuJIT) -; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumLocal() - var local = field; // we use local variable that points to the field - ^^^^^^^^^^^^^^^^^^ - mov rax,qword ptr [rcx+8] +; BenchmarkDotNet.Samples.IntroDisassemblyRyuJit.SumField() int sum = 0; ^^^^^^^^^^^^ - xor edx,edx - for (int i = 0; i < local.Length; i++) + xor eax,eax + for (int i = 0; i < field.Length; i++) ^^^^^^^^^ - xor ecx,ecx - for (int i = 0; i < local.Length; i++) + xor edx,edx + for (int i = 0; i < field.Length; i++) ^^^^^^^^^^^^^^^^ - mov r8d,dword ptr [rax+8] - test r8d,r8d + mov rcx,qword ptr [rcx+8] + cmp dword ptr [rcx+8],0 jle M00_L01 - sum += local[i]; + sum += field[i]; ^^^^^^^^^^^^^^^^ M00_L00: - movsxd r9,ecx - add edx,dword ptr [rax+r9*4+10h] - for (int i = 0; i < local.Length; i++) + mov r8,rcx + cmp edx,dword ptr [r8+8] + jae 00007ff9`0c412c1f + movsxd r9,edx + add eax,dword ptr [r8+r9*4+10h] + for (int i = 0; i < field.Length; i++) ^^^ - inc ecx - cmp r8d,ecx + inc edx + cmp dword ptr [rcx+8],edx jg M00_L00 return sum; ^^^^^^^^^^^ M00_L01: - mov eax,edx -; Total bytes of code 34 + add rsp,28h +; Total bytes of code 42 #544 Diff view for disassembler output (assignee: @wojtpl2 ) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @wojtpl2 ) #936 Producing the asm diff reports on demand #937 Producing the asm diff reports on demand - fix for #936 (by @wojtpl2 ) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @wojtpl2 ) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @wojtpl2 ) Improved LINQPad support If you run BenchmarkDotNet v0.11.2+ in LINQPad, your logs will be colored and monospaced: #447 Implement ColoredLogger for LinqPad #903 Add LINQPad logging (by @bgrainger ) #915 Use a monospaced font for LINQPad logging output (by @bgrainger ) c3b609 Add LINQPad logging (#903) (by @bgrainger ) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger ) Better CPU brand strings We did a lot of changes which improve the presentation form of the CPU brand string. Here is an example of such string in the previous version of BenchmarkDotNet: AMD Ryzen 7 2700X Eight-Core Processor (Max: 4.10GHz), 1 CPU, 16 logical and 8 physical cores Now it becomes: AMD Ryzen 7 2700X 4.10GHz, 1 CPU, 16 logical and 8 physical cores As you can see, \"Eight-Core Processor\" was removed (because we already have \"8 physical cores\"); \"(Max: 4.10GHz)\" was replaced by 4.10GHz (because the original CPU brand string doesn't contain the nominal frequency). #859 Strange max frequency values on Windows (assignee: @Rizzen ) #909 Improve CPU Brand Strings without frequency #860 Fix strange CPU Frequency values (by @Rizzen ) #910 Simplify AMD Ryzen CPU brand info (by @lahma ) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen ) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma ) Attributes Async GlobalSetup and GlobalCleanup Now GlobalSetup and GlobalCleanup methods can be async. See also: docs.setup-and-cleanup #521 Support async Setup/Cleanup #892 Added support for async GlobalSetup. (by @dlemstra ) #923 async GlobalCleanup support (by @dlemstra ) #926 Added support for async GlobalCleanup. (by @dlemstra ) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra ) a971a4 async GlobalCleanup support (#923) (by @dlemstra ) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra ) Introduced ParamsAllValues If you want to use all possible values of an enum or another type with a small number of values, you can use the [ParamsAllValues] attribute, instead of listing all the values by hand. The types supported by the attribute are: bool any enum that is not marked with [Flags] Nullable<T> , where T is an enum or boolean An example: public class IntroParamsAllValues { public enum CustomEnum { A, BB, CCC } [ParamsAllValues] public CustomEnum E { get; set; } [ParamsAllValues] public bool? B { get; set; } [Benchmark] public void Benchmark() { Thread.Sleep( E.ToString().Length * 100 + (B == true ? 20 : B == false ? 10 : 0)); } } Output: Method | E | B | Mean | Error | ---------- |---- |------ |---------:|------:| Benchmark | A | ? | 101.9 ms | NA | Benchmark | A | False | 111.9 ms | NA | Benchmark | A | True | 122.3 ms | NA | Benchmark | BB | ? | 201.5 ms | NA | Benchmark | BB | False | 211.8 ms | NA | Benchmark | BB | True | 221.4 ms | NA | Benchmark | CCC | ? | 301.8 ms | NA | Benchmark | CCC | False | 312.3 ms | NA | Benchmark | CCC | True | 322.2 ms | NA | // * Legends * E : Value of the 'E' parameter B : Value of the 'B' parameter #658 [Params] for enums should include all values by default #908 Added [ParamsAllValues] (by @gsomix ) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix ) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin ) Selecting Baseline across Methods and Jobs Now it's possible to mark a method and a job as baselines at the same time: public class TheBaselines { [Benchmark(Baseline = true)] public void Sleep100ms() => Thread.Sleep(TimeSpan.FromMilliseconds(100)); [Benchmark] public void Sleep50ms() => Thread.Sleep(TimeSpan.FromMilliseconds(50)); } static void Main(string[] args) => BenchmarkSwitcher .FromTypes(new[] { typeof(TheBaselines) }) .Run(args, DefaultConfig.Instance .With(Job.Core.AsBaseline()) .With(Job.Clr.WithId(\"CLR 4.7.2\"))); #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin ) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin ) Statistics Statistical tests In this release, statistical testing was significantly improved. Now it's possible to compare all benchmarks against baseline with the help of Welch's t-test or Mann–Whitney U test. An example: [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Microseconds, 1, true)] [StatisticalTestColumn( StatisticalTestKind.Welch, ThresholdUnit.Ratio, 0.03, true)] [StatisticalTestColumn( StatisticalTestKind.MannWhitney, ThresholdUnit.Ratio, 0.03, true)] [SimpleJob(warmupCount: 0, targetCount: 5)] public class IntroStatisticalTesting { [Benchmark] public void Sleep50() => Thread.Sleep(50); [Benchmark] public void Sleep97() => Thread.Sleep(97); [Benchmark] public void Sleep99() => Thread.Sleep(99); [Benchmark(Baseline = true)] public void Sleep100() => Thread.Sleep(100); [Benchmark] public void Sleep101() => Thread.Sleep(101); [Benchmark] public void Sleep103() => Thread.Sleep(103); [Benchmark] public void Sleep150() => Thread.Sleep(150); } Output: Method Mean Error StdDev Ratio Welch(1us)/p-values Welch(3%)/p-values MannWhitney(1us)/p-values MannWhitney(3%)/p-values Sleep50 53.13 ms 0.5901 ms 0.1532 ms 0.51 Faster: 1.0000/0.0000 Faster: 1.0000/0.0000 Faster: 1.0000/0.0040 Faster: 1.0000/0.0040 Sleep97 100.07 ms 0.9093 ms 0.2361 ms 0.97 Faster: 1.0000/0.0000 Same: 1.0000/0.1290 Faster: 1.0000/0.0040 Same: 1.0000/0.1111 Sleep99 102.23 ms 2.4462 ms 0.6353 ms 0.99 Faster: 0.9928/0.0072 Same: 1.0000/0.9994 Faster: 0.9960/0.0079 Same: 1.0000/1.0000 Sleep100 103.34 ms 0.8180 ms 0.2124 ms 1.00 Base: 0.5029/0.5029 Base: 1.0000/1.0000 Base: 0.7262/0.7262 Base: 1.0000/1.0000 Sleep101 103.73 ms 2.1591 ms 0.5607 ms 1.00 Same: 0.1041/0.8969 Same: 0.9999/1.0000 Same: 0.1111/0.9246 Same: 1.0000/1.0000 Sleep103 106.21 ms 1.2511 ms 0.3249 ms 1.03 Slower: 0.0000/1.0000 Same: 0.9447/1.0000 Slower: 0.0040/1.0000 Same: 0.9246/1.0000 Sleep150 153.16 ms 3.4929 ms 0.9071 ms 1.48 Slower: 0.0000/1.0000 Slower: 0.0000/1.0000 Slower: 0.0040/1.0000 Slower: 0.0040/1.0000 // * Legends * Mean : Arithmetic mean of all measurements Error : Half of 99.9% confidence interval StdDev : Standard deviation of all measurements Ratio : Mean of the ratio distribution ([Current]/[Baseline]) Welch(1us)/p-values : Welch-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' Welch(3%)/p-values : Welch-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(1us)/p-values : MannWhitney-based TOST equivalence test with 1 us threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' MannWhitney(3%)/p-values : MannWhitney-based TOST equivalence test with 3% threshold. Format: 'Result: p-value(Slower)|p-value(Faster)' 1 ms : 1 Millisecond (0.001 sec) The statistical testing is a work-in-progress feature. In future versions of BenchmarkDotNet, we are planning to improve API, fill missed docs, and introduce more parameters for customization. See also: Sample: IntroStatisticalTesting 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin ) 05cc8d Statistical testing improvements (by @AndreyAkinshin ) ZeroMeasurementAnalyser When you have an empty benchmark like this [Benchmark] public void Empty() { } The expected duration of this method is zero. However, you can get the mean value like 0.0023ns because of the natural noise. It's a pretty confusing result for many developers. Since v0.11.2, we have ZeroMeasurementAnalyser which warn you about such methods. By default, BenchmarkDotNet automatically evaluate overhead. In this case, ZeroMeasurementAnalyser runs Welch's t-test and compare actual and overhead measurements. If the overhead evaluation is disabled, it runs one-sample Student's t-test against a half of CPU cycle. #906 Zero measurement analyser (by @Rizzen ) 48d193 Zero measurement analyser (#906) (by @Rizzen ) RatioColumn The Ratio column was formerly known as Scaled . The old title was a source of misunderstanding and confusion because many developers interpreted it as the ratio of means (e.g., 50.46 / 100.39 for Time50 ). The ratio of distribution means and the mean of the ratio distribution are pretty close to each other in most cases, but they are not equal. See also: Sample: IntroBenchmarkBaseline , Sample: IntroRatioSD , Benchmark and Job Baselines . 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin ) Milestone details In the v0.11.2 scope, 28 issues were resolved and 33 pull requests were merged. This release includes 84 commits by 20 contributors. Resolved issues (28) #221 Investigate why CanEnableServerGcMode test fails for Core on appveyor #290 Question: Any official way to benchmark same method between different assembly versions? #447 Implement ColoredLogger for LinqPad #521 Support async Setup/Cleanup #544 Diff view for disassembler output (assignee: @WojciechNagorski ) #560 Suggestion: markdown output for DisassemblyDiagnoser (assignee: @adamsitnik ) #601 Surprising results #658 [Params] for enums should include all values by default #731 Add constant folding analyser #788 Detect correct version of .NET Core in Docket container #842 Benchmark filter: wildcards on *nix CLI (assignee: @adamsitnik ) #858 Should the Engine iterate over and consume IEnumerable and IQueryable results? (assignee: @adamsitnik ) #859 Strange max frequency values on Windows (assignee: @Rizzen ) #862 Don't print parse errors to the output (assignee: @adamsitnik ) #863 Make it easier to understand which process belongs to which benchmark (assignee: @adamsitnik ) #864 Make the filter case insensitive (assignee: @adamsitnik ) #874 .NET Core 3.0 support (assignee: @adamsitnik ) #879 Benchmark attributed with \"HardwareCounters\" throws an exception (assignee: @adamsitnik ) #880 Select Baseline across Methods and Jobs (assignee: @AndreyAkinshin ) #889 ArgumentsSource doesn't work if method takes 1 arg (assignee: @adamsitnik ) #891 Add docs about debugging BDN issues (assignee: @adamsitnik ) #904 Implement --info #905 Implement --list #909 Improve CPU Brand Strings without frequency #911 Excluding specific namespaces from disassembly (assignee: @adamsitnik ) #925 Make it possible to run the benchmark with multiple CoreRun.exe (assignee: @adamsitnik ) #931 Same NuGet version used when benchmarking different packages #936 Producing the asm diff reports on demand Merged pull requests (33) #860 Fix strange CPU Frequency values (by @Rizzen ) #878 EtwProfiler Diagnoser (by @adamsitnik ) #886 Enabled GcModeTests.CanEnableServerGcMode (by @dlemstra ) #887 Dependencies update (by @adamsitnik ) #888 Fix duplicate example in RunStrategy guide (by @stevedesmond-ca ) #890 RPlotExporter: use https to download dependencies (by @xavero ) #892 Added support for async GlobalSetup. (by @dlemstra ) #894 Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (by @dlemstra ) #898 Add workaround for Full framework on *NIX (by @mfilippov ) #900 Fixing aspnet/KestrelHttpServer url (by @facundofarias ) #901 Fixing SignalR and EntityFrameworkCore url as well (by @facundofarias ) #902 More command line args (by @adamsitnik ) #903 Add LINQPad logging (by @bgrainger ) #906 Zero measurement analyser (by @Rizzen ) #907 fixes #904 Implement --info (by @lahma ) #908 Added [ParamsAllValues] (by @gsomix ) #910 Simplify AMD Ryzen CPU brand info (by @lahma ) #913 .NET Core Toolchains improvements (by @adamsitnik ) #914 Implement --list - fixes #905 (by @WojciechNagorski ) #915 Use a monospaced font for LINQPad logging output (by @bgrainger ) #916 Update console-args.md - add information about --list option (by @WojciechNagorski ) #917 Add Azure Pipelines support (by @Ky7m ) #920 OCD Whitespace and tabs cleanup (by @dlemstra ) #922 Enables benchmarking betweeen different Nuget packages (by @Shazwazza ) #923 async GlobalCleanup support (by @dlemstra ) #926 Added support for async GlobalCleanup. (by @dlemstra ) #927 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExporter (by @WojciechNagorski ) #929 Add build status badges for Azure Pipelines (by @Ky7m ) #930 Fix minor spelling issues and typos (by @KonH ) #932 Partition benchmark run info based on added nuget packages (by @blairconrad ) #934 Detect correct version of .NET Core in Docker (by @Rizzen ) #935 Add Timeout for dotnet cli build commands to our toolchains (by @adamsitnik ) #937 Producing the asm diff reports on demand - fix for #936 (by @WojciechNagorski ) Commits (84) 22b020 Postrelease update of v0.11.1 changelog (by @AndreyAkinshin ) 3e26df docs: fix NuGet package lists in footers (v0.11.x) (by @AndreyAkinshin ) cebe2a Deferred Execution Validator, fixes #858 (by @adamsitnik ) 50fd57 exported json file should contain correct type name for generic types, not Ge... (by @adamsitnik ) 30b885 benchmarked code can be defining IHost so we need to provide full name (examp... (by @adamsitnik ) b7104e Don't print parse errors to the output, fixes #862 (by @adamsitnik ) 3a21b4 Make it easier to understand which process belongs to which benchmark, fixes ... (by @adamsitnik ) 99ea2d Fix behavior of Baseline property of Benchmark attribute in integration with ... (by @Caballero77 ) 2e398c detect .NET Core 3.0 and use the appropriate target framework moniker, fixes ... (by @adamsitnik ) ff1214 Update IntroSetupCleanupTarget.md (#876) (by @fredeil ) 1721b4 Fixed typo in the NodaTime name (#877) (by @YohDeadfall ) f411a5 Fix typo in example code (#869) (by @NRKirby ) 21a007 Support method-job baseline pairs, fixes #880 (by @AndreyAkinshin ) a78b38 Fix strange CPU Frequency values (#860) (by @Rizzen ) 60eca0 Threshold API for WelchTTest; Improve Student accuracy for small n (by @AndreyAkinshin ) 05cc8d Statistical testing improvements (by @AndreyAkinshin ) 557752 Fix compilation (by @AndreyAkinshin ) a03307 Enabled GcModeTests.CanEnableServerGcMode (#886) fixes #221 (by @dlemstra ) add585 Fix duplicate example in RunStrategy guide (#888) (by @stevedesmond-ca ) d8b008 Use NoInlining for CommonExporterApprovalTests (by @AndreyAkinshin ) eacfd7 Dependencies update (#887) (by @adamsitnik ) 579986 improve the docs, explain how to use ArgumentsSource for single arugment, fix... (by @adamsitnik ) 1ceee3 Fix compilation after merge (by @AndreyAkinshin ) 9ff772 RPlotExporter: use https to download dependencies (#890) (by @xavero ) 41d6b8 added xml docs, made some methods virtual/public to make it easier to write y... (by @adamsitnik ) cd0791 restore --no-dependencies was good when we were generating multiple projects,... (by @adamsitnik ) ad1feb expose KeepBenchmarkFiles as --keepFiles command line argument, #891 (by @adamsitnik ) 6880b5 add DebugInProcessConfig and DebugBuildConfig to make troubleshooting easier,... (by @adamsitnik ) 12e01a add Troubleshooting docs, fixes #891 (by @adamsitnik ) 106777 make the filter case insensitive invariant culture, fixes #864 (by @adamsitnik ) 1b8051 wrap * in '*' on Unix when showing users the help, fixes #842 (by @adamsitnik ) 382a4a Fix GlobalCleanupAttributeTest.GlobalCleanupMethodRunsTest (#894) (by @dlemstra ) 0f721c make it possible to specify runtimes using explicit tfms like net472 or netco... (by @adamsitnik ) 1e3df7 make it possible to specify hardware counters from command line (by @adamsitnik ) ba0d22 allow to configure the number of invocations and iterations from command line (by @adamsitnik ) b90be6 Add workaround for Full framework on *NIX (#898) (by @mfilippov ) 4afdb8 Fixing aspnet/KestrelHttpServer url (#900) (by @facundofarias ) 3319ab Fixing SignalR and EntityFrameworkCore url as well (#901) (by @facundofarias ) b72aab allow the users to specify programmatically custom default job settings and o... (by @adamsitnik ) 2e7042 Merge pull request #902 from dotnet/moreCommandLineArgs (by @adamsitnik ) 04a715 EtwProfiler Diagnoser (#878) (by @adamsitnik ) 220bae DotNetCliGenerator.TargetFrameworkMoniker must be public (by @adamsitnik ) 4e64c9 Ratio/RatioSD columns (by @AndreyAkinshin ) 177c07 Add Windows 10 (1809) in OsBrandStringHelper (by @AndreyAkinshin ) 4be28d fixes #904 Implement --info (#907) (by @lahma ) c3b609 Add LINQPad logging (#903) (by @bgrainger ) 922dff Added [ParamsAllValues] (#908), fixes #658 (by @gsomix ) 1e6235 github markdown exporter for Disassembler, fixes #560 (by @adamsitnik ) 330f66 Implement --list - fixes #905 (#914) (by @WojciechNagorski ) 10fdd0 Use a monospaced font for LINQPad logging output. (#915) (by @bgrainger ) 846d08 ParamsAllValuesValidator fixes (by @AndreyAkinshin ) 1c581e .NET Core Toolchains improvements (#913) (by @adamsitnik ) 8949df BenchmarkSwitcher should ask the user for choosing the benchmarks when the gl... (by @adamsitnik ) fb8f89 Make WindowsDisassembler public to allow for late resutls filtering in diagno... (by @adamsitnik ) 0bcbce allow configuring disasm recursive depth from console line arguments; --todo; (by @adamsitnik ) 5e3cee make sure BenchmarkSwitcher handles all possible cases and gives nice errors (by @adamsitnik ) 6c7521 Update console-args.md - add information about --list option (#916) (by @WojciechNagorski ) 8773ff when user provides categories via command line to benchmark switcher we don't... (by @adamsitnik ) 901616 when user provides CoreRun path and runtime in explicit way, we should use th... (by @adamsitnik ) 5df1e6 Simplify AMD Ryzen CPU brand info (#910) (by @lahma ) 1b4c7f OCD Whitespace and tabs cleanup (#920) (by @dlemstra ) d917e6 don't parse the trace file if there are no counters configured, wait for dela... (by @adamsitnik ) e0f7a6 Added support for async GlobalSetup. (#892) (by @dlemstra ) 46bebf allow the users to run the same benchmarks using few different CoreRun.exe, f... (by @adamsitnik ) a4f91a better handling of edge cases for parsing hardware counters from the console ... (by @adamsitnik ) 98925b initial 0.11.2 release notes (by @adamsitnik ) a971a4 async GlobalCleanup support (#923) (by @dlemstra ) e4c7b8 Added support for async GlobalCleanup. (#926), fixes #521 (by @dlemstra ) 92a786 Enables benchmarking betweeen different Nuget packages (#922) fixes #290 (by @Shazwazza ) 601c66 Add Azure Pipelines support (#917) (by @Ky7m ) f9ac68 Add build status badges (#929) (by @Ky7m ) 8a2eec Fix minor spelling issues and typos (#930) (by @KonH ) 510685 Partition benchmark run info based on added nuget packages (#932) (by @blairconrad ) 1903a1 Improve Disassembly exporters and add PrettyGithubMarkdownDiffDisassemblyExpo... (by @WojciechNagorski ) 48d193 Zero measurement analyser (#906) (by @Rizzen ) cf84a4 NuGet casing fix (by @AndreyAkinshin ) fd459f Remove remark about prerelease version in etwprofiler.md (by @AndreyAkinshin ) db444c Add Timeout for dotnet cli build commands to our toolchains (#935) fixes #933 (by @adamsitnik ) bb0b18 Detect correct version of .NET Core in Docker (#934), fixes #788 (by @Rizzen ) dd103b Producing the asm diff reports on demand - fixes #936 (#937) (by @WojciechNagorski ) 864400 Update v0.11.2 changelog (by @AndreyAkinshin ) 15c035 Minor IntroSamples fixes (by @AndreyAkinshin ) a5b692 Update v0.11.2 changelog (by @AndreyAkinshin ) 2341c7 Set library version: 0.11.2 (by @AndreyAkinshin ) Contributors (20) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Blair Conrad ( @blairconrad ) Bradley Grainger ( @bgrainger ) Caballero77 ( @Caballero77 ) Dirk Lemstra ( @dlemstra ) Evgeniy Andreev ( @gsomix ) Facundo Farias ( @facundofarias ) Flavio Xavero ( @xavero ) Fredrik Eilertsen ( @fredeil ) Igor Fesenko ( @Ky7m ) KonH ( @KonH ) Mark Tkachenko ( @Rizzen ) Marko Lahma ( @lahma ) Mikhail Filippov ( @mfilippov ) Nick Kirby ( @NRKirby ) Shannon Deminick ( @Shazwazza ) Steve Desmond ( @stevedesmond-ca ) Wojciech Nagórski ( @WojciechNagorski ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: November 1, 2018 Milestone: v0.11.2 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.2 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.2"
  },
  "changelog/v0.11.3.html": {
    "href": "changelog/v0.11.3.html",
    "title": "BenchmarkDotNet v0.11.3 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.11.3 Highlights This release is focused mainly on bug fixes that were affecting user experience. But don't worry, we have some new features too! Diagnosers ConcurrencyVisualizerProfiler (allows profiling benchmarks on Windows and exporting the data to a trace file which can be opened with Concurrency Visualizer) Command-line: --stopOnFirstError : Stops the benchmarks execution on first error. #947 --statisticalTest : Performs a Mann–Whitney Statistical Test for identifying regressions and improvements. #960 Bug fixes: Dry mode doesn't work because of the ZeroMeasurementHelper #943 MannWhitneyTest fails when comparing statistics of different sample size #948 and #950 Improve the dynamic loading of Diagnostics package #955 BenchmarkRunner.RunUrl throws NRE when Config is not provided #961 Don't require the users to do manual installation of TraceEvent when using Diagnostics package #962 Stop benchmark after closing application + Flush log after stopping benchmark #963 Diagnosers ConcurrencyVisualizerProfiler ConcurrencyVisualizerProfiler allows to profile the benchmarked .NET code on Windows and exports the data to a CVTrace file which can be opened with Concurrency Visualizer . ConcurrencyVisualizerProfiler uses EtwProfiler to get a .etl file which still can be opened with PerfView or Windows Performance Analyzer . The difference is that it also enables all Task and Thread related ETW Providers and exports a simple xml which can be opened with Visual Studio if you install Concurrency Visualizer plugin #964 Concurrency Visualizer Profiler Diagnoser (by @adamsitnik ) dfb3c89 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik ) Command-line In this release, we have some new command-line arguments! --stopOnFirstError : Stops the benchmarks execution on first error When provided, BenchmarkDotNet is going to stop the benchmarks execution on first error. #947 Add option to stop running when the first benchmark fails (by @wojtpl2 ) --statisticalTest : Statistical Test To perform a Mann–Whitney U Test and display the results in a dedicated column you need to provide the Threshold via --statisticalTest . Examples: 5%, 10ms, 100ns, 1s. Example: run Mann–Whitney U test with relative ratio of 1% for all benchmarks for .NET 4.6 (base), .NET Core 2.0 and .NET Core 2.1. class Program { static void Main(string[] args) => BenchmarkSwitcher.FromAssembly(typeof(Program).Assembly).Run(args); } public class MySample { [Benchmark] public void Sleep() { #if NETFRAMEWORK Thread.Sleep(50); #elif NETCOREAPP2_0 Thread.Sleep(45); #elif NETCOREAPP2_1 Thread.Sleep(55); #endif } [Benchmark] public void Same() => Thread.Sleep(50); } dotnet run -c Release -f netcoreapp2.1 --filter * --runtimes net46 netcoreapp2.0 netcoreapp2.1 --statisticalTest 1% Note: .NET 4.6 will be our baseline because it was provided as first on the runtimes list. Method Runtime Toolchain Mean Error StdDev Ratio MannWhitney(1%) Sleep Clr net46 50.51 ms 0.1833 ms 0.1714 ms 1.00 Base Sleep Core netcoreapp2.0 45.53 ms 0.1262 ms 0.1181 ms 0.90 Faster Sleep Core netcoreapp2.1 55.50 ms 0.1217 ms 0.1138 ms 1.10 Slower Same Clr net46 50.47 ms 0.1795 ms 0.1679 ms 1.00 Base Same Core netcoreapp2.0 50.55 ms 0.1873 ms 0.1752 ms 1.00 Same Same Core netcoreapp2.1 50.55 ms 0.2162 ms 0.2022 ms 1.00 Same Milestone details In the v0.11.3 scope, 10 issues were resolved and 10 pull requests were merged. This release includes 26 commits by 6 contributors. Resolved issues (10) #870 Error after adding OperationsPerInvoke (assignee: @AndreyAkinshin ) #885 Closing application dot't stop benchmark (assignee: @WojciechNagorski ) #933 Investigate hanging SingleBenchmarkCanBeExecutedForMultipleRuntimes test (assignee: @adamsitnik ) #939 We need an option to stop running when the first benchmark fails. (assignee: @WojciechNagorski ) #943 Dry mode doesn't work because of the ZeroMeasurementHelper (assignee: @AndreyAkinshin ) #948 BenchmarkDotNet.Mathematics.StatisticalTesting.MannWhitneyTest.PValueForSmallN(int n, int m, double u) (assignee: @AndreyAkinshin ) #950 MannWhitneyTest fails when comparing statistics of different sample size (assignee: @AndreyAkinshin ) #955 Improve the dynamic loading of Diagnostics package (assignee: @WojciechNagorski ) #961 BenchmarkRunner.RunUrl throws NRE when Config is not provided #964 Concurrency Visualizer Profiler (assignee: @adamsitnik ) Merged pull requests (10) #941 Fix example code (isBaseline -> baseline) (by @PathogenDavid ) #944 Fixed typo in IntroTagColumn sample (by @ahmedalejo ) #947 Add option to stop running when the first benchmark fails (by @WojciechNagorski ) #949 Add printDiff in DisassemblyDiagnoserAttribute (by @WojciechNagorski ) #951 Add failing test for #948 (by @WojciechNagorski ) #958 Use DependencyContext to load diagnostics assembly (by @WojciechNagorski ) #960 Expose StatisticalTestColumn via command line arguments (by @adamsitnik ) #962 Don't require the users to do manual installation of TraceEvent when using Diagnostics package (by @WojciechNagorski ) #963 Stop benchmark after closing application + Flush log after stopping benchmark. (by @WojciechNagorski ) #966 Fix typos in ConfigParser and CommandLineOptions (by @morgan-kn ) Commits (26) d85a7e Postrelease update of v0.11.2 changelog (by @AndreyAkinshin ) 8b2015 Fix ZeroMeasurementHelper for dry mode case, fixes #943 (by @AndreyAkinshin ) ab8543 Fix example code (#941) (by @PathogenDavid ) ec5fb2 Enable default analysers in BenchmarkTestExecutor (see #943) (by @AndreyAkinshin ) fb251d Remove [DryJob] from IntroBasic (by @AndreyAkinshin ) 1c1bdf Fix another problem in ZeroMeasurementAnalyser (see #943) (by @AndreyAkinshin ) 348f87 make sure we prevent from inlining the benchmarks also in the dummy method ge... (by @adamsitnik ) 80ecec when the parallel build fails, always try one more time in sequential way, ho... (by @adamsitnik ) 042291 set the metrics unit to \"Count\", they should not be empty /cc @jorive (by @adamsitnik ) 5b3657 Fixed typo in IntroTagColumn sample (#944) (by @ahmedalejo ) 60ea17 Add printDiff in DisassemblyDiagnoserAttribute (#949) (by @WojciechNagorski ) b6e8b1 Add failing test for #948 (#951) (by @WojciechNagorski ) 3e9f73 Fix IndexOutOfRangeException in MannWhitneyTest, fixes #948 (by @AndreyAkinshin ) 9f33f0 Add option to stop running when the first benchmark fails (#947) (by @WojciechNagorski ) 376a97 Improve dynamic assembly loading fixes #955 (by @WojciechNagorski ) 7dffd4 Handle another corner case in AdaptiveHistogramBuilder, fixes #870 (by @AndreyAkinshin ) dfb3c8 ConcurrencyVisualizerProfiler diagnoser! (by @adamsitnik ) 7e7dde Fix NRE in BenchmarkRunner.RunUrl, fixes #961 (by @AndreyAkinshin ) 4e6531 Improve diagnostics dll (#962) (by @WojciechNagorski ) 6c4a59 Stop benchmark after closing application + Flush log after stopping benchmark... (by @WojciechNagorski ) 51a965 Expose StatisticalTestColumn via command line arguments (#960) (by @adamsitnik ) ca188d 0.11.3 initial release notes (by @adamsitnik ) adde64 Fix typos in ConfigParser and CommandLineOptions (#966) (by @morgan-kn ) ab96ab make sure we cleanup the Logger after running the benchmark, otherwise AppDom... (by @adamsitnik ) 91362d Update v0.11.3 changelog (by @AndreyAkinshin ) e7e4b5 Set library version: 0.11.3 (by @AndreyAkinshin ) Contributors (6) Adam Sitnik ( @adamsitnik ) Ahmed Aderopo Alejo ( @ahmedalejo ) Andrey Akinshin ( @AndreyAkinshin ) David Maas ( @PathogenDavid ) Irina Ananeva ( @morgan-kn ) Wojciech Nagórski ( @WojciechNagorski ) Thank you very much! Additional details Date: November 20, 2018 Milestone: v0.11.3 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.3 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.3"
  },
  "changelog/v0.11.4.html": {
    "href": "changelog/v0.11.4.html",
    "title": "BenchmarkDotNet v0.11.4 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.11.4 It's been few months since our last release, but we have been working hard and have some new features for you! Highlights Features BenchmarkDotNet as a global tool : a new global tool which allows you to run benchmarks from given library. Now you can run benchmarks from the command line via dotnet benchmark . You can find more information about it in the documentation #1006 #213 InProcessEmitToolchain : new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments] , [ArgumentsSource] , passing the arguments by out , ref and returning stack-only types like Span<T> . #919 , #921 #843 ARM support : BenchmarkDotNet supports now ARM and ARM64. #780 , #979 #385 Mono AOT support : a new toolchain which allows running benchmarks using AOT version of Mono #940 NuGet symbol server support : BenchmarkDotNet publishes now the symbols to NuGet.org symbol server and you can easily debug it. #967 #968 Experimental support for .NET Core 3.0 WPF benchmarks #1066 For a working example please go to https://github.com/dotMorten/WPFBenchmarkTests Improvements: CoreRT Toolchain improvements - thanks to help from CoreRT Team we were able to make the CoreRT Toolchain work with the latest version of CoreRT #1001 , #1057 Display the number of benchmarks to run: we now display how many benchmarks are going to be executed before running them and how many remained after running each of them #1048 Better list of suggested benchmarks for wrong filter #834 #957 Invalid assembly binding redirects generated by VS were a pain to many of our users, we have now implemented an approach that tries to work around this issue. #895 , #667 , #896 , #942 Handling duplicates in IConfig #912 , #938 , #360 , #463 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts #1059 Give a warning when the [Benchmark] method is static - we now produce an error when users fail into this common issue #983 #985 C# keywords are prohibited as benchmark names #849 File names should be consistent across all OSes - < and > are valid on Unix, but not on Windows. We have unified that and now files produced on Unix and Windows have the same names. #981 Improve restore, build and publish projects #1002 , #1013 Make it possible to disable OptimizationsValidator #988 Sort enum parameters by value instead of name #977 Detect .NET Core benchmark failures from LINQPad #980 Improved error logging #1008 Improved disassembly diff #1022 Using invariant culture for Roslyn Toolchain error messages #1042 Use only full names in the auto-generated code to avoid any possible conflicts with user code #1007 , #1009 #1010 Write the GitHub table format to the console by default #1062 Proper cleanup on Ctrl+C/console Window exit #1061 Introduce StoppingCriteria - the first step to writing your own heuristic that determines when benchmarking should be stopped #984 Breaking changes: .NET Standard 2.0 only - BenchmarkDotNet has a single target now, which should help with some assembly resolving issues. We had to drop .NET 4.6 support because of that and .NET 4.6.1 is now the oldest supported .NET Framework. #1032 CustomCoreClrToolchain has been removed, it's recommended to use CoreRunToolchain instead #928 Bug fixes: NRE in Summary ctor #986 #987 ArgumentNullException when running benchmarks from published .NET Core app #1018 Dry jobs can eat iteration failures #1045 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure #1046 Running the example throws NullReference #1049 Fix race condition in process output reader #1051 #1053 Fix a rare but really annoying bug where for some reason we were sometimes setting ForegroundColor to the same color as BackgroundColor and some parts of the logged output were invisible commit StopOnFirstError must be respected commit Milestone details In the v0.11.4 scope, 42 issues were resolved and 41 pull requests were merged. This release includes 99 commits by 18 contributors. Resolved issues (42) #213 Add a \"benchmark\" cmd to dotnet #343 FileNotFoundException on mono (assignee: @AndreyAkinshin ) #360 Duplicates handling for IConfig (assignee: @adamsitnik ) #385 Consider using S.R.InteropServices.RuntimeInformation.ProcessArchitecture instead pointer based detection of platform (assignee: @adamsitnik ) #387 Add a mode to BenchmarkSwitcher that allows to run a method inline for profiling (assignee: @adamsitnik ) #463 Review interface IConfig (assignee: @adamsitnik ) #660 [Params] should not change the order of provided values #667 Does BenchMarkDotnet supports 4.7.1 Dotnet framework (assignee: @adamsitnik ) #687 Implement [Arguments] support for InProcessToolchain (assignee: @ig-sinicyn ) #714 Test BenchmarkDotNet against unstable/multimodal benchmarks from CoreCLR/CoreFX repo (assignee: @adamsitnik ) #780 ARM support (assignee: @adamsitnik ) #834 Better list of suggested benchmarks for wrong filter (assignee: @morgan-kn ) #843 Exception when returning a stackonly structure in a benchmark case using in-process toolchain (assignee: @ig-sinicyn ) #849 C# keywords are prohibited as benchmark names (assignee: @adamsitnik ) #895 Could not load file or assembly 'System.ValueTuple, Version=4.0.2.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51' or one of its dependencies (assignee: @adamsitnik ) #896 .NET 4.7.1 console app tries to use BenchmarkRunner, gets \"Could not load file or assembly 'System.Runtime, Version=4.1.2.0\" (assignee: @adamsitnik ) #919 Feature proposal: full-featured inprocess toolchain (assignee: @ig-sinicyn ) #928 Remove CustomCoreClrToolchain (assignee: @adamsitnik ) #938 Run benchmark with DisasemblyDiagnoser with --disasam option from console (assignee: @adamsitnik ) #942 System.IO.FileNotFoundException: Could not load file or assembly 'System.Runtime, Version=4.1.0.0' after adding BenchmarkDotNet.Diagnostics.Windows (assignee: @adamsitnik ) #967 Publish a snupkg to the NuGet.org symbol server (assignee: @WojciechNagorski ) #970 False alarm bug report #981 File names should be consistent across all OSes (assignee: @adamsitnik ) #982 Invalid string representaiton of CPU Affinity on a machine with more than 32 cores on ARM64 (assignee: @adamsitnik ) #983 Give a warning when the [Benchmark] method is static (assignee: @Rizzen ) #986 NRE in Summary ctor #988 Make it possible to disable OptimizationsValidator (assignee: @adamsitnik ) #998 Missing images in docs (assignee: @AndreyAkinshin ) #1002 Multiple build/publish failure with --coreRun toolchain (assignee: @WojciechNagorski ) #1007 benchmark cannot have type Action (assignee: @adamsitnik ) #1010 Write unit tests which check that BenchmarkProgram.txt doesn't contain usings (assignee: @adamsitnik ) #1018 ArgumentNullException when running benchmarks from published .NET Core app #1039 Some tests are broken on Net 461 (culture-dependent thing) (assignee: @ig-sinicyn ) #1045 Dry jobs can eat iteration failures (assignee: @adamsitnik ) #1046 NullReferenceException in BenchmarkDotNet.Reports.SummaryTable after iteration failure (assignee: @adamsitnik ) #1048 Display the number of benchmarks to run (assignee: @adamsitnik ) #1049 Running the example throws NullReference (assignee: @adamsitnik ) #1051 Fix race condition in process output reader (assignee: @adamsitnik ) #1056 Fails to build when targeting .NET Core 3.0 and .NET Framework (assignee: @adamsitnik ) #1059 Disassembly diagnoser should be kept in a separate directory to avoid dependency conflicts (assignee: @adamsitnik ) #1062 Write the GitHub table format to the console by default (assignee: @adamsitnik ) #1065 Allow benchmarking .NET Core Desktop apps (assignee: @adamsitnik ) Merged pull requests (41) #912 Duplicates handling for IConfig = big refactor, fixes #360 (by @adamsitnik ) #921 InProcessEmitToolchain (by @ig-sinicyn ) #940 Add support for mono AOT pass (by @alexanderkyte ) #957 Better list of suggested benchmarks for wrong filter #834 (by @morgan-kn ) #968 Support Nuget symbol server (by @WojciechNagorski ) #969 Disable batch mode and explicitly enable build trigger for master branch (by @Ky7m ) #977 sort enum parameters by value instead of name (by @kayle ) #979 ARM support (by @adamsitnik ) #980 Detect .NET Core benchmark failures from LINQPad (by @Turnerj ) #984 Introduce StoppingCriteria (by @AndreyAkinshin ) #985 Give a warning when the [Benchmark] method is static (by @Rizzen ) #987 Fix NRE in MetricColumn (#986) (by @qbit86 ) #991 Fix typos (by @0x6a62 ) #992 Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (by @glennawatson ) #996 Rephrase Notes section and fix markdown (by @Maximusya ) #997 Remove obsolete info from the docs (by @Maximusya ) #999 Synchronize benchmark output with the code in docs (by @Maximusya ) #1001 CoreRT toolchain update (by @adamsitnik ) #1006 BenchmarkDotNet as global tool (by @CodeTherapist ) #1008 Improve error logging to diagnose unstable tests (by @adamsitnik ) #1009 Use only full names in the auto-generated code to avoid any possible conflicts with user code (by @adamsitnik ) #1012 Changed TargetCount to IterationCount in docs (by @Sitiritis ) #1013 Improve restore, build and publish projects - Fix for #1002 (by @WojciechNagorski ) #1014 Update IntroRatioSD.md (by @fredeil ) #1022 Improve diff disassembly (by @WojciechNagorski ) #1032 Target .NET Standard 2.0 only (by @adamsitnik ) #1033 BenchmarkDotNet as global tool (#1006), fixes #213 (by @adamsitnik ) #1035 Improve global tool (by @WojciechNagorski ) #1036 Remove InternalsVisibleTo for Samples application (by @WojciechNagorski ) #1038 Change the name of the global tool (by @WojciechNagorski ) #1040 Making the new InProcessEmitToolchain work after my recent refactor and .NET Standard 2.0 port (by @adamsitnik ) #1041 InProcessEmitToolchain (by @adamsitnik ) #1042 Use invariant culture for csc messages (by @ig-sinicyn ) #1043 minor InProcess fix: diff now checks for implementation flags (by @ig-sinicyn ) #1052 dotnet cli version update + reducing the number of long running tests (by @adamsitnik ) #1053 read the process output in a thread safe way, fixes #1051 (by @adamsitnik ) #1054 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik ) #1055 Allow reflecting on DebuggableAttribute on CoreRT (by @MichalStrehovsky ) #1057 CoreRT toolchain improvements (by @adamsitnik ) #1061 Proper cleanup on Ctrl+C/console Window exit (by @adamsitnik ) #1066 Add experimental support for .NET Core 3.0 WPF benchmarks (by @adamsitnik ) Commits (99) 1fac9b Postrelease update of v0.11.3 changelog (by @AndreyAkinshin ) 40fae8 Support Nuget symbol server (#968) (by @WojciechNagorski ) 69b01f remove batch and explicitly enable build for master (#969) (by @Ky7m ) 01992c better error messages for lack of Cli and invalid CoreRun path (by @adamsitnik ) 767e02 sort enum parameters by value instead of name (#977), fixes #660 (by @kayle ) 128e11 Better list of suggested benchmarks for wrong filter #834 (#957) (by @morgan-kn ) c0910a Fix NRE in BaselineRatioColumn.GetRatioStatistics, fixes #970 (by @AndreyAkinshin ) 67b675 Fix TimeSpan calculations in DotNetCliCommand.AddPackages (by @AndreyAkinshin ) 847c27 Fix a few typos (by @AndreyAkinshin ) 6fb830 ARM support (#979) (by @adamsitnik ) 410d14 Detect .NET Core benchmark failures from LINQPad (#980), #975 (by @Turnerj ) 138325 File names should be consistent across all OSes, fixes #981 (by @adamsitnik ) add308 test fix for #981 (by @adamsitnik ) 77ed41 expose OriginalValues and SortedValues in the Statistics type so they get exp... (by @adamsitnik ) c0aac1 More tests for FolderNameHelper (by @AndreyAkinshin ) 3497ae Better message in MinIterationTimeAnalyser (by @AndreyAkinshin ) 91e16a Fix duplication of IsLinqPad check (by @AndreyAkinshin ) 89255c Refactoring xUnit tests to avoid non-serializable objects in MemberData (by @AndreyAkinshin ) 2cd06a Give a warning when the [Benchmark] method is static (#985) (by @Rizzen ) 5070af Fix NRE in MetricColumn (#986) (#987) (by @qbit86 ) 17378d Fix typos (#991) (by @0x6a62 ) 2ce35a Fix path to logo in README (by @AndreyAkinshin ) a20e4b always print the path, args and working dir of the auto-generated executable,... (by @adamsitnik ) 27dd87 CoreRunToolchain: when the file exists, overwrite it (by @adamsitnik ) 1b01f3 Remove obsolete info from the docs (#997) (by @Maximusya ) 299e1f Synchronized benchmark output with the code in docs (#999) (by @Maximusya ) 0da14b Rephrase Notes section and fix markdown (#996) (by @Maximusya ) 9e791f CoreRT toolchain update (#1001) (by @adamsitnik ) 04747a Use only full names in the auto-generated code to avoid any possible conflict... (by @adamsitnik ) f35465 add unit test that prevents from adding using statements to the code, fixes #... (by @adamsitnik ) fd0b8c Improve build error logging, increase the default timeout (by @adamsitnik ) 8276be Changed TargetCount to IterationCount in docs (#1012) (by @Sitiritis ) 3c98da Update IntroRatioSD.md (#1014) (by @fredeil ) 286996 Improve restore, build and publish projects - Fix for #1002 (#1013) (by @WojciechNagorski ) 923b23 BenchmarkDotNet as global tool (#1006), fixes #213 (by @CodeTherapist ) 7ef5f6 Introduce StoppingCriteria (#984) (by @AndreyAkinshin ) 5e4428 make SortedValues internal property, don't export it! (by @adamsitnik ) 5c519f Use .NET Standard 2.0 CommandLineParser, Update to net461 for NS2.0 support (... (by @glennawatson ) 6ee21b if we fail to do the full build, we try with --no-dependencies (by @adamsitnik ) 8d9714 Support machines without .NET DevPack, fix #1018 (by @AndreyAkinshin ) 573566 Add support for mono AOT pass (#940) (by @alexanderkyte ) 011c79 + InProcessEmitToolchain (by @ig-sinicyn ) 862e6e InProcessEmitToolchain cleanup (by @ig-sinicyn ) 252d7a Fix StringCanBePassedToBenchmarkAsReadOnlySpan (by @ig-sinicyn ) 7ec2f3 Check if there's something wrong with RoslynToolchain on .Net Core (by @ig-sinicyn ) 57acd6 No NOPs (thanks to @Warpten!) (by @ig-sinicyn ) bf362a Diff now compares nops (by @ig-sinicyn ) aa9ff8 + emit correct IL (by @ig-sinicyn ) 351ca5 Ignore NOPs for ldarg too (by @ig-sinicyn ) fc530f Fix build after rebase (by @ig-sinicyn ) 1577ba MonoAotToolchain refactoring, post #940 (by @adamsitnik ) 6ccf45 Improve diff disassembly (#1022) (by @WojciechNagorski ) ef090d if we fail to do the full build, we try with --no-dependencies (for the publi... (by @adamsitnik ) c69934 Give a warning when the [Benchmark] method is static: handle some edge-cases,... (by @adamsitnik ) 935ead use .NET 4.6.1 everywhere, we don't support 4.6 anymore. Cleanup after #992 (by @adamsitnik ) 20a011 C# keywords are prohibited for benchmark names, print nice error message, fix... (by @adamsitnik ) 2aec75 remove CustomCoreClrToolchain, it was causing too much trouble. We can run th... (by @adamsitnik ) f10752 Duplicates handling for IConfig = big refactor, fixes #360, closes #464 and f... (by @adamsitnik ) f9c8cc Target .NET Standard 2.0 (#1032), apply a workaround for assembly binding red... (by @adamsitnik ) aa1ded Merge branch 'master' into tools (by @adamsitnik ) ccee3e Merge pull request #1033 from dotnet/tools (by @adamsitnik ) 1b9f9f almost no warnings ;) (by @adamsitnik ) 3bd18f introduce ConfigOptions - an enum flag which make it easier to introduce new ... (by @adamsitnik ) 66c264 reverting things that should not introduce problems but did... (by @adamsitnik ) 33eaeb Merge branch 'master' into feature-inprocessemit (by @adamsitnik ) a1df27 Merge pull request #921 from ig-sinicyn/feature-inprocessemit (by @adamsitnik ) aac7a6 Improve global tool (#1035) (by @WojciechNagorski ) c01bc5 Remove InternalsVisibleTo for Samples application (#1036) (by @WojciechNagorski ) f6dbe4 Change the name of the global tool (#1038) (by @WojciechNagorski ) 11d8cb Making the new InProcessEmitToolchain work after my recent refactor and .NET ... (by @adamsitnik ) e935b5 minor InProcess fix: diff now checks for implementation flags, (#1043) (by @ig-sinicyn ) da4128 Merge pull request #1041 from dotnet/newInProcess (by @adamsitnik ) 82170f if global cleanup throws, we should report the problem but don't rethrow beca... (by @adamsitnik ) 904ddd tests that ensure that when a benchmark throws the runner does not throw, fix... (by @adamsitnik ) cbdf7b Use invariant culture for csc messages (#1042) (by @ig-sinicyn ) 5215ee Display the number of benchmarks to run, fixes #1048 (by @adamsitnik ) 84cc3e dotnet cli version update + reducing the number of long running tests (#1052)... (by @adamsitnik ) 1c431a read the process output in a thread safe way, fixes #1051 (#1053) (by @adamsitnik ) 41a367 update Travis Ubuntu image from 14.04 to 16.04 (by @adamsitnik ) 20744e allow the user to choose the strategy from console line arguments (by @adamsitnik ) 190b9b Allow reflecting on DebuggableAttribute on CoreRT (#1055) (by @MichalStrehovsky ) 9dd9e7 Ctlr+C: we should kill the entire process tree, not only for the benchmarks b... (by @adamsitnik ) d4249f Disassembly diagnoser should be kept in a separate directory to avoid depende... (by @adamsitnik ) 0b83c9 CoreRT toolchain improvements (#1057) (by @adamsitnik ) 9bc8f3 0.11.4 initial release notes (by @adamsitnik ) 13bb97 if the user provide a custom value, we should use it, post #1057 (by @adamsitnik ) ea3036 fix a rare but really annoying bug where for some reason we were sometimes se... (by @adamsitnik ) cf3f8c Proper cleanup on Ctrl+C/console Window exit (#1061) (by @adamsitnik ) 61f563 Write the GitHub table format to the console by default, fixes #1062 (by @adamsitnik ) 87d281 StopOnFirstError must be respected (by @adamsitnik ) 413d31 Add experimental support for .NET Core 3.0 WPF benchmarks (#1066), fixes #1065 (by @adamsitnik ) 69a8aa copy UseWindowsForms too (thanks @onovotny for pointing this out), post #1066 (by @adamsitnik ) d3379e Bump DocFX version (by @AndreyAkinshin ) 423204 Remove Version ComboBox in docs (by @AndreyAkinshin ) 1a8826 Update build-and-pack.cmd (by @AndreyAkinshin ) 9068d6 Update copyrights in docs (by @AndreyAkinshin ) c0c2bf Update v0.11.4 changelog (by @AndreyAkinshin ) e26441 Highlight the first column separator in the console summary table (by @AndreyAkinshin ) a704a4 Set library version: 0.11.4 (by @AndreyAkinshin ) Contributors (18) Adam Sitnik ( @adamsitnik ) Alexander Kyte ( @alexanderkyte ) Andrey Akinshin ( @AndreyAkinshin ) Code Therapist ( @CodeTherapist ) Fredrik Eilertsen ( @fredeil ) Glenn ( @glennawatson ) ig-sinicyn ( @ig-sinicyn ) Igor Fesenko ( @Ky7m ) Irina Ananeva ( @morgan-kn ) James Turner ( @Turnerj ) Jeff B. ( @0x6a62 ) kayle ( @kayle ) Maksim Yakimets ( @Maximusya ) Mark Tkachenko ( @Rizzen ) Michal Strehovský ( @MichalStrehovsky ) Tymur Lysenko ( @Sitiritis ) Viktor Pti ( @qbit86 ) Wojciech Nagórski ( @WojciechNagorski ) Thank you very much! Additional details Date: February 15, 2019 Milestone: v0.11.4 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.4 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.4"
  },
  "changelog/v0.11.5.html": {
    "href": "changelog/v0.11.5.html",
    "title": "BenchmarkDotNet v0.11.5 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.11.5 Highlights Features and noticeable improvements Power plan management Now BenchmarkDotNet executes all benchmarks with enabled High-Performance power plan (configurable, Windows-only). You can find some details below. #68 #952 Better Environment Variables API Now we have some additional extension methods which allow defining environment variables in user jobs. In the previous version, users always had to set an array of environment variables like this: job.With(new[] { new EnvironmentVariable(\"a\", \"b\") }) . Now it's possible to define an environment variable like job.With(new EnvironmentVariable(\"a\", \"b\")) or job.WithEnvironmentVariable(\"a\", \"b\") . Also, it's possible to clear the list of environment variables via job.WithoutEnvironmentVariables() . #1069 #1080 Better outlier messages The previous version of BenchmarkDotNet printed information about detected or removed outliers like this: \"3 outliers were detected\". It was nice, but it didn't provide additional information about these outliers (users had to read the full log to find the outliers values). Now BenchmarkDotNet prints additional information about outlier values like this: \"3 outliers were detected (2.50 us..2.70 us)\". e983cd31 Support modern CPU architecture names In the environment information section, BenchmarkDotNet prints not only the processor brand string, but also its architecture (e.g., \"Intel Core i7-4770K CPU 3.50GHz (Haswell)\"). However, it failed to recognize some recent processors. Now it's able to detect the architecture for modern Intel processors correctly (Kaby Lake, Kaby Lake R, Kaby Lake G, Amber Lake Y, Coffee Lake, Cannon Lake, Whiskey Lake). 995e053d Introduce BenchmarkDotNet.Annotations Currently, BenchmarkDotNet targets .NET Standard 2.0. It makes some users unhappy because they want to define benchmarks in projects with lower target framework. We decided to start working on the BenchmarkDotNet.Annotations NuGet package which targets .NET Standard 1.0 and contains classes that users need to define their benchmarks. However, it's not easy to refactor the full source code base and move all relevant public APIs to this package. In v0.11.5, we did the first step and moved some of these APIs to BenchmarkDotNet.Annotations . We want to continue moving classes to this package and get full-featured annotation package in the future. #1084 #1096 Use InProcessEmitToolchain by default in InProcess benchmarks In BenchmarkDotNet 0.11.4, we introduced InProcessEmitToolchain . It's a new, full-featured InProcess toolchain which allows executing benchmarks in the current process without spawning additional process per benchmark. It supports [Arguments] , [ArgumentsSource] , passing the arguments by out , ref and returning stack-only types like Span<T> . However, in v0.11.4, it can be activated only if InProcessEmitToolchain is declared explicitly. Now it's enabled by default when [InProcessAttribute] is used. #1093 Introduce an option which prevents overwriting results Currently, BenchmarkDotNet overwrites results each time when the benchmarks are executed. It allows avoiding tons of obsolete files in the BenchmarkDotNet.Artifacts folder. However, the behavior doesn't fit all use cases: sometimes users want to keep results for old benchmark runs. Now we have a special option for it. The option can be activated via --noOverwrite console line argument or DontOverwriteResults extension method for IConfig #1074 #1083 Other improvements and bug fixes Diagnostics and validation Better benchmark declaration error processing In the previous version, BenchmarkDotNet threw an exception when some benchmark methods had an invalid declaration (e.g., invalid signature or invalid access modifiers). Now it prints a nice error message without ugly stack traces. #1107 Better error message for users who want to debug benchmarks #1073 Don't show the same validation error multiple times Now each error will be printed only once. #1079 Restrict MemoryDiagnoserAttribute usage to class Now it's impossible to accidentally mark a method with this attribute. #1119 #1122 Export Better indentation in disassembly listings Now DissassemblyDiagnoser correctly process source code which contains tab as the indentation symbol #1110 Fix incorrect indentation for StackOverflow exporter Previously, StackOverflow exporter doesn't have a proper indent for job runtimes in the environment information. Now it's fixed. #826 #1104 Fix StackOverflowException in XmlExporter.Full #1086 #1090 Shortify MemoryDiagnoser column titles Now we use the following column titles: \"Allocated\" instead of \"Allocated Memory/Op\", \"Gen 0\" instead of \"Gen 0/1k Op\". The full description of each column can be found in the legend section below the summary table. #1081 Benchmark generation and execution Fixed broken Orderers The previous version has a nasty bug with custom orderers. Now it's fixed. #1070 #1109 Better overhead evaluation In the previous version, BenchmarkDotNet evaluated the benchmark overhead as a mean value of all overhead iteration. It was fine in most cases, but in some cases, the mean value can be spoiled by outliers. Now BenchmarkDotNet uses the median value. #1116 Respect CopyLocalLockFileAssemblies Now BenchmarkDotNet respect the CopyLocalLockFileAssemblies value and copies it to the generated benchmark project. #1068 #1108 Disable CodeAnalysisRuleSet for generated benchmarks Previously, generated benchmarks may fail if the CodeAnalysisRuleSet is defined in Directory.Build.Props . #1082 Supported undefined enum values #1020 #1071 Other minor improvements and bug fixes Power plans In #952 , power plan management was implemented. It resolves a pretty old issue #68 which was created more than three years ago. Now BenchmarkDotNet forces OS to execute a benchmark on the High-Performance power plan. You can disable this feature by modifying PowerPlanMode property. Here is an example where we are playing with this value: [Config(typeof(Config))] public class IntroPowerPlan { private class Config : ManualConfig { public Config() { Add(Job.MediumRun.WithPowerPlan(PowerPlan.HighPerformance)); Add(Job.MediumRun.WithPowerPlan(PowerPlan.UserPowerPlan)); } } [Benchmark] public int IterationTest() { int j = 0; for (int i = 0; i < short.MaxValue; ++i) j = i; return j; } [Benchmark] public int SplitJoin() => string.Join(\",\", new string[1000]).Split(',').Length; } And here is an example of the summary table on plugged-off laptop: Method | PowerPlan | Mean | Error | StdDev | -------------- |---------------- |---------:|----------:|----------:| IterationTest | HighPerformance | 40.80 us | 0.4168 us | 0.6109 us | SplitJoin | HighPerformance | 13.24 us | 0.2514 us | 0.3763 us | IterationTest | UserPowerPlan | 79.72 us | 2.5623 us | 3.8352 us | SplitJoin | UserPowerPlan | 24.54 us | 2.1062 us | 3.1525 us | As you can see, the power plan produces a noticeable effect on the benchmark results. This feature is available on Windows only. Milestone details In the v0.11.5 scope, 16 issues were resolved and 16 pull requests were merged. This release includes 44 commits by 12 contributors. Resolved issues (16) #68 Power management #826 MarkdownExporter.StackOverflow fails to indent jobs' runtime descriptions (assignee: @alinasmirnova ) #976 System.NotSupportedException: Line must start with GC (assignee: @adamsitnik ) #1020 Errors using undefined enum values as benchmark arguments (assignee: @adamsitnik ) #1068 The csproj setting CopyLocalLockFileAssemblies is ignored #1070 System.InvalidOperationException: Sequence contains more than one matching element after 0.11.4 (assignee: @AndreyAkinshin ) #1071 Enum flags results into compiler errors (assignee: @adamsitnik ) #1073 The error message for users who want to Debug benchmarks is not clear (assignee: @adamsitnik ) #1074 Results should be exported to a file with unique name #1079 Dont display the same Validation Error many times (assignee: @adamsitnik ) #1086 XmlExporter.Full fails with StackOverflowException #1107 Unhandled Exception: System.InvalidOperationException: Benchmark method '' has incorrect signature. Method shouldn't have any arguments. (assignee: @AndreyAkinshin ) #1109 Issue with DefaultOrderer #1110 DisassemblyDiagnoser assumes indentation uses spaces (assignee: @AndreyAkinshin ) #1116 Use Median instead of Mean whe deducing Overhead (assignee: @AndreyAkinshin ) #1119 MemoryDiagnoserAttribute on methods (assignee: @Rizzen ) Merged pull requests (16) #952 Implemented power-management, add docs (#68) (by @MarekM25 ) #1080 Improved Environment Variables API, resolves #1069 (by @AndreyAkinshin ) #1081 Shortify MemoryDiagnoser column titles (by @AndreyAkinshin ) #1082 Make it so that the code analysis settings are disabled. (by @glennawatson ) #1083 make it possible to Don't Overwrite Results, fixes #1074 (by @adamsitnik ) #1084 introduce BenchmarkDotNet.Annotations (by @adamsitnik ) #1088 Typo (by @Stromberg90 ) #1090 XmlExporter.Full fails (by @daveMueller ) #1093 make InProcessEmitToolchain the default one (by @adamsitnik ) #1096 move more simple Attributes to BenchmarkDotNet.Annotations (by @adamsitnik ) #1104 fix #826 (by @alinasmirnova ) #1105 Just spell check (by @sungam3r ) #1108 Fix #1068 - Copy value of CopyLocalLockFileAssemblies (by @WojciechNagorski ) #1112 Fixed event wire-up before Session acquisition (by @jzabroski ) #1122 Restrict MemoryDiagnoserAttribute usage to class (by @Rizzen ) #1126 Styling in docfx fashion (by @robertmuehsig ) Commits (44) 0a63e4 Postrelease update of v0.11.4 changelog (by @AndreyAkinshin ) f94616 Fix namespace for JobTests (by @AndreyAkinshin ) 995e05 Support modern CPUs in ProcessorBrandStringHelper (by @AndreyAkinshin ) f946ba Repair custom orderers, fixes #1070 (by @AndreyAkinshin ) 1d3783 allow passing Enum Flags and undefined enum values as benchmarks arguments/pa... (by @adamsitnik ) dfe9ca make sure that we can pass undefined enum values and the bug never comes back... (by @adamsitnik ) 76b467 improve the error message when users try to run the benchmarks in Debug, fixe... (by @adamsitnik ) 98d9f8 Dont display the same Validation Error many times, fixes #1079 (by @adamsitnik ) 03981c fix the unit test that I broke when I was fixing #1071 (by @adamsitnik ) 877aba Throw exception about private benchmark method (by @AndreyAkinshin ) e983cd Print some outlier values in OutliersAnalyser (by @AndreyAkinshin ) b5d324 Shortify MemoryDiagnoser column titles (#1081) (by @AndreyAkinshin ) c5c4c4 handle undefined negative enum values, #1020 (thanks @TylerBrinkley) (by @adamsitnik ) 2f273c Improved Environment Variables API, resolves #1069 (#1080) (by @AndreyAkinshin ) ff2847 Implement FrequencyTests.ParseTest (by @AndreyAkinshin ) 5e25da Make it so that the code analysis settings are disabled for compiled builds (... (by @glennawatson ) db701e make it possible to Don't Overwrite Results, fixes #1074 (#1083) (by @adamsitnik ) a12d8c introduce BenchmarkDotNet.Annotations (#1084) (by @adamsitnik ) dcc40a Typo (#1088) (by @Stromberg90 ) 2c392a XmlExporter.Full fails #1090 (by @daveMueller ) 8968bb make InProcessEmitToolchain the default one (#1093) (by @adamsitnik ) 4c9136 move more simple Attributes to BenchmarkDotNet.Annotations (#1096) (by @adamsitnik ) 6f524f Added extra output lines for jobs in test (by @alinasmirnova ) 27ed8a Logger with prefix works correctly with multiline input (by @alinasmirnova ) a846b8 just spell check (#1105) (by @sungam3r ) a2da9a Reverted reporter change (by @alinasmirnova ) e1c9b9 Merge pull request #1104 from alinasmirnova/master (by @AndreyAkinshin ) e45adc Fix #1068 - Copy value of CopyLocalLockFileAssemblies (#1108) (by @WojciechNagorski ) 2f823c don't fail with exception if user has written something to output in GlobalCl... (by @adamsitnik ) 8bc2cc Fixed event wire-up before Session acquisition (#1112) (by @jzabroski ) db3a8f Better handling of benchmark with incorrect signature, fixes #1107 (by @AndreyAkinshin ) 8a8e01 Fix GlobalSetupAttributeMethodsMustHaveNoParameters (by @AndreyAkinshin ) 52eca7 Better disasm indentation, fixes #1110 (by @AndreyAkinshin ) d9901b Use Median instead of Mean for overhead calculations, fixes #1116 (by @AndreyAkinshin ) 1c1913 add dotnet/performance to the list of users (by @adamsitnik ) e1d4d2 Restrict MemoryDiagnoserAttribute usage to class (#1122), fixes #1119 (by @Rizzen ) 8aa6ad Implemented power-management, add docs (#68) (#952) (by @MarekM25 ) 9c6cad Improve ApplyUserPowerPlan message (by @AndreyAkinshin ) d12414 Initial v0.11.5 changelog (by @AndreyAkinshin ) 1babcb styling in docfx fashion (by @robertmuehsig ) fb1286 Add netstandard2.0 target framework in BenchmarkDotNet.Annotations (by @AndreyAkinshin ) b7118e Add BenchmarkDotNet.Annotations in build-and-pack.cmd (by @AndreyAkinshin ) 8721a9 Prepare v0.11.5 changelog (by @AndreyAkinshin ) 31ea3d Set library version: 0.11.5 (by @AndreyAkinshin ) Contributors (12) Adam Sitnik ( @adamsitnik ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) David Müller ( @daveMueller ) Glenn ( @glennawatson ) Ivan Maximov ( @sungam3r ) John Zabroski ( @jzabroski ) Marek Moraczyński ( @MarekM25 ) Mark Tkachenko ( @Rizzen ) Robert Muehsig ( @robertmuehsig ) Strømberg ( @Stromberg90 ) Wojciech Nagórski ( @WojciechNagorski ) Thank you very much! Additional details Date: April 2, 2019 Milestone: v0.11.5 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.11.5 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.11.5"
  },
  "changelog/v0.12.0.html": {
    "href": "changelog/v0.12.0.html",
    "title": "BenchmarkDotNet v0.12.0 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.12.0 It's been several months since our last release, but we have been working hard and have some new features for you! Highlights Features and major improvements Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48) , [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48) , Job.Default.With(CoreRuntime.Core31) jobs in a manual config. You can find more details below. #1188 , #1186 , #1236 Official templates for BenchmarkDotNet-based projects With the help of the BenchmarkDotNet.Templates NuGet package, you can easily create new projects from the command line via dotnet new benchmark . This command has a lot of useful options, so you can customize your new project as you want. #1044 New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. #457 , #1131 , #1208 , #1214 , #1218 , #1219 New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items (the number of work items that have been processed in ThreadPool per single operation) and Lock Contentions (the number of times there was contention upon trying to take a Monitor's lock per single operation). Internally, it uses new APIs exposed in .NET Core 3.0. #1154 , #1227 Improved MemoryDiagnoser Now MemoryDiagnoser includes memory allocated by all threads that were live during benchmark execution: a new GC API was exposed in .NET Core 3.0 preview6+. It allows to get the number of allocated bytes for all threads. #1155 , #1153 , #723 LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported! #1241 , #1245 Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! #1148 , #1158 Minor summary and exporter improvements Improved presentation of the current architecture in the environment information In the previous version of BenchmarkDotNet, the reports always contained \"64bit\" or \"32bit\" which did not tell if it was ARM or not. Now it prints the full architecture name ( x64 , x86 , ARM , or ARM64 ). For example, instead of .NET Framework 4.8 (4.8.3815.0), 64bit RyuJIT you will get .NET Framework 4.8 (4.8.3815.0), X64 RyuJIT or .NET Framework 4.8 (4.8.3815.0), ARM64 RyuJIT . #1213 Simplified reports for Full .NET Framework version Previous version: .NET Framework 4.7.2 (CLR 4.0.30319.42000), 64bit RyuJIT-v4.7.3324.0 . Current version: .NET Framework 4.7.2 (4.7.3362.0), 64bit RyuJIT . #1114 , #1111 More reliable CPU info on Windows We added a workaround to for a bug in wmic that uses \\r\\r\\n as a line separator. #1144 , #1145 Better naming for generated plots When [RPlotExporter] is used, BenchmarkDotNet generates a lot of useful plots in the BenchmarkDotNet.Artifacts folder. The naming of the plot files was improved: benchmarks without Params doesn't include a double dash ( -- ) in their names anymore. 1183 , 1212 Better density plot precision The previous version of BenchmarkDotNet used the rule-of-thumb bandwidth selector in RPlotExporter density plots. It was fine for unimodal distributions, but sometimes it produced misleading plots for multimodal distributions. Now, RPlotExporter uses the Sheather&Jones bandwidth selector that significantly improves the presentation of the density plots for complex distributions. 58fde64 Better alignment in HtmlExporter Now BenchmarkDotNet aligns the content exported by HtmlExporter to the right. #1189 dfa074 Better precision calculation in SummaryTable 4e9eb43 Better summary analysis BenchmarkDotNet warns the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed. #1161 , #600 Make log file datetime format 24-hour #1149 Improve AskUser prompt message The error messages will surround * by quotes on Linux and macOS. #1147 Minor API improvements ED-PELT algorithm for changepoint detection is now available You can find details in this blog post . f89091 Improved OutlierMode API BenchmarkDotNet performs measurement postprocessing that may remove some of the outlier values (it can be useful to remove upper outliers that we get because of the natural CPU noise). In the previous version, naming for the OutlierMode values was pretty confusing: None/OnlyUpper/OnlyLower/All . Now, these values were renamed to DontRemove/RemoveUpper/RemoveLower/RemoveAll . For example, if you want to remove all the outliers, you can annotate your benchmark with the [Outliers(OutlierMode.RemoveAll)] attribute. The old names still exist (to make sure that the changes are backward compatible), but they are marked as obsolete, and they will be removed in the future versions of the library. #1199 , 0e4b8e Add the possibility to pass Config to BenchmarkSwitcher.RunAll and RunAllJoined #1194 , ae23bd Improved command line experience When user uses --packages $path , the $path will be sent to the dotnet build command as well. 1187 Extend the list of supported power plans. Now it supports \"ultimate\", \"balanced\", and \"power saver\" plans. #1132 , #1139 Make it possible to not enforce power plan on Windows. 1578c5c Guid support in benchmark arguments Now you can use Guid instances as benchmark arguments. 04ec20b Make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a single argument to mimic MemberData behaviour. ec296dc Make FullNameProvider public So it can be reused by the dotnet/performance repository. 6d71308 Extend Summary with LogFilePath #1135 , 6e6559 Allow namespace filtering for InliningDiagnoser #1106 , #1130 Option to configure MaxParameterColumnWidth #1269 , 4ec888 Other improvements Misc improvements in the documentation #1175 , #1173 , #1180 , #1203 , #1204 , #1206 , #1209 , #1219 , #1225 , #1279 Copy PreserveCompilationContext MSBuild setting from the project that defines benchmarks #1152 , 063d1a Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler #1179 , a106b1 Consume CoreRT from the new NuGet feed Because CoreRT no longer publishes to MyGet. #1129 Breaking changes: The [ClrJob] , [CoreJob] and [CoreRtJob] attributes got obsoleted and replaced by a [SimpleJob] which requires the user to provide target framework moniker in an explicit way. (See the \"Advanced multiple target frameworks support\" section for details.) #1188 , #1182 , #1115 , #1056 , #993 , The old InProcessToolchain is now obsolete. It's recommended to use InProcessEmitToolchain . If you want to use the old one on purpose, you have to use InProcessNoEmitToolchain . #1123 Bug fixes: Invalid arg passing in StreamLogger constructor. The append arg was not passed to the StreamWriter .ctor. #1185 Improve the output path of .etl files produced by EtwProfiler . EtwProfiler was throwing NRE for users who were using [ClrJob] and [CoreJob] attributes. #1156 , #1072 Flush custom loggers at the end of benchmark session. #1134 Make ids for tag columns unique - when using multiple TagColumns only one TagColumn was printed in the results. #1146 Advanced multiple target frameworks support Now BenchmarkDotNet supports .NET Framework 4.8, .NET Core 3.1, and .NET Core 5.0. Also, we reworked our API that allows targeting several runtimes from the same config: the new API is more consistent, flexible, and powerful. For example, if you want to execute your benchmarking using .NET Framework 4.8 and .NET Core 3.1, you can use the SimpleJob(RuntimeMoniker.Net48) , [SimpleJob(RuntimeMoniker.NetCoreApp31)] attributes or Job.Default.With(ClrRuntime.Net48) , Job.Default.With(CoreRuntime.Core31) jobs in a manual config. Now let's discuss how to use it in detail. If you want to test multiple frameworks, your project file MUST target all of them and you MUST install the corresponding SDKs : <TargetFrameworks>netcoreapp3.0;netcoreapp2.1;net48</TargetFrameworks> If you run your benchmarks without specifying any custom settings, BenchmarkDotNet is going to run the benchmarks using the same framework as the host process (it corresponds to RuntimeMoniker.HostProcess ): dotnet run -c Release -f netcoreapp2.1 # is going to run the benchmarks using .NET Core 2.1 dotnet run -c Release -f netcoreapp3.0 # is going to run the benchmarks using .NET Core 3.0 dotnet run -c Release -f net48 # is going to run the benchmarks using .NET 4.8 mono $pathToExe # is going to run the benchmarks using Mono from your PATH To run the benchmarks for multiple runtimes with a single command from the command line, you need to specify the runtime moniker names via --runtimes|-r console argument: dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 netcoreapp3.0 # is going to run the benchmarks using .NET Core 2.1 and .NET Core 3.0 dotnet run -c Release -f netcoreapp2.1 --runtimes netcoreapp2.1 net48 # is going to run the benchmarks using .NET Core 2.1 and .NET 4.8 What is going to happen if you provide multiple Full .NET Framework monikers? Let's say: dotnet run -c Release -f net461 net472 net48 Full .NET Framework always runs every .NET executable using the latest .NET Framework available on a given machine. If you try to run the benchmarks for a few .NET TFMs, they are all going to be executed using the latest .NET Framework from your machine. The only difference is that they are all going to have different features enabled depending on the target version they were compiled for. You can read more about this here and here . This is .NET Framework behavior which can not be controlled by BenchmarkDotNet or any other tool . Note: Console arguments support works only if you pass the args to BenchmarkSwitcher : class Program { static void Main(string[] args) => BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args); // crucial to make it work } You can achieve the same thing using [SimpleJobAttribute] : using BenchmarkDotNet.Attributes; using BenchmarkDotNet.Jobs; namespace BenchmarkDotNet.Samples { [SimpleJob(RuntimeMoniker.Net48)] [SimpleJob(RuntimeMoniker.Mono)] [SimpleJob(RuntimeMoniker.NetCoreApp21)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] public class TheClassWithBenchmarks Or using a custom config: using BenchmarkDotNet.Configs; using BenchmarkDotNet.Environments; using BenchmarkDotNet.Jobs; using BenchmarkDotNet.Running; namespace BenchmarkDotNet.Samples { class Program { static void Main(string[] args) { var config = DefaultConfig.Instance .With(Job.Default.With(CoreRuntime.Core21)) .With(Job.Default.With(CoreRuntime.Core30)) .With(Job.Default.With(ClrRuntime.Net48)) .With(Job.Default.With(MonoRuntime.Default)); BenchmarkSwitcher .FromAssembly(typeof(Program).Assembly) .Run(args, config); } } } The recommended way of running the benchmarks for multiple runtimes is to use the --runtimes console line argument. By using the console line argument, you don't need to edit the source code anytime you want to change the list of runtimes. Moreover, if you share the source code of the benchmark, other people can run it even if they don't have the exact same framework version installed. Official templates for BenchmarkDotNet-based projects Since v0.12.0, BenchmarkDotNet provides project templates to setup your benchmarks easily. The template exists for each major .NET language ( C# , F# and VB ) with equivalent features and structure. The templates require the .NET Core SDK . Once installed, run the following command to install the templates: dotnet new -i BenchmarkDotNet.Templates If you want to uninstall all BenchmarkDotNet templates: dotnet new -u BenchmarkDotNet.Templates The template is a NuGet package distributed over nuget.org: BenchmarkDotNet.Templates . To create a new C# benchmark library project from the template, run: dotnet new benchmark If you'd like to create F# or VB project, you can specify project language with -lang option: dotnet new benchmark -lang F# dotnet new benchmark -lang VB The template projects have five additional options - all of them are optional. By default, a class library project targeting netstandard2.0 is created. You can specify -f or --frameworks to change target to one or more frameworks: dotnet new benchmark -f netstandard2.0;net472 The option --console-app creates a console app project targeting netcoreapp3.0 with an entry point: dotnet new benchmark --console-app This lets you run the benchmarks from a console ( dotnet run ) or from your favorite IDE. The option -f or --frameworks will be ignored when --console-app is set. The option -b or --benchmarkName sets the name of the benchmark class: dotnet new benchmark -b Md5VsSha256 BenchmarkDotNet lets you create a dedicated configuration class (see Configs ) to customize the execution of your benchmarks. To create a benchmark project with a configuration class, use the option -c or --config : dotnet new benchmark -c The option --no-restore if specified, skips the automatic NuGet restore after the project is created: dotnet new benchmark --no-restore Use the -h or --help option to display all possible arguments with a description and the default values: dotnet new benchmark --help The version of the template NuGet package is synced with the BenchmarkDotNet package. For instance, the template version 0.12.0 is referencing BenchmarkDotnet 0.12.0 - there is no floating version behavior. For more info about the dotnet new CLI, please read the documentation . New NativeMemoryProfiler NativeMemoryProfiler measure the native memory traffic and adds the extra columns Allocated native memory and Native memory leak to the summary table. Internally, it uses EtwProfiler to profile the code using ETW. Consider the following benchmark: [ShortRunJob] [NativeMemoryProfiler] [MemoryDiagnoser] public class IntroNativeMemory { [Benchmark] public void BitmapWithLeaks() { var flag = new Bitmap(200, 100); var graphics = Graphics.FromImage(flag); var blackPen = new Pen(Color.Black, 3); graphics.DrawLine(blackPen, 100, 100, 500, 100); } [Benchmark] public void Bitmap() { using (var flag = new Bitmap(200, 100)) { using (var graphics = Graphics.FromImage(flag)) { using (var blackPen = new Pen(Color.Black, 3)) { graphics.DrawLine(blackPen, 100, 100, 500, 100); } } } } private const int Size = 20; // Greater value could cause System.OutOfMemoryException for test with memory leaks. private int ArraySize = Size * Marshal.SizeOf(typeof(int)); [Benchmark] public unsafe void AllocHGlobal() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); Marshal.FreeHGlobal(unmanagedHandle); } [Benchmark] public unsafe void AllocHGlobalWithLeaks() { IntPtr unmanagedHandle = Marshal.AllocHGlobal(ArraySize); Span<byte> unmanaged = new Span<byte>(unmanagedHandle.ToPointer(), ArraySize); } } It will produce the summary table like this one: Method Mean Error StdDev Gen 0 Gen 1 Gen 2 Allocated Allocated native memory Native memory leak BitmapWithLeaks 73,456.43 ns 22,498.10 ns 1,233.197 ns - - - 177 B 13183 B 11615 B Bitmap 91,590.08 ns 101,468.12 ns 5,561.810 ns - - - 180 B 12624 B - AllocHGlobal 79.91 ns 43.93 ns 2.408 ns - - - - 80 B - AllocHGlobalWithLeaks 103.50 ns 153.21 ns 8.398 ns - - - - 80 B 80 B As you can see, we have two additional columns Allocated native memory and Native memory leak that contain some very useful numbers! New ThreadingDiagnoser ThreadingDiagnoser also adds two extra columns to the summary table: Completed Work Items : The number of work items that have been processed in ThreadPool (per single operation) Lock Contentions : The number of times there was contention upon trying to take a Monitor's lock (per single operation) Internally, it uses new APIs exposed in .NET Core 3.0. It can be activated with the help of the [ThreadingDiagnoser] attribute: [ThreadingDiagnoser] public class IntroThreadingDiagnoser { [Benchmark] public void CompleteOneWorkItem() { ManualResetEvent done = new ManualResetEvent(initialState: false); ThreadPool.QueueUserWorkItem(m => (m as ManualResetEvent).Set(), done); done.WaitOne(); } } The above example will print a summary table like this one: Method Mean StdDev Median Completed Work Items Lock Contentions CompleteOneWorkItem 8,073.5519 ns 69.7261 ns 8,111.6074 ns 1.0000 - LINQPad 6 support Now both LINQPad 5 and LINQPad 6 are supported: Fast documentation search We continue to improve the usability of our documentation. In this release, we improved the search experience in the documentation: now it works almost instantly with the help of Algolia engine! That's how it looks: Milestone details In the v0.12.0 scope, 44 issues were resolved and 56 pull requests were merged. This release includes 110 commits by 24 contributors. Resolved issues (44) #198 [Feature request] No logger for benchmark run? (assignee: @CodeTherapist ) #311 How to debug benchmarks that fail with exception on file system access operations (assignee: @adamsitnik ) #457 Track Native Memory Allocations and more informations with our ETW Memory Diagnoser #600 Scaling issue #723 MemoryDiagnoser should include memory allocated by all Threads that were live during benchmark execution (assignee: @adamsitnik ) #995 Running benchmark fails when targeting netcoreapp2.2 (assignee: @adamsitnik ) #1028 Add new template for \"dotnet new benchmark\" (assignee: @CodeTherapist ) #1072 EtwProfiler exports trace file only for a single runtime when Runtimes are controlled via attributes (assignee: @adamsitnik ) #1106 Allow user defined namespace filter for InliningDiagnoser #1111 Change the format of printed Full .NET Framework Version (assignee: @adamsitnik ) #1115 Running using dotnet benchmark uses wrong core runtime #1132 The power management feature extension #1134 StreamLogger is not properly flushed on shutdown (assignee: @AndreyAkinshin ) #1135 The default file logger and summary title are out of sync (assignee: @adamsitnik ) #1137 [Discussion] Improve search experience in the documentation #1144 Incorrect CPU info for .NET Core applications #1146 Only the first of multiple custom columns is included in the summary table (assignee: @AndreyAkinshin ) #1147 Update benchmark switcher instructions to work on Linux (assignee: @AndreyAkinshin ) #1149 Ambiguous hour component in log file name timestamp (assignee: @AndreyAkinshin ) #1152 Failed to test Roslyn. (assignee: @adamsitnik ) #1153 Use GC.GetTotalAllocatedBytes when available in MemoryDiagnoser (assignee: @adamsitnik ) #1154 Add a ConcurrencyDiagnoser? (assignee: @adamsitnik ) #1156 Crash when BenchmarkDotNet.Diagnostics.Windows.Session.GetFilePath throws NRE (assignee: @adamsitnik ) #1158 🔍 Improving search on docs with Algolia's DocSearch #1162 Incorrect value of BenchmarkDotNet.Toolchains.DotNetCli.NetCoreAppSettings.Default #1168 Consider using default value instead of hardcoded '-' in MetricColumn.GetValue() #1179 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers of EtwProfiler (assignee: @adamsitnik ) #1181 Log shows a wrong name for plot images #1182 Benchingmarking .NET 4.8 Causes Errors #1183 Plots of benchmarks without params have a double dash (--) in the name #1186 Add support for --runtimes net48 (assignee: @adamsitnik ) #1187 When user uses --packages $path, the $path should be sent to dotnet build command as well (assignee: @adamsitnik ) #1194 RunAll with ToolChains (assignee: @adamsitnik ) #1195 LatestCoreRtVersionIsSupported fails on Mac Os #1202 BenchmarkDotNet Not Recognizing CPU #1220 [Docs] RScript / R_HOME setup #1235 NativeMemoryProfiler exception (assignee: @WojciechNagorski ) #1236 Rework new API for target runtimes (assignee: @adamsitnik ) #1241 Can BenchmarkDotNet be enabled for LINQPad 6? (assignee: @adamsitnik ) #1269 Unable to show full param string in the report (assignee: @adamsitnik ) #1280 Improvement in memory statistics (assignee: @WojciechNagorski ) #1285 Issue with .Net Core version 3.0 #1289 How to config to not save .log files? #1291 MemoryDiagnoser reports weird results for .NET Core 3.0 Merged pull requests (56) #1044 Add \"dotnet new\" benchmark project template (by @CodeTherapist ) #1114 simplify the reported Full .NET Framework version, fixes 1111 (by @adamsitnik ) #1123 + InProcessNoEmitToolchain (obsoletes the InProcessToolchain) (by @ig-sinicyn ) #1129 Consume CoreRT from the new NuGet feed (by @MichalStrehovsky ) #1130 allow namespace filtering for InliningDiagnoser (#1106) (by @MarekM25 ) #1131 NativeMemoryDiagnoser (by @WojciechNagorski ) #1139 Power-Management extension (#1132) (by @MarekM25 ) #1145 Added workaround to fix incorrect CPU info when using wmic (by @YohDeadfall ) #1148 Improve search experience in the documentation (by @s-pace ) #1155 Use new .NET Core 3.0 API to get the total number of allocated bytes for all threads (by @adamsitnik ) #1161 Warn the user when benchmark baseline value is too close to zero and the columns derived from BaselineCustomColumn cannot be computed (by @mhmd-azeez ) #1163 Make netcoreapp2.1 default (by @adamsitnik ) #1169 Fix: broken link in readme.md (by @Ant-hem ) #1173 Updated index.md and fixed Relative performance url (by @sergey-litvinov ) #1175 Added information about what a Gen X column means (by @jigargandhi ) #1180 Update docstring for IterationSetup/IterationCleanup (by @billwert ) #1185 Invalid arg passing in StreamLogger constructor (by @ig-sinicyn ) #1188 Enforce the users to provide full target framework moniker when using attributes to define multiple runtime jobs (by @adamsitnik ) #1189 Update HtmlExporter.cs (by @chuuddo ) #1196 Update Mac Os for Travis CI (by @WojciechNagorski ) #1199 Rename OutlierMode values (by @AndreyAkinshin ) #1201 print benchmark process id to the output (better profiler user story) (by @adamsitnik ) #1203 Easier introduction of new benchmarks (by @Scooletz ) #1204 Fix casing typo (by @antondahlin ) #1206 add *.fsproj to the list of supported project types (by @JaggerJo ) #1208 Support of --profiler NativeMemory command line argument (by @WojciechNagorski ) #1209 Sorting examples list and adding missing pages (by @WojciechNagorski ) #1212 Plots with a double dash (--) in the names (#1183) (by @marcnet80 ) #1213 print full architecture name (by @adamsitnik ) #1214 Add documentation to NativeMemoryDiagnoser (by @WojciechNagorski ) #1217 Log shows a wrong name for plot images #1181 (by @marcnet80 ) #1218 NativeMemoryProfiler -add count of allocated object (by @WojciechNagorski ) #1219 Add links to blogs. (by @WojciechNagorski ) #1222 Enhance rscript location (by @tebeco ) #1225 Documentation: Fix some typos in the documentation (by @MSeifert04 ) #1227 Threading Diagnoser (by @adamsitnik ) #1228 Support IEnumerable as benchmark argument (by @adamsitnik ) #1230 further runtime detection improvements (by @adamsitnik ) #1231 Fix iteration cleanup bug (by @adamsitnik ) #1232 Fixed dots at the end (not used in other places) (by @cincuranet ) #1233 try to read .NET Core version from all available information (by @adamsitnik ) #1237 The null ArtifactsPath value causes exception for all EtwProfiler (by @WojciechNagorski ) #1239 Add using statement to sample snippet (by @b8adamson ) #1240 Amend SummaryStyle to support visualization of '0' in reports (by @sleemer ) #1245 LINQPad 6 support using InProcessEmitToolchain (by @adamsitnik ) #1252 Add possibility to disable the log file (by @CodeTherapist ) #1255 Update Build Tools to use .NET Core SDK to 3.0.100 (by @CodeTherapist ) #1257 Task remove unused nuget packages (by @WojciechNagorski ) #1259 Task remove trailing whitespace (by @WojciechNagorski ) #1260 Fix ca1825 rule - Avoid zero-length array allocations (by @WojciechNagorski ) #1261 Fix CA2000 - Add missing using (by @WojciechNagorski ) #1265 make it possible to configure MaxParamterColumnWidth (by @adamsitnik ) #1268 Fix compilation error with post v3.3.1 Roslyn (by @stanciuadrian ) #1277 change the runtimes API (by @adamsitnik ) #1279 Improve documentation for version 0.12.0 (by @WojciechNagorski ) #1281 Print GC and threading stats only if needed (by @WojciechNagorski ) Commits (110) 881c6d Postrelease update of v0.11.5 changelog (by @AndreyAkinshin ) a2bddf Fix release date for v0.11.5 in changelog (by @AndreyAkinshin ) c0c91a Consume CoreRT from the new NuGet feed (#1129) (by @MichalStrehovsky ) 40dcab allow namespace filtering for InliningDiagnoser (#1106) (#1130), fixes #1106 (by @MarekM25 ) 12fdbe + InProcessNoEmitToolchain (#1123) (by @ig-sinicyn ) 62d6af Bump docfx version to 2.42.1 (by @AndreyAkinshin ) 40901c Add sitemap generation in docfx.json (see #1137) (by @AndreyAkinshin ) 04ec20 add Guid support to code templates (by @adamsitnik ) 4e9eb4 Better precision calculation in SummaryTable (by @AndreyAkinshin ) df6f91 Added workaround to fix incorrect CPU info when using wmic (#1145) (by @YohDeadfall ) 9065c7 Make ids for tag columns unique, fixes #1146 (by @AndreyAkinshin ) 527c95 Improve AskUser prompt message, fixes #1147 (by @AndreyAkinshin ) 45253c Flush custom loggers at the end of benchmark session, fix #1134 (by @AndreyAkinshin ) 21175b Make log file datetime format 24-hour, fix #1149 (by @AndreyAkinshin ) 0dfa37 Power-Management extension (#1132) (#1139) (by @MarekM25 ) f54055 Use new .NET Core 3.0 API to get the total number of allocated bytes for all ... (by @adamsitnik ) aa17ec improve the output path of .etl files produced by EtwProfiler, fixes #1156, f... (by @adamsitnik ) ec296d make ArgumentsSource support IEnumerable<object[]> for benchmarks accepting a... (by @adamsitnik ) 96f162 write \"Setup power plan\" in a separate line (by @adamsitnik ) 063d1a copy PreserveCompilationContext MSBuild setting from the project that defines... (by @adamsitnik ) 1578c5 make it possible to not enforce power plan, move the revert to finally, simpl... (by @adamsitnik ) 0513a7 remove the test that requires a manual update every time we add a new charact... (by @adamsitnik ) 6e6559 extend Summary with LogFilePath, fixes #1135 (by @adamsitnik ) 6d7130 make FullNameProvider public so it can be reused by the dotnet/performance re... (by @adamsitnik ) 6f91ea Drop netcoreapp2.0 TFM in sample and test projects (see #1141) (by @AndreyAkinshin ) bfe676 Warn the user when benchmark baseline value is too close to zero and the colu... (by @mhmd-azeez ) 4282b1 Update year in LICENSE.md (by @AndreyAkinshin ) 29d01b Improve search experience in the documentation (#1148) (by Sylvain Pace) ddf1b8 Fixed: broken link in readme.md (by @Ant-hem ) fc35f7 simplify the reported Full .NET Framework version, fixes 1111 (#1114) (by @adamsitnik ) 0a4550 Updated index.md and fixed Relative performance (#1173) (by @sergey-litvinov ) a106b1 Add System.Buffers.ArrayPoolEventSource to the list of default .NET Providers... (by @adamsitnik ) c022e7 Update docstring for IterationSetup/IteraitonCleanup (by @billwert ) 31cb34 Invalid arg passing in StreamLogger constructor (#1185) (by @ig-sinicyn ) fc8867 Make netcoreapp2.1 default (#1163) (by @adamsitnik ) 0f210c Add support for --runtimes net48, fixes #1186 (by @adamsitnik ) 48a9de When user uses --packages $path, the $path should be sent to dotnet build com... (by @adamsitnik ) dfa074 Update HtmlExporter.cs (#1189) (by @chuuddo ) 8b018d doc update: InProc toolchain supports Arguments now, we use Median instead of... (by @adamsitnik ) ae23bd add the possibility to pass config to BenchmarkSwitcher.RunAll and RunAllJoin... (by @adamsitnik ) 94b788 Update Mac Os for Travis CI (#1196), fixes #1195 (by @WojciechNagorski ) 58fde6 Use Sheather&Jones bandwidth selector for density plots in RPlotExporter (by @AndreyAkinshin ) 0e4b8e Rename OutlierMode values (#1199) (by @AndreyAkinshin ) 863c65 Added information about what a Gen X column means (#1175) (by @jigargandhi ) 70c5b3 print benchmark process id to the output (better profiler user story) (#1201) (by @adamsitnik ) 55cba0 Easier introduction of new benchmarks (#1203) (by @Scooletz ) 31bb6f Fix casing typo (#1204) (by @antondahlin ) e92abf NativeMemoryDiagnoser (#1131), fixes #457 (by @WojciechNagorski ) d04a01 update list of supported project types (#1206) (by @JaggerJo ) 5db67b Sorting examples list and add missing pagges (#1209) (by @WojciechNagorski ) 6620cd print full architecture name (#1213) (by @adamsitnik ) 705bc3 Add documentation to NativeMemoryDiagnouser (#1214) (by @WojciechNagorski ) 9caa05 Support of --profiler NativeMemory command line argument (#1208) (by @WojciechNagorski ) 5d7c78 Plots with a double dash (--) in the names (#1183) (#1212) (by @marcnet80 ) d0d883 Extend NativeMemoryProfiler with the number of allocated objects (#1218) (by @WojciechNagorski ) 09aba3 Add links to blogs. (#1219) (by @WojciechNagorski ) a200af Enforce the users to provide full target framework moniker when using attribu... (by @adamsitnik ) f8ef67 add release notes for 0.11.6 (by @adamsitnik ) 88ea5a Documentation: Fix some typos in the documentation (#1225) (by @MSeifert04 ) ea0468 Support IEnumerable as benchmark argument (#1228) (by @adamsitnik ) 4080ab Threading Diagnoser (#1227) (by @adamsitnik ) b6d0e0 further runtime detection improvements (#1230), (by @adamsitnik ) bc9624 Fix iteration cleanup bug (#1231) (by @adamsitnik ) cfccac Fixed dots at the end (not used in other places) (#1232) (by @cincuranet ) 61feb7 try to read .NET Core version from all available information (#1233) (by @adamsitnik ) c06ab7 Add using statement to sample snippet (#1239) (by @b8adamson ) af9608 The null ArtifactsPath value causes exception for all EtwProfiler (#1237) (by @WojciechNagorski ) 5f337d chore(tests): extract helper methods to MockFactory (by @sleemer ) 03e9ce feat(CsvExproter): print '0' instead of '-' in the CSV report (by @sleemer ) 06f0e7 Improuve link visibility for R installation (by @tebeco ) a2d9e3 adding example of R_HOME value in the doc to understand it construction (by @tebeco ) ce5ac8 Enhanced RScript detection, with a Fallback to the PATH if R_HOME points to a... (by @tebeco ) b86845 not necessary to set rscriptPath to null since it's re-affected right after (by @tebeco ) ee97ca Change access modifier to private, was not intended to be public (by @tebeco ) 609eec Log shows a wrong name for plot images #1181 (by @marcnet80 ) 76096e Add \"dotnet new\" benchmark project template (#1044) (by @CodeTherapist ) b7cbdf Update year in license (docs) (by @AndreyAkinshin ) 29919d Remove extra spaces in template *proj files (by @AndreyAkinshin ) 80ccfd Add some readonly modifiers (by @AndreyAkinshin ) d6a697 Improve MannWhitneyTest precision for small samples (by @AndreyAkinshin ) 9ba645 Fix CurrentRuntimeIsProperlyRecognized for NETFRAMEWORK case on Linux/macOS (by @AndreyAkinshin ) 24fda9 LINQPad 6 support using InProcessEmitToolchain (#1245) (by @adamsitnik ) e01e0d Fix typos in attribute messages (by @AndreyAkinshin ) 56a71f Add possibility to disable the log file (#1252) (by @CodeTherapist ) 3c4ec9 remove unused nuget packages (#1257) (by @WojciechNagorski ) 61cc56 Add missing using (#1261) (by @WojciechNagorski ) cd88ed Fix ca1825 rule - Avoid zero-length array allocations (#1260) (by @WojciechNagorski ) 2ba303 Task remove trailing whitespace (#1259) (by @WojciechNagorski ) e1c4aa Fix compilation error with post v3.3.1 Roslyn (#1268) (by @stanciuadrian ) 4ec888 make it possible to configure MaxParamterColumnWidth (#1265), fixes #1269 (by @adamsitnik ) 51f53a CombinedDisassemblyExporter output should be aligned to left, not right (by @adamsitnik ) f89091 Add EdPeltChangePointDetector (by @AndreyAkinshin ) da63e8 change the runtimes API (#1277) (by @adamsitnik ) 5333d5 Change next version number from 0.11.6 to 0.12.0 (by @AndreyAkinshin ) 52cc45 NativeMemoryProfiler instead of NativeMemoryDiagnoser (#1279) (by @WojciechNagorski ) f86e13 Print GC and threading stats if needed (#1281) (by @WojciechNagorski ) a08062 Rename some obsolete TargetFrameworkMoniker names to RuntimeMoniker (by @AndreyAkinshin ) 7fdee8 Fix JitOptimizationsValidatorIsMandatoryByDefault in DEBUG mode (by @AndreyAkinshin ) f2639e Move ImmutableConfigTests from IntegrationTests to regular unit tests (by @AndreyAkinshin ) 4f6a6b Fix diagnoser tests in ImmutableConfigTests (by @AndreyAkinshin ) 0768b7 Fix some typos in identifiers (by @AndreyAkinshin ) 28bb7c Bump DocFX version from 2.42.1 to 2.46 (by @AndreyAkinshin ) af9ff5 Fix mistakes in old changelogs (by @AndreyAkinshin ) c5aa4f Prepare v0.12.0 changelog (by @AndreyAkinshin ) cb1575 Add BenchmarkDotNet.Templates in build-and-pack.cmd (by @AndreyAkinshin ) bc7cb8 Improve v0.12.0 release notes (by @AndreyAkinshin ) c5ac2f Fix bug in BaselineCustomAnalyzer (by @AndreyAkinshin ) d75b1b Add .NET Core 2.2 and .NET Core 3.0 support in BenchmarkDotNet.Tool (by @AndreyAkinshin ) d582b5 Revert previous commit because of the CI Error (by @AndreyAkinshin ) 7bdf6e Set library version: 0.12.0 (by @AndreyAkinshin ) Contributors (24) Adam Sitnik ( @adamsitnik ) Adrian Stanciu ( @stanciuadrian ) Andrey Akinshin ( @AndreyAkinshin ) Antoine Hémery ( @Ant-hem ) Anton Dahlin ( @antondahlin ) b8adamson ( @b8adamson ) Bill Wert ( @billwert ) Code Therapist ( @CodeTherapist ) ig-sinicyn ( @ig-sinicyn ) Ilya Chudin ( @chuuddo ) Jigar ( @jigargandhi ) Jiri Cincura ↹ ( @cincuranet ) Josua Jäger ( @JaggerJo ) marcnet80 ( @marcnet80 ) Marek Moraczyński ( @MarekM25 ) Michael Seifert ( @MSeifert04 ) Michal Strehovský ( @MichalStrehovsky ) Muhammad Azeez ( @mhmd-azeez ) Sergey Litvinov ( @sergey-litvinov ) Szymon Kulec ( @Scooletz ) TeBeCo ( @tebeco ) Vlad Kovalev ( @sleemer ) Wojciech Nagórski ( @WojciechNagorski ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: October 24, 2019 Milestone: v0.12.0 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.0"
  },
  "changelog/v0.12.1.html": {
    "href": "changelog/v0.12.1.html",
    "title": "BenchmarkDotNet v0.12.1 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.12.1 Highlights .NET 5 support As you probably know, .NET Core 5 was officially rebranded to .NET 5. The new version of BenchmarkDotNet supports the new runtime after rebranding. #1399 465ebf Perfolizer adoption The internal statistical engine of BenchmarkDotNet became mature enough to be transformed into an independent project. Meet perfolizer — a toolkit for performance analysis! While BenchmarkDotNet focuses on obtaining reliable measurements, perfolizer focuses on the decent analysis of measured data. You still can use all the statistical algorithms from BenchmarkDotNet, but you can also install perfolizer as a standalone NuGet package . You can find more details in the official announcement . #1386 54a061 Cross-platform disassembler Now the DisassemblyDiagnoser is cross-platform! The disassembling logic was also improved, now it handles runtime helper methods and references to method tables properly. Internally, it uses the Iced library for formatting assembly code. Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! #1332 #899 #1316 #1364 294320 EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! Just mark your class with the [EventPipeProfiler(...)] attribute and get a .speedscope.json file that you can browse in SpeedScope . Special thanks to @WojciechNagorski for the implementation! #1321 #1315 c648ff New fluent API We continue to improve our API and make it easier for reading and writing. Special thanks to @WojciechNagorski for the implementation! #1273 #1234 640d88 Ref readonly support Now you can use ref readonly in benchmark signatures. Special thanks to @adamsitnik for the implementation! #1389 #1388 9ac777 Cross-platform disassembler Just mark your benchmark class with the [DisassemblyDiagnoser] attribute and you will get the disassembly listings for all the benchmarks. The formatting looks pretty nice thanks to Iced . It works like a charm on Windows, Linux, and macOS. [DisassemblyDiagnoser] public class IntroDisassembly { private int[] field = Enumerable.Range(0, 100).ToArray(); [Benchmark] public int SumLocal() { var local = field; // we use local variable that points to the field int sum = 0; for (int i = 0; i < local.Length; i++) sum += local[i]; return sum; } [Benchmark] public int SumField() { int sum = 0; for (int i = 0; i < field.Length; i++) sum += field[i]; return sum; } } .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumLocal() mov rax,[rcx+8] xor edx,edx xor ecx,ecx mov r8d,[rax+8] test r8d,r8d jle short M00_L01 M00_L00: movsxd r9,ecx add edx,[rax+r9*4+10] inc ecx cmp r8d,ecx jg short M00_L00 M00_L01: mov eax,edx ret ; Total bytes of code 35 .NET Core 2.1.16 (CoreCLR 4.6.28516.03, CoreFX 4.6.28516.10), X64 RyuJIT ; BenchmarkDotNet.Samples.IntroDisassembly.SumField() sub rsp,28 xor eax,eax xor edx,edx mov rcx,[rcx+8] cmp dword ptr [rcx+8],0 jle short M00_L01 M00_L00: mov r8,rcx cmp edx,[r8+8] jae short M00_L02 movsxd r9,edx add eax,[r8+r9*4+10] inc edx cmp [rcx+8],edx jg short M00_L00 M00_L01: add rsp,28 ret M00_L02: call CORINFO_HELP_RNGCHKFAIL int 3 ; Total bytes of code 53 Now we handle runtime helper methods and references to method tables properly. Example: Before: ; MicroBenchmarks.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20h mov rsi,rcx cmp edx,7FFFFFFFh jne M00_L00 call MicroBenchmarks.WithCallsAfter.Static() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Instance() mov rcx,rsi call MicroBenchmarks.WithCallsAfter.Recursive() mov rcx,rsi mov rax,qword ptr [rsi] mov rax,qword ptr [rax+40h] call qword ptr [rax+20h] mov rcx,rsi mov edx,1 mov rax,7FF8F4217050h add rsp,20h pop rsi jmp rax M00_L00: mov rcx,offset System_Private_CoreLib+0xa31d48 call coreclr!MetaDataGetDispenser+0x322a0 mov rsi,rax mov ecx,0ACFAh mov rdx,7FF8F42F4680h call coreclr!MetaDataGetDispenser+0x17140 mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call coreclr!coreclr_shutdown_2+0x39f0 int 3 add byte ptr [rax],al sbb dword ptr [00007ff9`26284e30],eax add dword ptr [rax+40h],esp add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax],al add byte ptr [rax-70BC4CCh],ah ; Total bytes of code 157 After: ; BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Int32) push rsi sub rsp,20 mov rsi,rcx cmp edx,7FFFFFFF jne M00_L00 call BenchmarkDotNet.Samples.WithCallsAfter.Static() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Instance() mov rcx,rsi call BenchmarkDotNet.Samples.WithCallsAfter.Recursive() mov rcx,rsi mov rax,[rsi] mov rax,[rax+40] call qword ptr [rax+20] mov rcx,rsi mov edx,1 mov rax BenchmarkDotNet.Samples.WithCallsAfter.Benchmark(Boolean) add rsp,20 pop rsi jmp rax M00_L00: mov rcx MT_System.InvalidOperationException call CORINFO_HELP_NEWSFAST mov rsi,rax mov ecx,12D mov rdx,7FF954FF83F0 call CORINFO_HELP_STRCNS mov rdx,rax mov rcx,rsi call System.InvalidOperationException..ctor(System.String) mov rcx,rsi call CORINFO_HELP_THROW int 3 ; Total bytes of code 134 See also: Cross-runtime .NET disassembly with BenchmarkDotNet . Special thanks to @adamsitnik for the implementation and @0xd4d for Iced! EventPipe-based cross-platform profiler Now you can easily profiler your benchmarks on Windows, Linux, and macOS! If you want to use the new profiler, you should just mark your benchmark class with the [EventPipeProfiler(...)] attribute: [EventPipeProfiler(EventPipeProfile.CpuSampling)] // <-- Enables new profiler public class IntroEventPipeProfiler { [Benchmark] public void Sleep() => Thread.Sleep(2000); } Once the benchmark run is finished, you get a .speedscope.json file that can be opened in SpeedScope : The new profiler supports several modes: CpuSampling - Useful for tracking CPU usage and general .NET runtime information. This is the default option. GcVerbose - Tracks GC collections and samples object allocations. GcCollect - Tracks GC collections only at very low overhead. Jit - Logging when Just in time (JIT) compilation occurs. Logging of the internal workings of the Just In Time compiler. This is fairly verbose. It details decisions about interesting optimization (like inlining and tail call) Please see Wojciech Nagórski's blog post for all the details. Special thanks to @WojciechNagorski for the implementation! New fluent API We continue to improve our API and make it easier for reading and writing. The old API is still existing, but it is marked as obsolete and will be removed in the further library versions. The most significant changes: Changes in Job configuration Changes in IConfig/ManualConfig Full fluent API Special thanks to @WojciechNagorski for the implementation! Ref readonly support Now you can use ref readonly in benchmark signatures. Here is an example: public class RefReadonlyBenchmark { static readonly int[] array = { 1 }; [Benchmark] public ref readonly int RefReadonly() => ref RefReadonlyMethod(); static ref readonly int RefReadonlyMethod() => ref array[0]; } Special thanks to @adamsitnik for the implementation! Milestone details In the v0.12.1 scope, 31 issues were resolved and 42 pull requests were merged. This release includes 85 commits by 19 contributors. Resolved issues (31) #641 RPlotExporter hanging (assignee: @m-mccormick ) #899 Tiered compilation and disassembler (assignee: @adamsitnik ) #1023 Out of process benchmarks fail with ASP.NET Core SDK reference #1211 Binding Redirect Issues When Using Xml Serializers #1234 Strong type fluent API proposal (assignee: @WojciechNagorski ) #1238 RunAllJoined Causing Exception (assignee: @gsomix ) #1262 Params attribute doesn`t work in F# if you specify more than one enum value in constructor (assignee: @gsomix ) #1295 Custom format/culture for report output values (for CSV, and maybe HTML, MD) #1305 Copy UserSecrets from benchmark project #1311 Spelling nit (assignee: @AndreyAkinshin ) #1312 Add an option to pass environment variables to the default job #1315 Implement cross platform EventPipeProfiler diagnoser (assignee: @WojciechNagorski ) #1316 Implement Unix Disassembler for .NET Core (assignee: @adamsitnik ) #1318 use of NugetReference[] causes System.MissingMethodException: No parameterless constructor defined for this object. (assignee: @adamsitnik ) #1323 DisassemblyDiagnoser index outside array bounds (assignee: @AndreyAkinshin ) #1325 Surface native code size benchmarked code (assignee: @adamsitnik ) #1326 BDN does not build using dotnet sdk from the command line in Linux #1339 Generated code and StyleCop.Analyzers (assignee: @adamsitnik ) #1348 Different display text for arrays depending on a value source (assignee: @YohDeadfall ) #1350 Warn the user if command line arguments were not passed to the BenchmarkSwitcher #1353 Show Length when param type is an array #1361 SimpleJobAttribute with RunStrategy and RuntimeMoniker #1363 Wrong assembly binding redirects for Microsoft.Data.SqlClient.resources ; using in Netcore3.0 project (assignee: @adamsitnik ) #1364 Bug: Benchmark class with Console.WriteLine(1) fails for DisassemblyDiagnoser with 'Sequence contains no matching element' (assignee: @adamsitnik ) #1369 Parameter column doesn't seem to respect culture info (assignee: @Tyrrrz ) #1379 Unix CI builds are red (assignee: @AndreyAkinshin ) #1385 Make BaselineCustomColumn.GetValue public #1388 'ref readonly' return is not supported (assignee: @adamsitnik ) #1396 MacOS Azure Pipeline build is broken (assignee: @AndreyAkinshin ) #1413 Plot with only one \"default\" Job (assignee: @AndreyAkinshin ) #1416 EventPipeProfiler Documentation (assignee: @WojciechNagorski ) Merged pull requests (42) #1258 Task add style cope and fxcop analyzers (by @WojciechNagorski ) #1263 Configuration compatibility validation (by @gsomix ) #1266 Add EnumParam preserving type information (by @gsomix ) #1273 New fluent API (by @WojciechNagorski ) #1287 EdPeltChangePointDetector improvements (by @jeanbern ) #1300 Update link of \" official benchmarking guide\" to use the new recommended link (by @eriawan ) #1301 Improve BenchmarkDotNet.Templates (by @AndreyAkinshin ) #1302 CultureInfo Refactoring (by @AndreyAkinshin ) #1307 Fix project file order (by @vilinski ) #1309 Copy UserSecrets from benchmark project (by @kant2002 ) #1313 add possibility to specify env vars via console line arguments (by @adamsitnik ) #1321 The EventPipeProfiler cross-platform profiler (by @WojciechNagorski ) #1327 Add package-refs to reference assemblies for linux build (by @damageboy ) #1329 Show information about docker (by @WojciechNagorski ) #1331 Use 24-hour time in joined summary file name (by @jroessel ) #1332 Improved and Cross platform disassembler (by @adamsitnik ) #1335 Attribute improvements (by @WojciechNagorski ) #1340 Improvement of csproj finding (by @WojciechNagorski ) #1349 Fixed display text for array parameters and arguments (by @YohDeadfall ) #1357 add the header at the top of the generated file to avoid static analysis tools from analyzing it, (by @adamsitnik ) #1359 Warn if command line arguments were not passed to the BenchmarkSwitcher (by @suslovk ) #1365 Use DirtyAssemblyResolveHelper only for Full .NET Framework (by @adamsitnik ) #1366 add missing SimpleJobAttribute ctor (by @adamsitnik ) #1367 Await non-generic ValueTask returning method (by @mayuki ) #1372 Use CultureInfo when formatting parameter values (by @Tyrrrz ) #1373 fixes #641 (by @m-mccormick ) #1375 don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once again just to gather JIT info, the overhead is very small (by @adamsitnik ) #1376 update TraceEvent to 2.0.49 to get TailCalls working again (by @adamsitnik ) #1380 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (by @AndreyAkinshin ) #1381 Minor event pipe profiler improvements (by @adamsitnik ) #1384 Fix build after styleCop (by @WojciechNagorski ) #1386 Switch to perfolizer (by @AndreyAkinshin ) #1387 Make BaselineCustomColumn expose \"GetValue\" as a public API (by @damageboy ) #1389 Ref readonly support (by @adamsitnik ) #1394 Align homepage example with README (by @dahlbyk ) #1397 Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (by @AndreyAkinshin ) #1399 React to .NET 5 branding changes (by @jkotas ) #1407 Improve warnings for small operations number (by @CodeFuller ) #1410 Updating Document - Fixing a small grammar mistake (by @abhinavgalodha ) #1417 Fix --profiler option description. (by @WojciechNagorski ) #1418 EventPipeProfiler documentation (by @WojciechNagorski ) #1419 Small fix in EventPipeProfiler documentation (by @WojciechNagorski ) Commits (85) 396d4b #1262: Add EnumParam preserving type information (by @gsomix ) 718b77 #1262: Add tests (by @gsomix ) 33ec90 EdPeltChangePointDetector improvements (by @jeanbern ) 7e3efc Postrelease update of v0.12.0 changelog (by @AndreyAkinshin ) 8677b0 Update css in documentation (by @AndreyAkinshin ) 919b7f Fix link to IntroThreadingDiagnoser in diagnoser.md (by @AndreyAkinshin ) 4d15ea Update README.md (by @AndreyAkinshin ) f2d081 Update link of \" official benchmarking guide\" to use the new recommended link... (by @eriawan ) 05df0e Documentation: update article about command-line tool (by @AndreyAkinshin ) d69505 Improve BenchmarkDotNet.Templates (#1301) (by @AndreyAkinshin ) e23755 Speed up some integration tests (by @AndreyAkinshin ) 3d96bf Update NuGet package descriptions (by @AndreyAkinshin ) 351dae Update README.md (by @AndreyAkinshin ) 5f07f4 Add Windows 10 brand string for 19H1 (by @AndreyAkinshin ) fd92ff Update README.md (by @AndreyAkinshin ) 5af5c5 Update README.md (by @AndreyAkinshin ) 1b923f Fix project file order (#1307) (by @vilinski ) 57b01f Copy UserSecrets from benchmark project (#1309) (by @kant2002 ) 2415fd Fix some typos, fix #1311 (by @AndreyAkinshin ) e92d6d add possibility to specify env vars via console line arguments (#1313) (by @adamsitnik ) b7054c WithNuGet should accept NuGetReferenceList, not IReadOnlyCollection<NuGetRefe... (by @adamsitnik ) bb437b Remove curly braces for single statements (by @AndreyAkinshin ) 76c675 Improve code readability (by @AndreyAkinshin ) 8486e1 Merge pull request #1287 from jeanbern/patch-1 (by @AndreyAkinshin ) d6bf40 Update README.md (by @AndreyAkinshin ) 728c40 Support empty lines in disassembler/GetSmartPrefix, fix #1323 (by @AndreyAkinshin ) 0c48c2 CultureInfo Refactoring (#1302) (by @AndreyAkinshin ) 099550 Switch to using ms ref aseemblies for build (#1327) (by @damageboy ) 55842b Merge pull request #1266 from gsomix/feature/1262-fsharp-enums (by @AndreyAkinshin ) 35d358 Show information about docker (#1329) (by @WojciechNagorski ) b6283c Use 24-hour time in joined summary file name (#1331) (by @jroessel ) 640d88 New fluent API (#1273), fixes #1234 (by @WojciechNagorski ) a3f76b Update README (by @AndreyAkinshin ) 4a9697 Update copyright year (by @AndreyAkinshin ) 5e7f01 add the header at the top of the generated file to avoid s... (by @adamsitnik ) 07b512 Await non-generic ValueTask returning method (#1367) (by @mayuki ) 479177 Display array length for array parameters and arguments (#1349), fixes #1348 ... (by @YohDeadfall ) 3b8d2c Warn if command line arguments were not passed to the BenchmarkSwitcher (#135... (by @suslovk ) 87d85a Use CultureInfo when formatting parameter values (#1372) (by @Tyrrrz ) 310b5a add missing SimpleJobAttribute ctor, fixes #1361 (#1366) (by @adamsitnik ) 6a1458 change the way RPlotExporter reads the R script output, fixes #641 (#1373) (by @m-mccormick ) ff4c3d Attribute improvements (#1335) (by @WojciechNagorski ) 29eafb Improvement of csproj finding (#1340) (by @WojciechNagorski ) be2168 Use DirtyAssemblyResolveHelper only for Full .NET Framework (#1365) (by @adamsitnik ) 664ab6 update TraceEvent to 2.0.49 to get TailCalls working again (#1376) (by @adamsitnik ) b788bc don't require the JitDiagnosers (TailCall & Inlining) to run benchmarks once ... (by @adamsitnik ) 8ad2a9 Bump Cake version from 0.30.0 to 0.37.0, fix #1379 (#1380) (by @AndreyAkinshin ) 474047 Task add style cope and fxcop analyzers (#1258) (by @WojciechNagorski ) c648ff The EventPipeProfiler cross-platform profiler (#1321) (by @WojciechNagorski ) 19169a Add brand strings for latest Windows versions (by @AndreyAkinshin ) 532f84 Update README (by @AndreyAkinshin ) 3defd7 Minor event pipe profiler improvements (#1381) (by @adamsitnik ) 294320 Improved and Cross platform disassembler (#1332) (by @adamsitnik ) 1d63d6 Fix build after styleCop (#1384) (by @WojciechNagorski ) b3ba08 Make BaselineCustomColumn expose \"GetValue\" as a public API (#1387) (by @damageboy ) 54a061 Switch to perfolizer (by @AndreyAkinshin ) 9ac777 Ref readonly support (#1389) (by @adamsitnik ) c3286f Update CodeAnnotations.cs (by @AndreyAkinshin ) 3223c9 Code cleanup (by @AndreyAkinshin ) c19e54 Implement configurations compatibility validation (#1263), Closes #1238 (by @gsomix ) df434e Align homepage example with README (#1394) (by @dahlbyk ) 9a251a Bump macOS Azure Pipeline vmImage to 10.14, fix #1396 (#1397) (by @AndreyAkinshin ) 465ebf React to .NET 5 branding changes (#1399) (by @jkotas ) 6cca72 Updating a small grammar mistake (#1410) (by @abhinavgalodha ) 27b32e Improve warnings for small operations number (#1407) (by @CodeFuller ) 2d365b Fix --profiler option description. (#1417) (by @WojciechNagorski ) 7902cd Add macOS Catalina support in OsBrandStringHelper (by @AndreyAkinshin ) fd4c32 Update README (by @AndreyAkinshin ) 6e13ba Resolving JobId in DefaultCharacteristicPresenter, fix #1413 (by @AndreyAkinshin ) 35ebd2 Better job id generation in SimpleJobAttribute (by @AndreyAkinshin ) bf4778 Use ASCII mode for Measurement presentation in terminal (by @AndreyAkinshin ) f6b81f Display result path in RPlotExporter (by @AndreyAkinshin ) 30b269 Disable plot printing in BuildPlots.R (by @AndreyAkinshin ) 27887d Disable Rplots.pdf generation in BuildPlots.R (by @AndreyAkinshin ) 338e40 Specify uid for how-to-run.md (by @AndreyAkinshin ) f6dcd3 Add BenchmarkDotNet.Annotations in API documentation (by @AndreyAkinshin ) b503fd Bump DocFX version from 2.46 to 2.51 (by @AndreyAkinshin ) f457e7 Prepare v0.12.1 changelog (by @AndreyAkinshin ) 53d090 Fix documentation.md (by @AndreyAkinshin ) e72897 Add v0.12.1 highlights (by @AndreyAkinshin ) 2de040 Bump perfolizer version from 0.2.0 to 0.2.1 (by @AndreyAkinshin ) 76a070 EventPipeProfiler documentation (#1418) (by @WojciechNagorski ) 928fb1 EventPipeProfiler doc improvements (#1419) (by @WojciechNagorski ) 12798e Update documentation (by @AndreyAkinshin ) 384d47 Set library version: 0.12.1 (by @AndreyAkinshin ) Contributors (19) Abhinav Galodha ( @abhinavgalodha ) Adam Sitnik ( @adamsitnik ) Alexey Golub ( @Tyrrrz ) Andreas Vilinski ( @vilinski ) Andrey Akinshin ( @AndreyAkinshin ) Andrii Kurdiumov ( @kant2002 ) CodeFuller ( @CodeFuller ) damageboy ( @damageboy ) Eriawan Kusumawardhono ( @eriawan ) Evgeniy Andreev ( @gsomix ) Jan Kotas ( @jkotas ) Jean-Bernard Pellerin ( @jeanbern ) Johannes Rössel [yWorks] ( @jroessel ) Keith Dahlby ( @dahlbyk ) Konstantin ( @suslovk ) Matt McCormick ( @m-mccormick ) Mayuki Sawatari ( @mayuki ) Wojciech Nagórski ( @WojciechNagorski ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: April 6, 2020 Milestone: v0.12.1 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Tool/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.12.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.12.1"
  },
  "changelog/v0.13.0.html": {
    "href": "changelog/v0.13.0.html",
    "title": "BenchmarkDotNet v0.13.0 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.13.0 It's been a year since our last release. BenchmarkDotNet has been downloaded more than seven million times from nuget.org . It's more than we could have ever possibly imagined! Some could say, that it's also more than we can handle ;) That is why we wanted to once again thank all the contributors who helped us with 0.13.0 release! Highlights In BenchmarkDotNet v0.13.0, we have supported various technologies: .NET 5 and .NET 6 target framework monikers .NET SDK installed via snap SingleFile deployment Xamarin applications WASM applications Mono AOT We have also introduced new features and improvements including: Memory randomization Method-specific job attributes Sortable parameter columns Customizable ratio column Improved CoreRun and CoreRT support Improved Hardware Counters support Of course, this release includes dozens of other improvements and bug fixes! Supported technologies .NET 5, .NET 6, SingleFile and snap At some point in time, netcoreapp5.0 moniker was changed to net5.0 , which required a fix on our side ( #1479 , btw we love this kind of changes). Moreover, .NET 5 introduced platform-specific TMFs (example: net5.0-windows10.0.19041.0 ) which also required some extra work: #1560 , #1691 . In #1523 support for .NET 6 was added. <TargetFrameworks>net5.0;net5.0-windows10.0.19041.0;net6.0<TargetFrameworks> In #1686 @am11 has implemented support for single file deployment (supported in .NET 5 onwards). Last, but not least in #1652 snap support has been implemented. adam@adsitnik-ubuntu:~/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples$ dotnet50 run -c Release -f net5.0 --filter BenchmarkDotNet.Samples.IntroColdStart.Foo // Validating benchmarks: // ***** BenchmarkRunner: Start ***** // ***** Found 1 benchmark(s) in total ***** // ***** Building 1 exe(s) in Parallel: Start ***** // start /snap/dotnet-sdk/112/dotnet restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 1.49s and exited with 0 // start /snap/dotnet-sdk/112/dotnet build -c Release --no-restore /p:UseSharedCompilation=false /p:BuildInParallel=false /m:1 /p:Deterministic=true /p:Optimize=true in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b // command took 2.78s and exited with 0 // ***** Done, took 00:00:04 (4.37 sec) ***** // Found 1 benchmarks: // IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // ************************** // Benchmark: IntroColdStart.Foo: Job-NECTOD(IterationCount=5, RunStrategy=ColdStart) // *** Execute *** // Launch: 1 / 1 // Execute: /snap/dotnet-sdk/112/dotnet \"9a018ee4-0f33-46dd-9093-01d3bf31233b.dll\" --benchmarkName \"BenchmarkDotNet.Samples.IntroColdStart.Foo\" --job \"IterationCount=5, RunStrategy=ColdStart\" --benchmarkId 0 in /home/adam/projects/BenchmarkDotNet/samples/BenchmarkDotNet.Samples/bin/Release/net5.0/9a018ee4-0f33-46dd-9093-01d3bf31233b/bin/Release/net5.0 Xamarin support Thanks to the contributions of the amazing @jonathanpeppers BenchmarkDotNet supports Xamarin! The examples can be found in our repo: iOS , Android . #1360 , #1429 , #1434 , #1509 WASM support Thanks to the work of @naricc you can now benchmark WASM using Mono Runtime! For more details, please refer to our docs . #1483 , #1498 , #1500 , #1501 , #1507 , #1592 , #1689 . Mono AOT support In another awesome contribution ( #1662 ) @naricc has implemented Mono AOT support. The new toolchain supports doing Mono AOT runs with both the Mono-Mini compiler and the Mono-LLVM compiler (which uses LLVM on the back end). For more details, please go to our docs . New features and improvements Memory randomization In #1587 @adamsitnik has introduced a new, experimental feature called \"Memory Randomization\". This feature allows you to ask BenchmarkDotNet to randomize the memory alignment by allocating random-sized byte arrays between iterations and call [GlobalSetup] before every benchmark iteration and [GlobalCleanup] after every benchmark iteration. Sample benchmark: public class IntroMemoryRandomization { [Params(512 * 4)] public int Size; private int[] _array; private int[] _destination; [GlobalSetup] public void Setup() { _array = new int[Size]; _destination = new int[Size]; } [Benchmark] public void Array() => System.Array.Copy(_array, _destination, Size); } Without asking for the randomization, the objects are allocated in [GlobalSetup] and their unmodified addresses (and alignment) are used for all iterations (as long as they are not promoted to an older generation by the GC). This is typically the desired behavior, as it gives you very nice and flat distributions: dotnet run -c Release --filter IntroMemoryRandomization -------------------- Histogram -------------------- [502.859 ns ; 508.045 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- But if for some reason you are interested in getting a distribution that is better reflecting the \"real-life\" performance you can enable the randomization: dotnet run -c Release --filter IntroMemoryRandomization --memoryRandomization true -------------------- Histogram -------------------- [108.803 ns ; 213.537 ns) | @@@@@@@@@@@@@@@ [213.537 ns ; 315.458 ns) | [315.458 ns ; 446.853 ns) | @@@@@@@@@@@@@@@@@@@@ [446.853 ns ; 559.259 ns) | @@@@@@@@@@@@@@@ --------------------------------------------------- Method-specific job attributes From now, all attributes that derive from JobMutatorConfigBaseAttribute ( full list ) can be applied to methods. You no longer have to move a method to a separate type to customize config for it. [Benchmark] [WarmupCount(1)] public void SingleWarmupIteration() [Benchmark] [WarmupCount(9)] public void NineWarmupIterations() Sortable parameter columns In order to sort columns of parameters in the results table, you can use the Property Priority inside the params attribute. The priority range is [Int32.MinValue;Int32.MaxValue] , lower priorities will appear earlier in the column order. The default priority is set to 0 . public class IntroParamsPriority { [Params(100)] public int A { get; set; } [Params(10, Priority = -100)] public int B { get; set; } [Benchmark] public void Benchmark() => Thread.Sleep(A + B + 5); } Method B A Mean Error StdDev Benchmark 10 100 115.4 ms 0.12 ms 0.11 ms This feature got implemented by @JohannesDeml in #1612 . Customizable ratio column Now it's possible to customize the format of the ratio column. [Config(typeof(Config))] public class IntroRatioStyle { [Benchmark(Baseline = true)] public void Baseline() => Thread.Sleep(1000); [Benchmark] public void Bar() => Thread.Sleep(150); [Benchmark] public void Foo() => Thread.Sleep(1150); private class Config : ManualConfig { public Config() { SummaryStyle = SummaryStyle.Default.WithRatioStyle(RatioStyle.Trend); } } } | Method | Mean | Error | StdDev | Ratio | RatioSD | |--------- |-----------:|--------:|--------:|-------------:|--------:| | Baseline | 1,000.6 ms | 2.48 ms | 0.14 ms | baseline | | | Bar | 150.9 ms | 1.30 ms | 0.07 ms | 6.63x faster | 0.00x | | Foo | 1,150.4 ms | 5.17 ms | 0.28 ms | 1.15x slower | 0.00x | This feature was implemented in #731 . Improved CoreRun support BenchmarkDotNet was reporting invalid .NET Core version number when comparing performance using CoreRuns built from dotnet/corefx and dotnet/runtime . Fixed by @adamsitnik in #1580 In #1552 @stanciuadrian has implemented support for all GcMode characteristics for CoreRunToolchain . Previously the settings were just ignored, now they are being translated to corresponding COMPlus_* env vars. Improved CoreRT support CoreRT has moved from https://github.com/dotnet/corert/ to https://github.com/dotnet/runtimelab/tree/feature/NativeAOT and we had to update the default compiler version and nuget feed address. Moreover, there was a bug in CoreRtToolchain which was causing any additional native dependencies to not work. Big thanks to @MichalStrehovsky , @jkotas and @kant2002 for their help and support! #1606 , #1643 , #1679 Command-line argument support in BenchmarkRunner So far only BenchmarkSwitcher was capable of handling console line arguments. Thanks to @chan18 BenchmarkRunner supports them as well ( #1292 ): public class Program { public static void Main(string[] args) => BenchmarkRunner.Run(typeof(Program).Assembly, args: args); } New API: ManualConfig.CreateMinimumViable ManualConfig.CreateEmpty creates a completely empty config. Without adding a column provider and a logger to the config the users won't see any results being printed. In #1582 @adamsitnik has introduced a new method that creates minimum viable config: IConfig before = ManualConfig.CreateEmpty() .AddColumnProvider(DefaultColumnProviders.Instance) .AddLogger(ConsoleLogger.Default); IConfig after = ManualConfig.CreateMinimumViable(); Benchmarking NuGet packages from custom feeds In #1659 @workgroupengineering added the possibility to indicate the source of the tested nuget package and whether it is a pre-release version. IConfig config = DefaultConfig.Instance .AddJob(Job.Default .WithNuGet(\"BenchmarkDotNet\", \"0.13.0\", new Uri(\"https://api.nuget.org/v3/index.json\")) .WithId(\"0.13.0\")) .AddJob(Job.Default .WithNuGet(\"BenchmarkDotNet\", \"0.12.1.1534\", new Uri(\"https://ci.appveyor.com/nuget/benchmarkdotnet\"), prerelease: true) .WithId(\"0.12.1.1534\")); Deterministic benchmark builds BenchmarkDotNet is now always enforcing Deterministic builds ( #1489 ) and Optimizations enabled ( #1494 ) which is a must-have if you are using custom build configurations. MSBuild enforces optimizations only for configurations that are named Release (the comparison is case-insensitive). <ItemGroup Condition=\" '$(Configuration)' == 'X' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"1.0.0\" /> </ItemGroup> <ItemGroup Condition=\" '$(Configuration)' == 'Y' \"> <PackageReference Include=\"SomeLibThatYouWantToBenchmark\" Version=\"2.0.0\" /> </ItemGroup> var config = DefaultConfig.Instance .AddJob(Job.Default.WithCustomBuildConfiguration(\"X\").WithId(\"X\").AsBaseline()) .AddJob(Job.Default.WithCustomBuildConfiguration(\"Y\").WithId(\"Y\")); #1489 , #1494 Improved Hardware Counters support BenchmarkDotNet is being used by the .NET Team to ensure that .NET is not regressing. More than three thousand benchmarks (they can be found here ) are being executed multiple times a day on multiple hardware configs. Recently, .NET Team started to use InstructionsRetired to help to filter unstable benchmarks that report regressions despite not changing the number of instructions retired. This has exposed few bugs in Hardware Counters support in BenchmarkDotNet, which all got fixed by @adamsitnik in #1547 and #1550 . Moreover, we have removed the old PmcDiagnoser and extended EtwProfiler with the hardware counters support. It's just much more accurate and futureproof. For details, please go to #1548 . How stable was PmcDiagnoser (same benchmarks run twice in a row on the same machine): Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 845,746 Burgers_0 .NET Core 2.1 30,154,151 Burgers_0 .NET Framework 4.6.1 4,230,848 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 34,154,524 Burgers_0 .NET Core 2.1 246,534,203 Burgers_0 .NET Framework 4.6.1 2,607,686 How stable is EtwProfiler : Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,069,978,261 Burgers_0 .NET Core 2.1 3,676,000,000 Burgers_0 .NET Framework 4.6.1 3,468,866,667 Method Runtime InstructionRetired/Op Burgers_0 .NET 5.0 3,066,810,000 Burgers_0 .NET Core 2.1 3,674,666,667 Burgers_0 .NET Framework 4.6.1 3,468,600,000 Moreover, in #1540 @WojciechNagorski has added the removal of temporary files created by EtwProfiler . Improved Troubleshooting We have the possibility to ask BDN to stop on the first error: --stopOnFirstError true . The problem was when the users had not asked for that, tried to run n benchmarks, all of them failed to build, and BDN was printing the same build error n times. In #1672 @adamsitnik has changed that, so when all the build fails, BDN stops after printing the first error. Moreover, we have also changed the default behavior for the failed builds of the boilerplate code. If the build fails, we don't remove the files. Previously we have required the users to pass --keepFiles to keep them. See #1567 for more details and don't forget about the Troubleshooting docs! Docs and Samples improvements Big thanks to @lukasz-pyrzyk , @fleckert , @MarecekF , @joostas , @michalgalecki , @WojciechNagorski , @MendelMonteiro , @kevinsalimi , @cedric-cf , @YohDeadfall , @jeffhandley and @JohannesDeml who have improved our docs and samples! #1463 , #1465 , #1508 , #1518 , #1554 , #1568 , #1601 , #1633 , #1645 , #1647 , #1657 , #1675 , #1676 , #1690 . Template improvements Projects created out of our official templates might have been unexpectedly packed when running dotnet pack on the entire solution. In #1584 @kendaleiv has explicitly disabled packing for the template. The template had netcoreapp3.0 TFM hardcoded. This got fixed by @https://github.com/ExceptionCaught in #1630 and #1632 . In #1667 @YohDeadfall has changed the default debug type from portable to pdbonly (required by DisassemblyDiagnoser ). Bug fixes Very long string [Arguments] and [Params] were causing BenchmarkDotNet to crash. Fixed by @adamsitnik in #1248 and #1545 . So far trace file names were containing full benchmark names and arguments. Now if the name is too long, the trace file name is a hash (consistent for multiple runs of the same benchmark). The same goes for passing benchmark name by the host process to the benchmark process via command-line arguments. LangVersion set to a non-numeric value like latest was crashing the build. Fixed by @martincostello in #1420 . Windows 10 November 201 9 was being recognized as 201 8 . Fixed by @kapsiR in #1437 . Assemblies loaded via streams were not supported. Fixed by @jeremyosterhoudt in #1443 . NativeMemoryProfiler was detecting small leaks that were false positives. Fixed by @WojciechNagorski in #1451 and #1600 . DisassemblyDiagnoser was crashing on Linux. Fixed by @damageboy in #1459 . Target framework moniker was being printed as toolchain name for Full .NET Framework benchmarks. Fixed by @svick in #1471 . [ParamsSource] returning IEnumerable<object[]> was not working properly when combined with [Arguments] . Fixed by @adamsitnik in #1478 . NullReferenceException in MultimodalDistributionAnalyzer . Fixed by @suslovk in #1488 . NotSupportedException was being thrown if there was an encoding mismatch between host and benchmark process. Diagnosed by @ChristophLindemann in #1487 , fixed by @lovettchris in #1491 . MissingMethodException was being thrown in projects that referenced a newer version of Iced . Fixed by @Symbai in #1497 and in #1502 . AppendTargetFrameworkToOutputPath set to false was not supported. Fixed by @adamsitnik in #1563 A locking finalizer could have hanged benchmark process which would just print // AfterAll and never quit. Fixed by @adamsitnik in #1571 . To prevent other hangs from happening, a timeout of 250ms was added. If the process does not quit after running the benchmarks and waiting 250ms , it's being force killed. In some cases, JsonExporter was reporting NaN for some of the Statistics. This was breaking non-.NET JSON deserializers. Fixed by @marcnet80 in #1581 . UnitType.Size metrics were not using the provided number format. Fixed by @jodydonetti in #1569 and #1618 . MaxColumnWidth setting was not used for type names. Fixed by @JohannesDeml in #1609 . Current culture was not respected when formatting Ratio column values. Fixed by @JohannesDeml in #1610 . BenchmarkDotNet was redirecting Standard Error of the benchmark process, which was causing deadlocks for benchmarks that were writing to it. Fixed by @adamstinik in #1631 DisassemblyDiagnoser was failing to disassemble multiline source code. @YohDeadfall fixed that in #1674 . In #1644 @adamstinik has fixed the inconsistency between benchmark filter and hint. Removal of the dotnet global tool In #1006 (0.11.4) we have introduced a new dotnet global tool. By looking at the number of reported bugs we got to the conclusion that the tool has not passed the test of time. Why? Because it was based entirely on dynamic assembly loading which is very hard to get right in .NET and the fact that we support all existing .NET Runtimes (.NET, .NET Core, Mono, CoreRT) made it even harder (if not impossible). We have removed it and the old versions are no longer supported . For more details, please refer to #1572 . Milestone details In the v0.13.0 scope, 53 issues were resolved and 94 pull requests were merged. This release includes 111 commits by 37 contributors. Resolved issues (53) #721 Add possibility to customize BaselinedScaledColumn with provided func (assignee: @AndreyAkinshin ) #1136 benchmark / beforeEverything fails when running in docker-win #1242 bug JSON Exporter exports NaN for some properties. This fails most JSON parsers (assignee: @marcnet80 ) #1247 Support benchmarks with very long string arguments (assignee: @adamsitnik ) #1288 Fix Hardware Counters diagnoser (assignee: @adamsitnik ) #1290 BenchmarkRunner should support parsing console line arguments (assignee: @chan18 ) #1333 Getting \"Unknown Processor\" Again #1427 NativeMemoryProfiler reports false positive leak (assignee: @WojciechNagorski ) #1431 System.IO.FileNotFoundException with EtwProfiler #1433 Benchmarks work in .NET 4.7.2 but not .NET Core 3.1 #1436 Wrong OsBrandString for Windows 10 1909 #1448 NRE in MultimodalDistributionAnalyzer #1452 Setting LangVersion to Latest Causes an Error #1464 DisassemblyDiagnoserConfig.ExportDiff needs better description #1472 Add support of Wasm to Benchmark Dotnet (assignee: @naricc ) #1474 docs: Getting started guide #1480 BenchmarkRunner not working from VSTS agent (assignee: @lovettchris ) #1487 Benchmarks do not execute (as service process / VSTS agent) on non US systems #1493 Using WithCustomBuildConfiguration leads to always running with RyuJIT Debug (assignee: @adamsitnik ) #1495 [GcServer(true)] is ignored with --corerun #1496 System.MissingMethodException: Method not found: 'Iced.Intel.MasmFormatter.get_MasmOptions()'. #1512 Template has hardcoded netcoreapp3.0 TFM (assignee: @ExceptionCaught ) #1532 Auto-generated project has invalid XML #1535 Can't benchmark library that targets 'net5.0-windows' framework (assignee: @adamsitnik ) #1537 Failed to run benchmarks on .net 5 RC1 and Preview LangVersion #1539 Inconsistency between benchmark filter and hint (assignee: @adamsitnik ) #1544 [EtwProfiler] Merge operation failed return code 0x3 (assignee: @adamsitnik ) #1546 Sometimes Hardware Counters per Op are reported as NaNs (assignee: @adamsitnik ) #1549 InstructionPointerExporter has been broken for a while (assignee: @adamsitnik ) #1559 [Docs] Update Console Args doc (assignee: @kevinsalimi ) #1561 NativeMemoryProfiler doesn't report allocations in v0.12.1.1432 Nightly (assignee: @WojciechNagorski ) #1564 error MSB4086: A numeric comparison was attempted on \"$(LangVersion)\" (assignee: @adamsitnik ) #1565 More consistent formatting of results #1566 BDN should not delete temporary build directories for failed builds (assignee: @adamsitnik ) #1570 Benchmark runs failing when using .NET 5 RC2 SDK installed via snap (assignee: @adamsitnik ) #1576 Missing/misleading version number with corerun #1585 Non-optimized dependency #1591 Wasm Benchmark Runs Failing with Target Framework Error (assignee: @naricc ) #1598 VB Net Framework project throws exception from command line tool #1605 CoreRT / NativeAOT version (assignee: @adamsitnik ) #1607 Exporter approval tests has recently become unstable (assignee: @marcnet80 ) #1613 EventPipeProfiler generating invalid SpeedScope files. #1616 BenchmarkDotNet fail in WPF project with .NET 5.0-windows target #1620 NullReferenceException in v0.12.1 #1623 Can I run Full Framework benchmarks without having a Console App? (assignee: @adamsitnik ) #1628 Installation uses legacy/archaic dotnetcore 2.1.503 (assignee: @adamsitnik ) #1629 Writing to Console.Error in benchmarked code causes a deadlock (assignee: @adamsitnik ) #1654 Update for 0.12.2 #1670 dotnet benchmark cli tool errors with .net5.0 assemblies (assignee: @adamsitnik ) #1673 Source code provider incorrectly handles multiline source code #1685 Support for SingleFile && SelfContained apps #1692 Bug running wasm benchmarks - Broken Pipe in writeline #1693 Estimate Date for Supporting .NET 6 (assignee: @adamsitnik ) Merged pull requests (94) #1097 Allow for Config per method, introduce OS and OSArchitecture filters (by @adamsitnik ) #1248 Support very long string as benchmark arguments (by @adamsitnik ) #1292 passed args to benchmark runner (by @chan18 ) #1360 Basic BenchmarkDotNet support for Xamarin (by @jonathanpeppers ) #1420 Fix MSB4086 if LangVersion is a keyword (by @martincostello ) #1426 Fix typo in log message (by @martincostello ) #1429 [xamarin] fix Mono runtime version detection (by @jonathanpeppers ) #1434 [samples] UI tweaks to Xamarin samples (by @jonathanpeppers ) #1437 Fix wrongly reported os brand string for Windows 10 1909 (by @kapsiR ) #1443 Handle assemblies loaded via a stream (by @jeremyosterhoudt ) #1451 Fix native memory profiler (by @WojciechNagorski ) #1454 always print full information about non-optimized dependencies (by @adamsitnik ) #1458 Don't try to parse blank lines (by @TysonMN ) #1459 Upgrades ClrMD to a version that will not crash on Linux :( (by @damageboy ) #1463 Updated Disassembler docs (by @lukasz-pyrzyk ) #1465 Improved doc description of the ExportDiff property (by @lukasz-pyrzyk ) #1471 Clearly display names for .Net Framework (by @svick ) #1478 ParamsSource returning IEnumerable<object[]> fixes (by @adamsitnik ) #1479 net5.0 does not contain \"core\" word but it's a .NET Core moniker (by @adamsitnik ) #1483 Add Wasm Tool Chain (by @naricc ) #1488 Safe access to CultureInfo (by @suslovk ) #1489 enforce Deterministic builds for auto-generated .NET Core projects (by @adamsitnik ) #1490 be less strict about verifying the Acknowledgment (by @adamsitnik ) #1491 set process output encoding to utf8 so BenchmarkRunnerDotNet works in self hosted VSTS agent. (by @lovettchris ) #1492 allow the users to specify Platform via console args (by @adamsitnik ) #1494 enforce Optimizations when using Custom Build Configurations (by @adamsitnik ) #1497 Update to latest Iced 1.7.0 (by @Symbai ) #1498 Pedantic WASM improvements (by @adamsitnik ) #1500 Wasm: samples, docs and a bug fix (by @adamsitnik ) #1501 Add Custom Runtime Pack option (by @naricc ) #1502 Update to latest Iced (by @Symbai ) #1503 Update MeasurementsStatistics.cs (by @skynode ) #1507 Change mono-config.js format in the Wasm Tool Chain for ICU support (by @naricc ) #1508 fixed typo (by @fleckert ) #1509 [xamarin] fix for DebugConfig and read-only file system (by @jonathanpeppers ) #1518 FactorialWithTailing - incorrect implementation (by @MarecekF ) #1523 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (by @adamsitnik ) #1540 Remove unneeded files after etw profiler (by @WojciechNagorski ) #1545 Fix Merge operation failed for EtwProfiler (by @adamsitnik ) #1547 hardware counters: don't try to exclude non-existing overhead for long running benchmarks (by @adamsitnik ) #1548 Remove the old PmcDiagnoser, EtwProfiler is much more accurate (by @adamsitnik ) #1550 Bring instruction pointer exporter back to live (by @adamsitnik ) #1552 Enable supported GcMode characteristics with corerun (by @stanciuadrian ) #1554 Documentation: add --maxWidth description (by @joostas ) #1556 Simplify code: remove sort before adding to HashSet (by @stanciuadrian ) #1560 Add support for Platform-specific TFMs introduced in .NET 5 (by @adamsitnik ) #1563 ensure that the auto-generated project alwas has tfm in the output path (by @adamsitnik ) #1567 Dont remove artifacts when build fails (by @adamsitnik ) #1568 Update getting-started.md (by @michalgalecki ) #1569 Respect size number format in MetricColumn (by @jodydonetti ) #1571 Dispose parameters, kill benchmarking process when it hangs after printing the results (by @adamsitnik ) #1572 Remove the dotnet global tool (by @adamsitnik ) #1573 Don't run the benchmark once per iteration if only the first ivocation lasts longer than IterationTime (by @adamsitnik ) #1580 use Environment.Version to determine .NET 5+ versions (by @adamsitnik ) #1581 Json exporter fix (by @marcnet80 ) #1582 introduce ManualConfig.CreateMinimumViable() method (by @adamsitnik ) #1584 Prevent dotnet pack from packaging benchmark projects (by @kendaleiv ) #1587 Memory Randomization (by @adamsitnik ) #1590 Update message to not suggest an obsolete API (by @martincostello ) #1592 Add wasmnet50 wasmnet60 monikers (by @naricc ) #1600 fix issue #1561 (by @WojciechNagorski ) #1601 Update README.md (by @WojciechNagorski ) #1606 CoreRT feed and version update (by @adamsitnik ) #1609 Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (by @JohannesDeml ) #1610 Fix add missing culuture info to ToString in RatioStyle (by @JohannesDeml ) #1612 Sorting parameter columns with parameter priority (by @JohannesDeml ) #1618 Json indentation level fix (by @marcnet80 ) #1630 Update framework symbol on dotnet new template #1512 (by @ExceptionCaught ) #1631 don't redirect Standard Error, as we don't read it and writing to it by benchmark can cause deadlocks (by @adamsitnik ) #1632 update console app templating (by @ExceptionCaught ) #1633 Update etwprofiler.md (by @MendelMonteiro ) #1635 Install local SDK without sudo on Unix (by @am11 ) #1637 .NET Core 2.1 -> .NET 5.0 (by @adamsitnik ) #1643 Remove CoreRT workaround (by @MichalStrehovsky ) #1644 Filter hint improvements (by @adamsitnik ) #1645 Update Console Args doc #1559 (by @kevinsalimi ) #1647 Update API in documentation #1602 (by @kevinsalimi ) #1652 Basic snap support (by @adamsitnik ) #1657 1655 doc with options obsolete usage of with (by @cedric-cf ) #1659 feat: Allowed to indicate the source of nuget package and whether it is a pre-release version. (by @workgroupengineering ) #1662 Add tool chain for Netcore Mono AOT. (by @naricc ) #1667 Changed default debug type to pdbonly (by @YohDeadfall ) #1672 when all builds fail, BDN should stop after printing first error (by @adamsitnik ) #1674 Fixed smart pointer for multiline source code (by @YohDeadfall ) #1675 Updated disassembler contribution docs (by @YohDeadfall ) #1676 Fix a docs typo (by @jeffhandley ) #1679 Fix location for NativeAOT publish files (by @kant2002 ) #1686 Resolve assembly location for SingleFile (by @am11 ) #1689 Dont redirect standard input for WASM (by @naricc ) #1690 Fix change runtime target to Core50 (by @JohannesDeml ) #1691 don't remove OS version number from the platform-specifc TFM (by @adamsitnik ) #1697 0.13.0 release notes (by @adamsitnik ) #1698 Update \"View results\" from \"Getting started\" (by @rstm-sf ) #1707 Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm template (by @naricc ) Commits (111) 117c37 Postrelease update of v0.12.1 changelog (by @AndreyAkinshin ) 742f44 Fix typo (by @AndreyAkinshin ) 82b15e Fix MSB4086 if LangVersion is a keyword (#1420) (by @martincostello ) 9c0f52 Xamarin Support (#1360) (by @jonathanpeppers ) e37c02 Fix typo in log message (#1426) (by @martincostello ) ccdf22 [xamarin] fix Mono runtime version detection (#1429) (by @jonathanpeppers ) d95493 [samples] UI tweaks to Xamarin samples (#1434) (by @jonathanpeppers ) d07604 Fix wrongly reported os brand string for Windows 10 1909 (#1437) (by @kapsiR ) 1efd5e Handle assemblies loaded via a stream (#1443) (by @jeremyosterhoudt ) 502ad7 Update OsBrandStringHelper.cs (by @AndreyAkinshin ) 67971e Update OsBrandStringTests.cs (by @AndreyAkinshin ) ceef31 don't try to parse blank lines #1456 (#1458) (by @TysonMN ) 9a3469 Upgrades ClrMD to a version that will not crash on Linux :( (#1459) (by @damageboy ) bd1c93 Updated Disassembler settings (#1463) (by @lukasz-pyrzyk ) 35f50f Improved doc description of the ExportDiff property (#1465) (by @lukasz-pyrzyk ) dbbab9 Clearly display names for .Net Framework (#1471) (by @svick ) 044591 ParamsSource returning IEnumerable<object[]> fixes (#1478) (by @adamsitnik ) 703d54 Safe access to CultureInfo (by @suslovk ) a4dd37 Update to latest Iced (#1497) (by @Symbai ) 092889 Add Wasm Tool Chain (#1483) (by @naricc ) 01455d set process output encoding to utf8 (#1491) (by @lovettchris ) fa7da4 net5.0 does not contain \"core\" word but it's a .NET Core moniker (#1479) (by @adamsitnik ) 254da4 enforce Optimizations when using Custom Build Configurations (#1494) (by @adamsitnik ) 765d52 allow the users to specify Platform via console args (#1492) (by @adamsitnik ) 908b09 always print full information about non-optimized dependencies (#1454) (by @adamsitnik ) 1ff50a Pedantic WASM improvements (#1498) (by @adamsitnik ) d57c4c enforce Deterministic builds for auto-generated .NET Core projects (#1489) (by @adamsitnik ) 59080c Support very long string as benchmark arguments (#1248) (by @adamsitnik ) 9c5663 Wasm: samples, docs and a bug fix (#1500) (by @adamsitnik ) 13ee8b Add Custom Runtime Pack option to WasmToolchain (#1501) (by @naricc ) b356ac Update to latest Iced (#1502) (by @Symbai ) 797ced fixed typo (#1508) (by @fleckert ) ef0ac7 Change mono-config.js format in the Wasm Tool Chain for ICU support (#1507) (by @naricc ) eb20d3 Update README (by @AndreyAkinshin ) 92474e make MeasurementsStatistics a readonly ref struct (#1503) (by @skynode ) 64cc94 [xamarin] fix for DebugConfig and read-only file system (#1509) (by @jonathanpeppers ) c8af03 FactorialWithTailing - fix incorrect sample implementation (#1518) (by @MarecekF ) c9f158 add .NET 6.0 support, rename .NET Core 5.0 to .NET 5.0 (#1523) (by @adamsitnik ) e4d37d Fix native memory profiler (#1451) (by @WojciechNagorski ) 10abc4 Remove unneeded files after etw profiler (#1540) (by @WojciechNagorski ) e8d085 Documentation: add --maxWidth description (#1554) (by @joostas ) c6cd54 Update CorrectionsSuggester.cs (#1556) (by @stanciuadrian ) be769f Enable supported GcMode characteristics with corerun (#1552) (by @stanciuadrian ) 0a004a Update getting-started.md (#1568) (by @michalgalecki ) cd0bda Respect size number format in MetricColumn (#1569), fixes #1565 (by @jodydonetti ) 349e90 Introduce RatioStyle, fix #721 (by @AndreyAkinshin ) 718031 hardware counters: don't try to exclude non-existing overhead for long runnin... (by @adamsitnik ) fbd52c remove the old PmcDiagnoser, EtwProfiler is much more accurate (#1548) (by @adamsitnik ) 152414 Bring instruction pointer exporter back to live (#1550) (by @adamsitnik ) c6d6fb Fix Merge operation failed for EtwProfiler (#1545) (by @adamsitnik ) 769090 Add support for Platform-specific TFMs introduced in .NET 5 (#1560) (by @adamsitnik ) 8de321 ensure that the auto-generated project alwas has target framework moniker in ... (by @adamsitnik ) 0f9bb3 Dont remove artifacts when build fails (#1567) (by @adamsitnik ) b4bda1 Dispose parameters, kill benchmarking process when it hangs after printing th... (by @adamsitnik ) c209b1 Remove the dotnet global tool (#1572) (by @adamsitnik ) 178b6a Don't run the benchmark once per iteration if only the first ivocation lasts ... (by @adamsitnik ) 8b2214 use Environment.Version to determine .NET 5+ versions (#1580) (by @adamsitnik ) d5c158 Prevent dotnet pack from packaging benchmark projects (#1584) (by @kendaleiv ) 8149c3 Json exporter fix for double.NaN (#1581), fixes #1242 (by @marcnet80 ) c63fe8 Update message to not suggest an obsolete API (#1590) (by @martincostello ) 0de41c Added wasmnet50 wasmnet60 monikers. (#1592) (by @naricc ) 992719 fix issue #1561 (#1600) (by @WojciechNagorski ) 81c234 Update README.md (#1601) (by @WojciechNagorski ) 641ffd Fix #1604 - pass SummaryStyle to ParameterInstance.ToDisplayText() (#1609) (by @JohannesDeml ) e72ddf Fix add missing culuture info to ToString in RatioStyle (#1610) (by @JohannesDeml ) d17926 Json indentation level fix (#1618) (by @marcnet80 ) 40f6e5 Update framework symbol on dotnet new template #1512 (#1630) (by @ExceptionCaught ) ffc8dd use .AddDiagnoser instead of the obsolete .With in the EtwProfiler doc sample... (by @MendelMonteiro ) 5d421c Install local SDK without sudo on Unix (#1635) (by @am11 ) d71a7e update console app templating (#1632) (by @ExceptionCaught ) aef9cb Sorting parameter columns with parameter priority (#1612) (by @JohannesDeml ) d5f7b9 Memory Randomization (#1587) (by @adamsitnik ) 5b2167 don't redirect Standard Error, as we don't read it and writing to it by bench... (by @adamsitnik ) a7af81 introduce ManualConfig.CreateMinimumViable() method (#1582) (by @adamsitnik ) 852bb8 .NET Core 2.1 -> .NET 5.0 (#1637) (by @adamsitnik ) e01312 Support latest Windows and macOS versions in OsBrandStringHelper (by @AndreyAkinshin ) 502dc9 CoreRT feed and version update (#1606) (by @adamsitnik ) 9f5d70 Remove CoreRT workaround (#1643) (by @MichalStrehovsky ) 6a151f passed args to benchmark runner (#1292) (by @chan18 ) bf63b3 Update Console Args doc, fixes #1559 (#1645) (by @kevinsalimi ) 970d28 Update API in documentation, fixes #1602 (#1647) (by @kevinsalimi ) d758f6 Allow for Config per method, introduce OS and OSArchitecture filters (#1097) (by @adamsitnik ) b4e2b6 1655 doc with options obsolete usage of with (#1657) (by @cedric-cf ) 8c28c8 add basic snap support (#1652) (by @adamsitnik ) e1c8cb Filter hint improvements (#1644) (by @adamsitnik ) 349f9d feat: Allowed to indicate the source of nuget package and whether it is a pre... (by @workgroupengineering ) 4a917d Add tool chain for Netcore Mono AOT. (#1662) (by @naricc ) 314a27 [Templates] Changed default debug type to pdbonly (#1667) (by @YohDeadfall ) 2616cd Updated disassembler contribution docs (#1675) (by @YohDeadfall ) 02b907 Fix a typo (#1676) (by @jeffhandley ) b67cfb Fix location for NativeAOT publish files (#1679) (by @kant2002 ) 63e28c when all builds fail, BDN should stop after printing first error (#1672) (by @adamsitnik ) becc13 Dont redirect standard input for WASM (#1689) (by @naricc ) b97bf6 Fix change runtime target to Core50 (#1690) (by @JohannesDeml ) 0321a3 Fixed smart pointer for multiline source code (#1674) (by @YohDeadfall ) 7265c1 Resolve assembly location for SingleFile (#1686) (by @am11 ) 626dcb don't remove OS version number from the platform-specifc TFM (#1691) (by @adamsitnik ) 95608d 0.13.0 release notes (#1697) (by @adamsitnik ) 4b5a65 Remove Allocated column from the \"View results\" doc page (#1698) (by @rstm-sf ) b0683f Set ValidateExecutableReferencesMatchSelfContained to false in aotllvm templa... (by @naricc ) 09afe7 Windows 21H1 support in OsBrandStringHelper (by @AndreyAkinshin ) 77b58d Update old changelogs (by @AndreyAkinshin ) 2f4b79 Improve AsyncBenchmarksTests.TaskReturningMethodsAreAwaited (by @AndreyAkinshin ) a79339 Disable CoreRtToolchain.Core50 in ThreadingDiagnoserTests.GetToolchains on Unix (by @AndreyAkinshin ) 18e292 Update README (by @AndreyAkinshin ) 09a204 Update BenchmarkDotNet.sln.DotSettings (by @AndreyAkinshin ) 85db95 Bump Cake version: 0.37.0->1.1.0 (by @AndreyAkinshin ) 5c74d5 Bump docfx version: 2.51->2.57.2 (by @AndreyAkinshin ) 2a2c0c Update copyright year (2021) (by @AndreyAkinshin ) 396060 Prepare v0.13.0 changelog (by @AndreyAkinshin ) 6dcf43 Set library version: 0.13.0 (by @AndreyAkinshin ) Contributors (37) Adam Sitnik ( @adamsitnik ) Adeel Mujahid ( @am11 ) Adrian Stanciu ( @stanciuadrian ) Andrey Akinshin ( @AndreyAkinshin ) Andrii Kurdiumov ( @kant2002 ) Cédric Charière Fiedler ( @cedric-cf ) chan18 ( @chan18 ) Chris Lovett ( @lovettchris ) damageboy ( @damageboy ) Dexter ( @skynode ) Florian Eckert ( @fleckert ) Jeff Handley ( @jeffhandley ) jeremyosterhoudt ( @jeremyosterhoudt ) Jody Donetti ( @jodydonetti ) Johannes Deml ( @JohannesDeml ) Jonathan Peppers ( @jonathanpeppers ) Jonathon Wei ( @ExceptionCaught ) Justas ( @joostas ) kapsiR ( @kapsiR ) Ken Dale ( @kendaleiv ) Kevin Salimi ( @kevinsalimi ) Konstantin ( @suslovk ) Łukasz Pyrzyk ( @lukasz-pyrzyk ) marcnet80 ( @marcnet80 ) MarecekF ( @MarecekF ) Martin Costello ( @martincostello ) Mendel Monteiro-Beckerman ( @MendelMonteiro ) Michał Gałecki ( @michalgalecki ) Michal Strehovský ( @MichalStrehovsky ) Nathan Ricci ( @naricc ) Petr Onderka ( @svick ) Rustam Sayfutdinov ( @rstm-sf ) Symbai ( @Symbai ) Tyson Williams ( @TysonMN ) Wojciech Nagórski ( @WojciechNagorski ) workgroupengineering ( @workgroupengineering ) Yoh Deadfall ( @YohDeadfall ) Thank you very much! Additional details Date: May 19, 2021 Milestone: v0.13.0 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.0 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.0"
  },
  "changelog/v0.13.1.html": {
    "href": "changelog/v0.13.1.html",
    "title": "BenchmarkDotNet v0.13.1 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.13.1 BenchmarkDotNet v0.13.1 is a service update with various bug fixes and improvements. Highlights S390x architecture support ( #1712 ) Various WASM toolchain improvements ( #1719 , #1722 , #1729 , #1742 , #1743 , #1744 , #1746 , #1757 , #1763 ) Support of CoreRT on 5.0.3XX SDK ( #1725 ) Using Utf8 for reading from standard input (fixes a nasty encoding-related bug) ( #1735 ) Adjusting WaitForExit timeouts ( #1745 ) Support for returning unmanaged types from benchmarks with InProcessToolchain ( #1750 ) Disabled Tiered JIT ( #1751 ) A MemoryDiagnoser bug fix ( #1762 ) Allow users to hide Gen X columns ( #1764 ) Copy GC settings from host process to the benchmark process ( #1765 ) Do not split surrogates in shortified parameter values ( #1705 ) Milestone details In the v0.13.1 scope, 3 issues were resolved and 22 pull requests were merged. This release includes 36 commits by 10 contributors. Resolved issues (3) #1703 Unable to run benchmark when ParamsSource refers to string with surrogate pairs #1713 System.NotSupportedException: Unknown Acknowledgment: ﻿Acknowledgment when running in a github action (assignee: @adamsitnik ) #1714 AwaitingTasksShouldNotInterfereAllocationResults is flaky (assignee: @adamsitnik ) Merged pull requests (22) #1705 do not split surrogates in ParameterInstance.ToDisplayText() (by @novak-as ) #1710 Fix typo (by @martincostello ) #1712 add S390x architecture support (by @adamsitnik ) #1719 Added UsingBrowserRuntimeWorkload (by @naricc ) #1722 Add AOT options to wasm runtime (by @naricc ) #1725 Add ValidateExecutableReferencesMatchSelfContained (by @kant2002 ) #1729 Naricc/validate executable references match self contained (by @naricc ) #1735 Use Utf8 not just for writing to standard output, but also for reading from standard input (by @adamsitnik ) #1742 Fix WasmAssembliesToBundle item is empty error (by @radekdoulik ) #1743 Add linker description for wasm AOT (by @radekdoulik ) #1744 Make mono/wasm run on Windows (by @radekdoulik ) #1745 Fix #1731. (by @cgranade ) #1746 Make PrepareForWasmBuild work with wasm workload (by @radekdoulik ) #1748 Fix typo in docs (by @Jlobblet ) #1750 Fix pointer-returning benchmarks support for InProcessToolchain (by @adamsitnik ) #1751 disable TieredJit so it's background allocations don't show up in allocated memory reported by MemoryDiagnoser tests (by @adamsitnik ) #1757 [wasm] Add WasmMainJSPath in interpreter projects (by @radekdoulik ) #1762 MemoryDiagnoser fix (by @adamsitnik ) #1763 Pr wasm set runtimesrcdir for interpreter (by @naricc ) #1764 Allow users to hide Gen X columns (by @adamsitnik ) #1765 Copy GC settings from host process (by @adamsitnik ) #1768 Fix typo in README (by @eugene-g ) Commits (36) fe1124 Postrelease update of v0.13.0 changelog (by @AndreyAkinshin ) 0388db Update build-and-pack.cmd (by @AndreyAkinshin ) 5c8469 Set release date for v0.13.0 (by @AndreyAkinshin ) 601a1a Fix typo (#1710) (by @martincostello ) 5bc925 do not split surrogates in ParameterInstance.ToDisplayText() (#1705) (by @novak-as ) 891e57 Add unicode testcases in ParameterInstanceTests.MaxParameterColumnWidthCanBeC... (by @AndreyAkinshin ) 5d2160 Update changelog files (by @AndreyAkinshin ) bbc4b4 add S390x architecture support (#1712) (by @adamsitnik ) bf54f0 Fix flakiness in ThreadingDiagnoserTests (by @AndreyAkinshin ) 6ffdb2 [WASM] Added UsingBrowserRuntimeWorkload (#1719) (by @naricc ) 5196e6 Add AOT options to wasm runtime (#1722) (by @naricc ) d97285 Add ValidateExecutableReferencesMatchSelfContained (#1725) (by @kant2002 ) cb23e1 Delete .BenchmarkDotNet.Samples.csproj.swp (#1726) (by @naricc ) 75f632 Set ValidateExecutableReferencesMatchSelfContained for Wasm (#1729) (by @naricc ) 9e7e50 Added false to Wasm cs proj. (#1734) (by @naricc ) e7ff4c Use Utf8 not just for witing to standard output, but also for reading from st... (by @adamsitnik ) 081563 Added UsingBrowserRuntimeWorkload false. (#1741) (by @naricc ) 2fefdb Fix WasmAssembliesToBundle item is empty error (#1742) (by @radekdoulik ) 6b475f Add linker description for wasm AOT (#1743) (by @radekdoulik ) acb6f2 Make mono/wasm run on Windows (#1744) (by @radekdoulik ) 4b3d19 Make PrepareForWasmBuild work with wasm workload (#1746) (by @radekdoulik ) 141ef7 handle processes that don't exit on time more gracefully, fixes #1731. (#1745) (by @cgranade ) c3fb7b Add support for returning unmanaged types from benchmarks (#1739) (by @kant2002 ) 6f453b [wasm] Allow unsafe code (#1752) (by @radekdoulik ) c2cee2 Fix the CI (by @radekdoulik ) 19cbef Fix typo in docs (#1748) (by @Jlobblet ) 1a94d4 [wasm] Add WasmMainJSPath in interpreter projects (#1757) (by @radekdoulik ) 37ec19 Get rid of warning (#1760) (by @radekdoulik ) 4bd433 use benchmark process runtime, not host process runtime when deciding whether... (by @adamsitnik ) 8cb701 Update OsBrandStringHelper (by @AndreyAkinshin ) 8f81b5 Copy GC settings from host process (#1765) (by @adamsitnik ) f37266 Allow users to hide Gen X columns (#1764) (by @adamsitnik ) f9a4c1 [WASM] set runtimesrcdir for interpreter (#1763) (by @naricc ) 9e674d Fix typo in README (by @eugene-g ) 708be4 Prepare v0.13.1 changelog (by @AndreyAkinshin ) a93681 Set library version: 0.13.1 (by @AndreyAkinshin ) Contributors (10) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Andrii Kurdiumov ( @kant2002 ) Chris Granade ( @cgranade ) Evgeny Grebenyuk ( @eugene-g ) John Blundell ( @Jlobblet ) Martin Costello ( @martincostello ) Nathan Ricci ( @naricc ) Oleksandr Novak ( @novak-as ) Radek Doulik ( @radekdoulik ) Thank you very much! Additional details Date: August 11, 2021 Milestone: v0.13.1 ( List of commits ) NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Annotations/0.13.1 https://www.nuget.org/packages/BenchmarkDotNet.Templates/0.13.1"
  },
  "changelog/v0.13.2.html": {
    "href": "changelog/v0.13.2.html",
    "title": "BenchmarkDotNet v0.13.2 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.13.2"
  },
  "changelog/v0.7.0.html": {
    "href": "changelog/v0.7.0.html",
    "title": "BenchmarkDotNet v0.7.0 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.0 Milestone details In the v0.7.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 59 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (59) 7f1c49 Add ShiftVsMultiplyBenchmark (by @AndreyAkinshin ) 21298c Renaming (by @AndreyAkinshin ) 86aada Add ReverseSortProgram (by @AndreyAkinshin ) 5830ef Add MakeRefVsBoxingProgram (by @AndreyAkinshin ) fe121e Automatic adjustment WarmUpIterationCount (by @AndreyAkinshin ) d3dd9c Improved console output (by @AndreyAkinshin ) 5e5df2 Update IncrementProgram (by @AndreyAkinshin ) dca61d Change Average statistic to Median (by @AndreyAkinshin ) 9d57e6 Update README.md (by @AndreyAkinshin ) 7cca77 StaticFieldProgram -> ArrayIterationProgram (by @AndreyAkinshin ) e02906 Add ForeachArray and ForeachList programs (by @AndreyAkinshin ) 8e3f6e Add StandardDeviation calculation (by @AndreyAkinshin ) 8b0c50 Add BenchmarkSettings singleton with DetailedMode property (by @AndreyAkinshin ) eae5bf Add useful arguments for console application (by @AndreyAkinshin ) 6f15f0 Update README.md (by @AndreyAkinshin ) c1c44b Add StackFrameProgram (by @AndreyAkinshin ) bbc6e7 Update StackFrameProgram (by @AndreyAkinshin ) 5f8121 Set version number and add NuGet package metadata (by @AndreyAkinshin ) 9425cb Add ProcessorAffinity to settings (by @AndreyAkinshin ) bcc037 Add single result benchmark mode (--single) and disable warmup mode (--disabl... (by @AndreyAkinshin ) 4ce0b4 Add build.bat for Benchmarks project (by @AndreyAkinshin ) 69fbc7 Add --output-file option (by @AndreyAkinshin ) df2092 Update build system (by @AndreyAkinshin ) addd25 Update run.bat (by @AndreyAkinshin ) b5c154 Add Mono support to run.bat (by @AndreyAkinshin ) a4b42a Update build system (by @AndreyAkinshin ) 65bbf7 Benchmarks: add support of selecting target program via number (by @AndreyAkinshin ) d4317b Add MedianTicks to CompetitionResult report in DetailedMode fixed #1 (by @AndreyAkinshin ) 3999e0 Update README.md (by @AndreyAkinshin ) bd7452 Update EnvironmentTickCount hack (by @AndreyAkinshin ) cf7aa6 Add CultureInfo setting (by @AndreyAkinshin ) 16bb5e Set BenchmarkDotNet version: 0.5.1 (by @AndreyAkinshin ) 07cf52 Add CompetitionBase: now competitions can be created in form of unit tests. (by @mijay ) 284b78 Full refactoring (by @AndreyAkinshin ) 2943d9 Add BenchmarkDotNet.Samples project (by @AndreyAkinshin ) 572483 Merge branch 'dev' (by @AndreyAkinshin ) 324d99 Remove ReflectionVsExpressionCompetition (by @AndreyAkinshin ) ce5c67 Add CacheConsiousBinarySearchCompetition (by @AndreyAkinshin ) ba8725 Add SelectVsConvertAllCompetition (by @AndreyAkinshin ) 60b002 Set BenchmarkDotNet version: 0.5.2 (by @AndreyAkinshin ) 3a4213 Fix in GetBenchmarkMethodClean (by @AndreyAkinshin ) 73ee56 Add BitCountCompetition (by @AndreyAkinshin ) 72836a Add missed Clean in BenchmarkCompetitionTask, Fixed #4 (by @AndreyAkinshin ) 1258cb Big refactoring (by @AndreyAkinshin ) 03bf14 Attributes renaming (by @AndreyAkinshin ) 98a3cd Improved environment info (by @AndreyAkinshin ) fe6e4e New benchmarks: ArrayBoundEliminationCompetition, InstructionLevelParallelism... (by @AndreyAkinshin ) c89054 Fix in EnvironmentHelper.GetConfiguration() (by @AndreyAkinshin ) 90d260 Add icon (by @AndreyAkinshin ) beb681 Improved WarmUp (by @AndreyAkinshin ) 7a63b6 Big refactoring (by @AndreyAkinshin ) 8197e5 Update samples (by @AndreyAkinshin ) c8d348 Add BenchmarkProperties (by @AndreyAkinshin ) 97c73a Update Cpu_InstructionLevelParallelism (by @AndreyAkinshin ) 957714 Small fixes (by @AndreyAkinshin ) fdf4dd Update README (by @AndreyAkinshin ) 8ac1ab Merge branch 'big-refactoring' (by @AndreyAkinshin ) 18a256 Small fixes (by @AndreyAkinshin ) 20df13 NuGet version: 0.7.0 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Mitya Kononchuk ( @mijay ) Thank you very much!"
  },
  "changelog/v0.7.1.html": {
    "href": "changelog/v0.7.1.html",
    "title": "BenchmarkDotNet v0.7.1 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.1 Milestone details In the v0.7.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) b2bc76 A bugfix (MSBuild fail case) (by @AndreyAkinshin ) ce7f58 Improved SingleRun (by @AndreyAkinshin ) 295cc2 Current values for JitVersion, Platform, and Framework (by @AndreyAkinshin ) 744eba Set library version: 0.7.1 (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much!"
  },
  "changelog/v0.7.2.html": {
    "href": "changelog/v0.7.2.html",
    "title": "BenchmarkDotNet v0.7.2 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.2 Milestone details In the v0.7.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) 19f1e2 Add templates for BenchmarkProjectGenerator (by @AndreyAkinshin ) 043c04 v0.7.2: BenchmarkMode.Throughput, OperationCountAttribute, minor improvements... (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much!"
  },
  "changelog/v0.7.3.html": {
    "href": "changelog/v0.7.3.html",
    "title": "BenchmarkDotNet v0.7.3 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.3 Milestone details In the v0.7.3 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 1 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (1) 42e13b v0.7.3: Small bug fixes (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much!"
  },
  "changelog/v0.7.4.html": {
    "href": "changelog/v0.7.4.html",
    "title": "BenchmarkDotNet v0.7.4 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.4 Milestone details In the v0.7.4 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 2 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (2) c5e924 Update README (by @AndreyAkinshin ) 641c95 v0.7.4: New benchmark Invoker, new samples, refactoring, minor fixes (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much!"
  },
  "changelog/v0.7.5.html": {
    "href": "changelog/v0.7.5.html",
    "title": "BenchmarkDotNet v0.7.5 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.5 Milestone details In the v0.7.5 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 4 commits by 1 contributors. Resolved issues (0) Merged pull requests (0) Commits (4) 957a01 Update samples (by @AndreyAkinshin ) 118e2f Add the Cpu_Ilp_RyuJit sample (by @AndreyAkinshin ) b7e564 Update copyrights (by @AndreyAkinshin ) b6cce3 v0.7.5: Improved project building (by @AndreyAkinshin ) Contributors (1) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much!"
  },
  "changelog/v0.7.6.html": {
    "href": "changelog/v0.7.6.html",
    "title": "BenchmarkDotNet v0.7.6 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.6 Milestone details In the v0.7.6 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 9 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (9) 8e9942 Update README.md (by @NN--- ) 51ef26 Merge pull request #11 from NN---/patch-2 (by @AndreyAkinshin ) db8791 Fixed link to samples. (by @redknightlois ) 14ddf4 Merge pull request #12 from redknightlois/patch-1 (by @mattwarren ) d70b4c Accessibility and genericness checks added for benchmark methods. (by @krk ) 04ce12 Benchmark methods defined in nested classes are supported. (by @krk ) a5caba Improvements in log parser (by @AndreyAkinshin ) d750b9 Merge pull request #13 from krk/master (by @AndreyAkinshin ) eab4bd Set library version: 0.7.6 (by @AndreyAkinshin ) Contributors (5) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) Kerem Kat ( @krk ) Matt Warren ( @mattwarren ) NN ( @NN--- ) Thank you very much!"
  },
  "changelog/v0.7.7.html": {
    "href": "changelog/v0.7.7.html",
    "title": "BenchmarkDotNet v0.7.7 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.7 Milestone details In the v0.7.7 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 14 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (14) c94525 Add Cpu_BranchPerdictor (by @AndreyAkinshin ) 44cbb0 Add Algo_Md5VsSha256 (by @AndreyAkinshin ) 4d789c Most significant bit and bool to int conversions. (by @redknightlois ) 09446b Updated to avoid using an array. (by @redknightlois ) b16153 Fixed a bug where converting a bool to int instead to byte (which is the nati... (by @redknightlois ) 52acca Merge pull request #15 from redknightlois/master (by @AndreyAkinshin ) 66cce4 Fix troubles with inlining (by @AndreyAkinshin ) a8e641 Fixes in Jit_BoolToInt (by @AndreyAkinshin ) cfbb88 Rename task parameters: Current -> Host (by @AndreyAkinshin ) 209b4f Rename Task to BenchmarkTask, fix #9 (by @AndreyAkinshin ) 74be9d Fix typos (by @AndreyAkinshin ) adc6c2 Fix Intro_01_MethodTasks (by @AndreyAkinshin ) 438042 Add BenchmarkRunner.RunUrl (by @AndreyAkinshin ) 72d606 Set library version: 0.7.7 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) Thank you very much!"
  },
  "changelog/v0.7.8.html": {
    "href": "changelog/v0.7.8.html",
    "title": "BenchmarkDotNet v0.7.8 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.7.8 Milestone details In the v0.7.8 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 36 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (36) 6ede76 Reporting: better number formats for ops/sec. (by @ppanyukov ) 118bc9 Merge pull request #17 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) 994cbc Markdown friendly reporting (by @AndreyAkinshin ) 91bbb4 Reporting: use fixed precision for AvrTime and StdDev. (by @ppanyukov ) e9b8fe Merge pull request #18 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) 121c3d Reporting: uniform time units across all benchmarks. (by @ppanyukov ) 1cb520 Merge pull request #21 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) a4f53e Reporting: refactor use of BenchmarkTimeSpan. (by @ppanyukov ) 7fbf63 Merge pull request #24 from ppanyukov/feature/report-num-align (by @AndreyAkinshin ) c8c893 message for Obsolete warning which tells what to use now + updated README (by @adamsitnik ) b48756 Merge pull request #26 from adamsitnik/master (by @AndreyAkinshin ) 36f849 Add Jit_RegistersVsStack (by @AndreyAkinshin ) 32cafc Allow a [Setup] method to be used on Benchmarks (by @mattwarren ) 8a14a8 Missed out of last commit (by @mattwarren ) 0103b7 Integration tests for [Setup] method closes #23, closes #7 (by @mattwarren ) 1e7c25 Display MSBuild errors in the console output, see #22 (by @mattwarren ) 876303 Added new benchmark for Stopwatch v DateTime (by @mattwarren ) e5f748 New ReportExporter system (by @AndreyAkinshin ) e0fdbc Add BenchmarkDotNet.Visualizer (by @AndreyAkinshin ) 954d08 Fix bug in op/s reporting (by @mattwarren ) d9dcf4 Tidying up BenchmarkDotNet.Samples layout see #29 (by @mattwarren ) 7abb1b Making Visualizer samples point to the new location (see #29) (by @mattwarren ) 96d5b9 Speed up the integration tests, closes #23 (by @mattwarren ) 2568a1 Initial work on Params attribute (see #8) (by @mattwarren ) 47fad8 Ensure Benchmarks with Params show up properly in Reports (by @mattwarren ) 36e060 Integration tests and sample for Params attribute (by @mattwarren ) 76ad88 Fixing some spelling mistakes (by @mattwarren ) 81e6eb Update BenchmarkProgram.txt (by @mattwarren ) 4008cf Merge pull request #32 from PerfDotNet/mattwarren-exception-handling (by @mattwarren ) 9e893e Statistic improvements (by @AndreyAkinshin ) 9ce9f9 Ensure that Params attribute can work with static fields/properties (by @mattwarren ) 7c3782 Update README.md (by @AndreyAkinshin ) 5a1783 Update Array_HeapAllocVsStackAlloc.cs (by @mattwarren ) 50ff16 Allow just number param in RunCompetitions. (by @vkkoshelev ) 04c306 Merge pull request #34 from vedun-z/master (by @AndreyAkinshin ) a630dc Set library version: 0.7.8 (by @AndreyAkinshin ) Contributors (5) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Philip Panyukov ( @ppanyukov ) vkkoshelev ( @vkkoshelev ) Thank you very much!"
  },
  "changelog/v0.8.0.html": {
    "href": "changelog/v0.8.0.html",
    "title": "BenchmarkDotNet v0.8.0 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.8.0 Milestone details In the v0.8.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 67 commits by 5 contributors. Resolved issues (0) Merged pull requests (0) Commits (67) 042631 Atomics sample (by @redknightlois ) 6ce693 Merge pull request #35 from redknightlois/master (by @AndreyAkinshin ) e73ce4 Update Intro_03_SingleRun (by @AndreyAkinshin ) add75c Samples: add Js_AsVsCast (by @AndreyAkinshin ) 1d4653 Samples: updates Js_AsVsCast (by @AndreyAkinshin ) 73f48f BenchmarkRuntime support (by @AndreyAkinshin ) 8e9fec BenchmarkRuntime: fix a bug (by @AndreyAkinshin ) 0d8a86 Added RotateBits (will be interested when https://github.com/dotnet/coreclr/i.. . (by @redknightlois ) 724970 Added and special case which we know it must not be optimized at all (for com... (by @redknightlois ) 30ba93 Merge pull request #43 from redknightlois/master (by @AndreyAkinshin ) a2338c Big refactoring (by @AndreyAkinshin ) dc8d02 Make the \"Getting Started\" guide read better (by @mattwarren ) 9883ca Update README.md (by @mattwarren ) 3cd76b Update README.md (by @mattwarren ) 6a3d00 Update README.md (by @mattwarren ) 7de832 Better way of generating Benchmark competition list (by @mattwarren ) 10ded0 Add Jit_GenericsMethod (by @AndreyAkinshin ) e5538b Fix for #42 (make benchmarks work in LINQPad) (by @mattwarren ) 873450 Make logging robust when strings contain '{' or '} (by @mattwarren ) 2ee55a Create a batch file that builds the benchmark (by @mattwarren ) d14b18 Adding \"Advanced Features\" section (by @mattwarren ) deb1a9 Sample benchmark for different types of loops (by @mattwarren ) 26e7b0 Move sample to correct namespace (by @mattwarren ) 505711 Grouping parameter results together (fixes #36) (by @mattwarren ) 1ee786 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren ) 496ae1 Add support for benchmarking methods of generic classes (#44) (by @mattwarren ) ad12e1 Return of the Params (by @AndreyAkinshin ) f80613 Little cleanup (by @AndreyAkinshin ) 52a076 Little refactoring (Flow -> Toolchain) (by @AndreyAkinshin ) 2f383e Moar samples (by @mattwarren ) 30b162 Initial work on code for asm/IL viewing (by @mattwarren ) 6a8873 Initial support for printing Assembly code (by @mattwarren ) 8cd841 Print diagnostic info (with flag \"-printDiagnostics\") (by @mattwarren ) 236043 Adding missing CLRMD dependancies (by @mattwarren ) 58b7a3 Print the method when we have a \"call\" asm instruction (by @mattwarren ) 1dae2b Change Jit_GenericsMethod benchmark to reproduce on x64 both Legacy & RuyJit (by @alexandrnikitin ) 6ae157 Merge pull request #47 from alexandrnikitin/samples-Jit_GenericsMethod-x64repro (by @AndreyAkinshin ) c39b7c README: add gitter link (by @AndreyAkinshin ) b0768e Ensure we \"close\" the code section in the markdown we generate (by @mattwarren ) 6c9ae7 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren ) 9ed66d Show how you can write \"Performance\" Unit Tests (by @mattwarren ) 7c9c6d Helper methods for Performance Unit Tests (by @mattwarren ) 3a2c75 Make Perf Unit Test more robust!! (by @mattwarren ) d1ddd3 Ensure the Description is used when sorting (if available) (by @mattwarren ) 27d662 Moving assembly viewer into BenchmarkDotNet.Diagnostics (by @mattwarren ) 1ef961 Load BenchmarkDotNet.Diagnostics dynamically (by @mattwarren ) 7eb70a New plugin system (by @AndreyAkinshin ) 2114d7 Fix typos in API (by @AndreyAkinshin ) e0a488 Fix in PerformanceUnitTest (by @AndreyAkinshin ) 02cddd BenchmarkDotNet.Tests: upgrade xunit to 2.1 (by @AndreyAkinshin ) 3d8ff2 IntegrationTests: replace GetTestOutput by AccumulationLogger (by @AndreyAkinshin ) 5ebf69 IntegrationTests: upgrade xunit to 2.1 (by @AndreyAkinshin ) 280834 Diagnostic refactoring (by @AndreyAkinshin ) 79ee42 Custom toolchains (by @AndreyAkinshin ) 527df6 Analysers (by @AndreyAkinshin ) 3d8199 Fix in BuildTable (by @AndreyAkinshin ) 699588 Tidy up of Source Diagnoser code (part of #53) (by @mattwarren ) 5ab029 Better way of getting the called method name (part of #53) (by @mattwarren ) 37f468 Integration test for Source Diagnostics (see #53) (by @mattwarren ) da0093 Spelling mistakes and remove unused using stmts (by @mattwarren ) fbf409 Fix typo in README (by @ForNeVeR ) 4895c6 Merge pull request #61 from ForNeVeR/patch-1 (by @AndreyAkinshin ) dd5f1f Rename: exec -> execute (by @AndreyAkinshin ) 6826a9 BenchmarkSwitcher: update the promt message (by @AndreyAkinshin ) f2a63f Update README.md (by @AndreyAkinshin ) 54cfdc Samples/Program.cs: small fix (by @AndreyAkinshin ) a927e9 Set library version: 0.8.0 (by @AndreyAkinshin ) Contributors (5) Alexandr Nikitin ( @alexandrnikitin ) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) Friedrich von Never ( @ForNeVeR ) Matt Warren ( @mattwarren ) Thank you very much!"
  },
  "changelog/v0.8.1.html": {
    "href": "changelog/v0.8.1.html",
    "title": "BenchmarkDotNet v0.8.1 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.8.1 Milestone details In the v0.8.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (12) 79ee93 README.md: small fixes (by @AndreyAkinshin ) a3e2dc Adding missing CLRMD binary dependencies (by @mattwarren ) 7492c1 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @mattwarren ) ddae06 Lazy-load the Diagnostic plug-ins, fixes #63 (by @mattwarren ) 5df0df More robust version of the Diagnostic Library (see #53) (by @mattwarren ) 9f3ba0 Ensure that non-void SingleRun Benchmarks work (by @mattwarren ) de5bca Allow Benchmarks that use Inner classes (see #55) (by @mattwarren ) 5d000f Ensure we can run Benchmarks produced by F# (see #59) (by @mattwarren ) 8b0563 Added missing binary dependency (part of #59) (by @mattwarren ) 60047e Fixing #45 (by @mattwarren ) 3bede9 Implemented Ctrl-C handling in the Console (Fixes #50) (by @mattwarren ) 719391 Set library version: 0.8.1 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much!"
  },
  "changelog/v0.8.2.html": {
    "href": "changelog/v0.8.2.html",
    "title": "BenchmarkDotNet v0.8.2 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.8.2 Changes in the Summary table Summary table now supports ResultExtenders that can add new column to the table Now we use StandardError (aka Error ) as the main accuracy metric Columns op/s , StdDev are disabled by default (you can add it via ResultExtenders) Statistic improvements, now you have detailed statistic in the console log like follows: Mean = 118.5298 us, StdError = 1.2863 us (N = 30, StdDev = 7.0454 us) Min = 109.1602 us, Median = 117.1794 us, Max = 132.5764 us IQR = 10.1244 us, LowerFence = 98.0834 us, UpperFence = 138.5810 us ConfidenceInterval = [116.0086 us; 121.0510 us] (CI 95%) Added the Baseline feature, see #64 Export improvements, now you have files <BenchmarkName>-report-github.md , <BenchmarkName>-report-stackoverflow.md for easy publishing results on GitHub and StackOverflow. Basic plotting. Added new BenchmarkRPlotExporter that creates BuildPlots.R in the bin directory. It is an R script that generates boxplot and barplot for your benchmarks (you should have installed R with defined R_HOME environment variable) Updated environment info Added Stopwatch Frequency and Resolution Split common benchmark properties (like Mode , Platform , Runtime ) in several lines (3 properties per line) Log improvements: add total time, statistics, list of exported files Bug fixes Milestone details In the v0.8.2 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 3 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) de0140 Add BenchmarkEnvironmentAnalyser (by @AndreyAkinshin ) 9ea78f Improved confidence intervals (by @AndreyAkinshin ) b8d4b6 Rename: PreWarmup -> Pilot (by @AndreyAkinshin ) 988efc Reporting: change StandardDeviation to StandardError (by @AndreyAkinshin ) 4da39d Big refactoring (by @AndreyAkinshin ) 6a0caa Add BenchmarkRPlotExporter (by @AndreyAkinshin ) 3a6ea4 Allow plugins to extend the Results Table (by @mattwarren ) 7a7991 Create a \"Result Extender\" plug-in for #64 (by @mattwarren ) 70ea89 Integration tests for #64 (by @mattwarren ) a2d0ec Separate class for string extensions. (by @alinasmirnova ) 5d6c78 Multiline prefix string extension. (by @alinasmirnova ) bdd84e New logger type for adding prefix. StackOverflow markdowns. (by @alinasmirnova ) ba9ec5 Move ExportToFile to ExporterBase. Add file suffix. (by @alinasmirnova ) 38cd8c GitHub markdown support. (by @alinasmirnova ) 732420 Markdown readme edits (by @alinasmirnova ) 541eef Merge pull request #71 from alinasmirnova/refactoring (by @AndreyAkinshin ) c53618 Merge remote-tracking branch 'refs/remotes/origin/develop' into refactoring (by @AndreyAkinshin ) e3f420 Samples: add Intro_08_Baseline (by @AndreyAkinshin ) 145b78 README: add NuGet badge (by @AndreyAkinshin ) b0e108 Minor fixes (by @AndreyAkinshin ) 565c25 Update README (by @AndreyAkinshin ) 045e2a Add BenchmarkStatResultExtender (by @AndreyAkinshin ) 20c6d2 Minor fixes (by @AndreyAkinshin ) f80edc Update README (by @AndreyAkinshin ) 3d2309 README: links to wiki (by @AndreyAkinshin ) d60d0f Fix bug in TimeUnit (by @AndreyAkinshin ) 034961 Unit tests for TimeUnit (by @AndreyAkinshin ) f2c6f1 Logs: add total time (by @AndreyAkinshin ) 140dec Merge branch 'refs/heads/refactoring' into develop (by @AndreyAkinshin ) 9e16e8 Ensure that the DeltaResultExtender doesn't throw (by @mattwarren ) 60f7c9 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren ) 77b24b Rollback of bad changes from the last merge (by @AndreyAkinshin ) 3df71a More robust way of wiring up BenchmarkBaselineDeltaResultExtender (by @mattwarren ) 8e5a0e Set library version: 0.8.2 (by @AndreyAkinshin ) Contributors (3) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Date: January 19, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.8.2"
  },
  "changelog/v0.9.0.html": {
    "href": "changelog/v0.9.0.html",
    "title": "BenchmarkDotNet v0.9.0 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.0 New API Autodetermination of amount iteration for warmup/target idle/main iterations, duration of iteration, amount of CLR launches. Milestone details In the v0.9.0 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 34 commits by 4 contributors. Resolved issues (0) Merged pull requests (0) Commits (34) 71369d Add benchmarks to tests different ways of accessing arrays. Copypasted from h... (by @alexandrnikitin ) 9a5930 Merge pull request #79 from alexandrnikitin/samples-array-access (by @AndreyAkinshin ) 1b8cf9 MathSummaryTests: fix output (by @AndreyAkinshin ) 92503b BenchmarkSwitcher improvements (by @AndreyAkinshin ) ebaeea Big API refactoring (by @AndreyAkinshin ) f149cb Big API refactoring, Part 2 (by @AndreyAkinshin ) 380d9a Big API refactoring, Part 3 (by @AndreyAkinshin ) 6cd2ce Big API refactoring, Part 4 (by @AndreyAkinshin ) 1665d8 Big API refactoring, Part 5 (by @AndreyAkinshin ) 140312 A better way of running a F# integration test (by @mattwarren ) 8e58ab Big API refactoring, Part 6 (by @AndreyAkinshin ) 9ec71b Add html export, resolved #75 (by @alinasmirnova ) 7ae4ed Merge pull request #86 from alinasmirnova/refactoring (by @AndreyAkinshin ) bfbc80 Big API refactoring, Part 7 (by @AndreyAkinshin ) 256ed4 Re-design of the IDiagnoser API (by @mattwarren ) f4bad8 Initial work on ETW Diagnostic Providers (by @mattwarren ) da2e3f Big API refactoring, Part 8 (by @AndreyAkinshin ) 5df553 Big API refactoring, Part 9 (by @AndreyAkinshin ) 120b7c Big API refactoring, Part 10 (by @AndreyAkinshin ) e61425 Big API refactoring, Part 11 (by @AndreyAkinshin ) 171ba0 Big API refactoring, Part 12 (by @AndreyAkinshin ) 854633 Big API refactoring, Part 13 (by @AndreyAkinshin ) caafa9 Fix a bug in Templates/BenchmarkProgram.txt (by @AndreyAkinshin ) 568c44 Add BenchmarkDotNet.Samples.FSharp (by @AndreyAkinshin ) 2fa773 Fix a bug in Generator (by @AndreyAkinshin ) 30e855 Update README (by @AndreyAkinshin ) 1164ef Update README (by @AndreyAkinshin ) 9c357c Improved plots for benchmarks with Params (by @AndreyAkinshin ) ef41f6 Fix a bug in ClassicBuilder (by @AndreyAkinshin ) 02babc Add BaselineDiffColumn.Scaled (by @AndreyAkinshin ) 4388c8 Remove construction with description in BenchmarkAttribute (by @AndreyAkinshin ) c9c25f Update README (by @AndreyAkinshin ) 1cef82 RPlotExporter improvements (by @AndreyAkinshin ) 173abf Set library version: 0.9.0 (by @AndreyAkinshin ) Contributors (4) Alexandr Nikitin ( @alexandrnikitin ) Alina Smirnova ( @alinasmirnova ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Date: February 9, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.0"
  },
  "changelog/v0.9.1.html": {
    "href": "changelog/v0.9.1.html",
    "title": "BenchmarkDotNet v0.9.1 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.1 Milestone details In the v0.9.1 scope, 0 issues were resolved and 0 pull requests were merged. This release includes 5 commits by 2 contributors. Resolved issues (0) Merged pull requests (0) Commits (5) a0cfba use benchmarkSwitcher and 0.9.0 api features (by @cloudRoutine ) a88fc0 Merge pull request #89 from cloudRoutine/patch-1 (by @AndreyAkinshin ) 99d7c5 Improved ReflectionExtensions.GetCorrectTypeName; Fixed #90 (by @AndreyAkinshin ) 770510 Improved work with idle method that returns a value type; Fixed #70 (by @AndreyAkinshin ) 3c4410 Set library version: 0.9.1 (by @AndreyAkinshin ) Contributors (2) Andrey Akinshin ( @AndreyAkinshin ) Jared Hester ( @cloudRoutine ) Thank you very much! Additional details Date: February 10, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.1"
  },
  "changelog/v0.9.2.html": {
    "href": "changelog/v0.9.2.html",
    "title": "BenchmarkDotNet v0.9.2 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.2 Dnx451 support (Closed #51 , Merged #87 ) Milestone details In the v0.9.2 scope, 1 issues were resolved and 1 pull requests were merged. This release includes 48 commits by 2 contributors. Resolved issues (1) #51 DNX Compatibility Merged pull requests (1) #87 DNX451 support (by @adamsitnik ) Commits (48) f25427 road to DNX: part I: moving from csproj to xproj (by @adamsitnik ) 2fe5cf road to DNX: part II: added dnx451 target (DNX SDK running on .Net 4.5.1) (by @adamsitnik ) 6b4400 road to DNX: part II: the moment when Unit Test has shown up in VS! (by @adamsitnik ) c97792 road to DNX: part II: able to debug Samples (by @adamsitnik ) f901d6 road to DNX: part II: the moment when Integration Test has shown up in VS! (by @adamsitnik ) f46296 road to DNX: part II: including *.txt files as resources, excluding auto-gene... (by @adamsitnik ) cfc1b6 updated gitignore to exclude files created during integration tests run (by @adamsitnik ) 60b343 Road to DNX: benchmark execution : building project.json instead of .csproj (by @adamsitnik ) 0d41cb Road to DNX: benchmark execution : compiling project.json with Microsoft.Dnx.... (by @adamsitnik ) 31bc59 updated versions in .json files after sync with master, (by @adamsitnik ) c8e826 road to DNX: compilation: adding MetadataReferences for dlls required to comp... (by @adamsitnik ) 2ebe6c road to DNX: compilation: adding executing assembly as dependency to project.... (by @adamsitnik ) 76a74e Road to DNX: removing dependencies to BenchmarkDotNet.Diagnostics for DNX451 ... (by @adamsitnik ) 40419a road to DNX: handling \"nuget-like\" package versions that can contain text (as... (by @adamsitnik ) 8f06a7 it should have never happened but it does when debugging: DirectoryNotFoundEx... (by @adamsitnik ) 7c2a96 Road to DNX: reusing MS dnu to restore and build. Simple solution that just w... (by @adamsitnik ) e51d4d Road to DNX: alternative to MS dnu. reuses nuget and roslyn but as for now it... (by @adamsitnik ) ada7cb Road to DNX: replacing dnu build with dnx run. +putting files in a folder tha... (by @adamsitnik ) 18e969 road to DNX: referencing the right thing, bitness the same as hosting process (by @adamsitnik ) 8e870c road to DNX: setting the compiler EXPLICIT to finally make it WORKING (at lea... (by @adamsitnik ) 466d13 Road to DNX: removing failed PoC,dependencies cleanup, added some comments (by @adamsitnik ) 5b3675 Road to DNX: removing dependencies to MSBuild for DNX target, some project.js... (by @adamsitnik ) 3e65e8 road to DNU: reference project during development, but package when released (by @adamsitnik ) 617a61 road to DNX: logging output from dnu restore/dnx run + default timeout (by @adamsitnik ) 075cdc road to DNX: new value for toolchain enum: DNX451 (by @adamsitnik ) bd3fea road to DNX: being able to debug NET40 from VS (by @adamsitnik ) da5a9a road to DNX: copying all files that used to be copied in \".csproj times\" (by @adamsitnik ) 5d8717 road to DNX: new debug profile with DNX trace mode ON, use when troubleshooti... (by @adamsitnik ) 8272f6 road to DNX: fixing tests (by @adamsitnik ) 96bcf8 road to DNX: make sure that our child process get the right priority and affi... (by @adamsitnik ) cd0ba8 road to DNX: respecting specified benchmark processor architecture (by @adamsitnik ) b1eb28 road to DNX: added all output files from integration tests to .gitignore (by @adamsitnik ) aa62d1 fix for 4.0 (was passing arguments in wrong order) (by @adamsitnik ) 0c1251 merge (by @adamsitnik ) 46cd5e F# support, limited to existing tools possibilities (can not run from VS, onl... (by @adamsitnik ) 74020c Merge remote-tracking branch 'upstream/master' (by @adamsitnik ) 3402f0 replacing dnx with dotnet cli (by @adamsitnik ) d634f4 road to DNX: final cleanup (by @adamsitnik ) 24cd3a removing project.lock.json files (by @adamsitnik ) 80becb removing all .csproj & packages.config file + keeping only single .sln file (by @adamsitnik ) 9633d5 removing nuspec (now auto-generated by VS based on project.json) + version in... (by @adamsitnik ) 617d82 running Classic Framework tests from console + minor cleanup (by @adamsitnik ) fc9d98 DNX: running once compiled assembly directly without dotnet cli (perf+abble t... (by @adamsitnik ) 8adad8 dnx: Diagnosers support. Currently only these which do not need umanaged libs... (by @adamsitnik ) 34c3c9 DNX: changed folder of the auto-generated files to benchmark-specific + samples (by @adamsitnik ) 9cf009 DNX: description for development (by @adamsitnik ) 43af33 update to dotnet cli changes: output path and exit codes , now we set output... (by @adamsitnik ) f59d3e Merge pull request #87 from adamsitnik/master (by @AndreyAkinshin ) Contributors (2) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Milestone: v0.9.2 Date: March 5, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.2"
  },
  "changelog/v0.9.3.html": {
    "href": "changelog/v0.9.3.html",
    "title": "BenchmarkDotNet v0.9.3 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.3 CoreCLR support (Closed #52 , Merged #113 ) Milestone details In the v0.9.3 scope, 2 issues were resolved and 1 pull requests were merged. This release includes 12 commits by 2 contributors. Resolved issues (2) #52 CoreCLR Compatibility #114 Update NETStandard.Library dependency Merged pull requests (1) #113 Core Clr support (by @adamsitnik ) Commits (12) 5b6460 Core: compilable main project (by @adamsitnik ) cfdde6 Core: compilable samples and tests projects (by @adamsitnik ) ab8b26 Core: new profile for running Samples from VS (by @adamsitnik ) 9e1372 Core: new toolchain implementation with dnx451 code reuse (by @adamsitnik ) de8bcc Core: tests: script to run both dnx and core (by @adamsitnik ) 05d50f Core: dotnet cli supports only x64 now, workaround (by @adamsitnik ) 726c66 Core: executing only supported benchmarks (x86 and Legacy Jit are not supported) (by @adamsitnik ) de3371 Core: Dnx and Core as Runtimes, removed Toolchain configuration (by @adamsitnik ) e7a3a8 Core: generating path in Linux-friendly way ;) (by @adamsitnik ) fede7c Core: notify user when the process.Priority can not be set and continue execu... (by @adamsitnik ) d59827 Merge pull request #113 from PerfDotNet/coreclr (by @AndreyAkinshin ) 939891 Set library version: 0.9.3 (by @AndreyAkinshin ) Contributors (2) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Thank you very much! Additional details Milestone: v0.9.3 Date: March 13, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.3 https://www.nuget.org/packages/BenchmarkDotNet/0.9.3-beta"
  },
  "changelog/v0.9.4.html": {
    "href": "changelog/v0.9.4.html",
    "title": "BenchmarkDotNet v0.9.4 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.4 Improved messages about error in benchmarks, see #104 Natural sort order, see #92 , #95 , #97 Improved double / float / decimal / enum support for Params, see #96 , #105 , #116 Now environment info includes information about HardwareTimerKind and JitModules Added DryConfig Improved export performance, closed #119 , merged #124 Better cmd-line discoverability (see #78 ), e.g. run Benchmark.exe --help and some useful information will be printed Supporting all kinds of references for generated project (exact version, custom paths, GAC, sub-folders, dependent assemblies not copied), closed #41 , #49 , #72 , #123 , merged #125 Friendliness to LinqPad restored, closed #66 , merged #125 Milestone details In the v0.9.4 scope, 13 issues were resolved and 2 pull requests were merged. This release includes 55 commits by 4 contributors. Resolved issues (13) #41 Seems, not supported \"sub-folder\" #49 Dependent assemblies are not copied or added to the project file. #72 Referenced assembly dll-file (directly via file) not referenced in generated Program.csproj #78 Better command line discoverability (assignee: @mattwarren ) #92 Results in the R graphs aren't displayed in a \"Natural Sort Order\" #95 Results should preserve the order of param values definition #96 Implement enums as valid Param for test #97 Params changes an order #104 System.InvalidOperationException: StatSummary: Sequence contains no elements #105 Params Attribute bug with float type #116 Issue when ParamAttribute decorated property is double and current system culture has comma as decimal separator #119 For large benchmarks report exporting is very, very slow and has a massive Gen2 heap #123 Can not run benchmark that references custom framework library (like WindowsBase) Merged pull requests (2) #124 Faster export (by @adamsitnik ) #125 supporting all kinds of references for generated project (by @adamsitnik ) Commits (55) 74789d Sort results by Parameter, in a Natural Sort Order (by @mattwarren ) fec115 ParameterComparer refacotring (by @AndreyAkinshin ) 9d3856 Add information about JIT modules in EnvironmentHelper (by @AndreyAkinshin ) 7667ee Adding TraceEvent library for parsing ETW Events (by @mattwarren ) ae71f2 More work on the GC/Allocation diagnostics (by @mattwarren ) efa739 Allow diagnosers to be run from cmd line or via [Config(..)] (by @mattwarren ) 633f1c Throw an error when invalid Config(..) options are specified (by @mattwarren ) 04678a Add information about HardwareTimerKind (by @AndreyAkinshin ) 7f3cf0 Fix in GetCorrectTypeNameTest (by @AndreyAkinshin ) d9b890 Fix in HardwareTimerKind (by @AndreyAkinshin ) 416e36 Natural sort order for CsvMeasurementsExporter and plots, Fixed #92 (by @AndreyAkinshin ) dfc54a Ensure we sort the results by Method Name/Description (by @mattwarren ) fa6c62 Changed GCDiagnoser to inspect live ETW event stream instead of recording to ... (by @goldshtn ) d3f7ce Params: float/double/decimal support, Fixed #105 (by @AndreyAkinshin ) 7bce9b Params: enum support, Fixed #96 (by @AndreyAkinshin ) 4890dd Merge pull request #106 from goldshtn/develop (by @mattwarren ) 9072b9 More robust when a benchmark throws an exception (see #104) (by @mattwarren ) 2b9162 Work on #73 - highlighting in the Console output (by @mattwarren ) f62483 Work on #73 - highlighting in the Console output (by @mattwarren ) a639d5 Work on #73 - highlighting in Markdown output (by @mattwarren ) 1457fe Changing [ConfigWithDryJobs] -> [DryConfig] (by @mattwarren ) 396b7d Diagnostics for \"JIT In-lining\" events (by @mattwarren ) 7a1027 Merge remote-tracking branch 'origin/master' into develop (by @adamsitnik ) 6ec7f0 GC Diagnosers: reference to nuget package, unit test for both CLASSIC and DNX (by @adamsitnik ) 9e7059 Proper XML Doc comment for DryConfig attribute (by @mattwarren ) ad6be7 README.md: update (by @AndreyAkinshin ) a4d0b8 Merge branch 'master' into develop (by @adamsitnik ) 71e911 perf: CSV export: less allocations, reusing JobShortInfo (by @adamsitnik ) 409b5e perf: logging with less allocations (by @adamsitnik ) be6bfc perf: simpified LoggerWithPrefix, no need to check for multiple lines because... (by @adamsitnik ) ade8a1 perf: avoid string.Concat and string.PadLeft (by @adamsitnik ) f070eb perf: reuse AllProperties, reduced complexity (by @adamsitnik ) 57c88b perf: deffer export to enable continuous progress updates instead of single l... (by @adamsitnik ) 40071d loggers: final cleanup and fix for doubled new lines for diagnosers (by @adamsitnik ) c46854 supporting all kinds of references for generated project. This closes #49, cl... (by @adamsitnik ) a36e34 Initial work on better cmd line discoverability (part of #78) (by @mattwarren ) 3f0752 Better formatting in the Baseline column (by @mattwarren ) 8ab1a2 More samples (by @mattwarren ) 1981a3 Refactoring of ConfigParser code (part of #78) (by @mattwarren ) 3d1eba Allows \"Exporters\" and \"Analysers\" to be specified via cmd line (part of #78) (by @mattwarren ) 5d195a Allow \"all\" option, i.e. \"exporters=all\" (part of #78) (by @mattwarren ) 2146b8 Added some tests for ConfigParser (by @mattwarren ) 582e08 Merge pull request #124 from PerfDotNet/perf (by @AndreyAkinshin ) 84e67d README: Update team section (by @AndreyAkinshin ) 4d6001 README: add FAQ question (by @AndreyAkinshin ) 43ade3 BenchmarkDotNet.Samples: add #CLASSIC_RELEASE in launchSettings (by @AndreyAkinshin ) e3c2d1 README: some improvements (by @AndreyAkinshin ) c416c4 use the highest used target framework version to avoid framework mismatches +... (by @adamsitnik ) 8a49b3 Merge branch 'develop' into references (by @adamsitnik ) 23b2ea integration tests for complex references scenarios (by @adamsitnik ) ddfa4a classic: specify full name and use newer msbuild dlls to avoid calling extra bat (by @adamsitnik ) 79e8eb code cleanup after LINQPad 4 & 5 verification (by @adamsitnik ) 445137 Merge pull request #125 from PerfDotNet/references (by @AndreyAkinshin ) 4f1e1f Update package description (by @AndreyAkinshin ) 0f5531 Set library version: 0.9.4 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Sasha Goldshtein ( @goldshtn ) Thank you very much! Additional details Milestone: v0.9.4 Date: March 24, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.4 https://www.nuget.org/packages/BenchmarkDotNet/0.9.4-beta"
  },
  "changelog/v0.9.5.html": {
    "href": "changelog/v0.9.5.html",
    "title": "BenchmarkDotNet v0.9.5 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.5 Added validators, JitOptimizationsValidator detects all non-optimzied dlls that were referenced #134 Strong naming #101 Add IOrderProvider #107 Putting all the generated artifacts in a separate folder: ./BenchmarkDotNet.Artifacts/results and ./BenchmarkDotNet.Artifacts/bin #94 Printing dotnet cli version for .NET Core and Dnx451, informing user when not installed. Closed #128 Supporting assembly redirects #67 Changed used msbuild version: 12 for .NET 4.5 (VS 2013), 14 for .NET 4.6 (VS 2015). Closed #132 and #137 Switched to new ‘dotnet’ target framework monikers (dotnet5.4 instead of dnxcore50), why dnx452, dnx46, net462 support added Executing single Benchmark for multiple Runtimes also with Diagnoser attached (see #117 ) Misc minor changes Milestone details In the v0.9.5 scope, 13 issues were resolved and 0 pull requests were merged. This release includes 45 commits by 4 contributors. Resolved issues (13) #67 F# requiring assembly binding redirects for FSharp.Core #94 Put all the generated artifacts in a separate folder #101 Strong naming? #107 Specify benchmark method order #122 Reports: Move params columns next to Method column #128 Print dotnet cli version in EnvironmentInfo #129 Improve DnxAndCoreTests #132 [Bug] FileNotFoundException On 0.9.4. #134 [Feature request] Release builds only? #137 Brand new machine with VS 2015 only b0rks #142 [Suggestion] BenchmarkDotNet.Analyzers.IAnalyser - use same spelling for namespace and type? #148 Crash on [Params] with a string value that contains an invalid path char #150 Declaring nested enums and using them as parameter value make incorrectly generated code/ Merged pull requests (0) Commits (45) 2645ef use AutoGenerateBindingRedirects to avoid assembly conflicts, fixes #67 (by @adamsitnik ) 693b21 warn user if dotnet cli is not installed and print it's version in summary, f... (by @adamsitnik ) bfb017 target NET46 to reference msbuild 14 that comes with VS 2015 to make BDN work... (by @adamsitnik ) fceb3c fallback to bat if MSBuild dlls are not found + generate bat when needed (by @adamsitnik ) 49bdf0 restore: generating build script file (now for all runtimes) (by @adamsitnik ) b9b0bc scripts: cleanup -> build -> show failed tests if any ->cleanup, fixes #129 (by @adamsitnik ) ad64d8 Put all the generated artifacts in a separate folder, fixes #94 (by @adamsitnik ) 902de6 F# samples targeting .NET Core +classic F# part reorganization (by @adamsitnik ) b31c0b supported languages: updated readme & integration tests for Visual Basic (by @adamsitnik ) 24ade7 handle missing MSBuild.dll, get latest msbuild in fallback script scenario, s... (by @adamsitnik ) d371de Spelling mistake in errors message (see #139) (by @mattwarren ) c882dd core: dependencies cleanup + getting rid of warnings (by @adamsitnik ) b14e35 Add IOrderProvider, fixes #107 (by @AndreyAkinshin ) c95267 warn user if non-optimized dll is used, fixes #134 (by @adamsitnik ) 5876f5 Strong naming, fixes #101 (by @adamsitnik ) 036168 Analys(z)ers unification, lets use single spelling, fixes #142 (by @adamsitnik ) 2fa5c0 Update README.md (by @JohanLarsson ) 8b8641 Merge pull request #145 from JohanLarsson/master (by @AndreyAkinshin ) 734533 introducing Validators: validate benchmarks before running, return errors in ... (by @adamsitnik ) eaa943 ExecutionValidator: allow users to verify that all their benchmarks are runna... (by @adamsitnik ) e4fa4b support overriding with 'stronger' validators, eliminate duplicates (by @adamsitnik ) 57666a Add column order for SummaryTable, fixes #122 (by @AndreyAkinshin ) 62af92 Minor fixes in README (by @AndreyAkinshin ) 5e6877 updated README (by @adamsitnik ) 1255a4 Initial work on BenchmarkDotNet.Diagnostics.Windows rename (by @mattwarren ) 59ca8c Ensure renamed diagnostics dll is loaded (BenchmarkDotNet.Diagnostics.Windows... (by @mattwarren ) 825193 Added info about Diagnosers (by @mattwarren ) b836c5 Spelling/formatting (by @mattwarren ) 3f74c7 Fixing project.json (after I overwrite previous changes) (by @mattwarren ) c24a78 Merge branch 'develop' of https://github.com/PerfDotNet/BenchmarkDotNet into ... (by @mattwarren ) 8c678f reflecting recent Diagnosers->Diagnostics.Windows changes (by @adamsitnik ) 9bcdca Executing single Benchmark for multiple Runtimes [with Diagnoser attached] #117 (by @adamsitnik ) 4dffdb Switching to new ‘dotnet’ target framework monikers (by @adamsitnik ) 81b1e4 improved Runtimes descriptions + .NET 4.6.2 support (by @adamsitnik ) 8e92e1 dnx452 and dnx46 support (by @adamsitnik ) 06efde Fix in BaselineDiffColumnTest, see also #122 (by @AndreyAkinshin ) f79f83 DEVELOPING.md: use stable version of dotnet cli (by @AndreyAkinshin ) c2206d BenchmarkDotNet/project.json: correct version for System.IO.FileSystem (by @AndreyAkinshin ) 1b650d Support for nested Enums as Params values, fixes #150 (by @adamsitnik ) 76ef44 characters as Params support, including invalid path characters, fixes #148 (by @adamsitnik ) 14e45c Distinct jobs to avoid possible duplication when config is doubled (by @adamsitnik ) 837254 cleanup (by @adamsitnik ) d0cf6b added NETCore.Platforms dependency to make dotnet cli restore our Core projects (by @adamsitnik ) f7a20e replacing the chars that are invalid for file names, not only paths #148 (by @adamsitnik ) e31872 Set library version: 0.9.5 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Johan Larsson ( @JohanLarsson ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Milestone: v0.9.5 Date: May 02, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.5 https://www.nuget.org/packages/BenchmarkDotNet/0.9.5-beta"
  },
  "changelog/v0.9.6.html": {
    "href": "changelog/v0.9.6.html",
    "title": "BenchmarkDotNet v0.9.6 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.6 Added Percentiles (see #164 ) Added support for Json export (see #84 ) Bugfixes Milestone details In the v0.9.6 scope, 11 issues were resolved and 2 pull requests were merged. This release includes 40 commits by 5 contributors. Resolved issues (11) #100 Code generation doesn't support generic classes #112 Generic benchmark classes are not supported #140 Readd an ability to define and to use custom Toolchain #141 [Request for comments] Assembly-level config attribute? #151 Crash during benchmark with baseline #152 MarkdownExporter.Default.ExportToLog fails with NRE for Summary with Critical Validation Errors #153 ManualConfig.Add(IConfig config) does not add the validators. #156 Cleanup benchmark folders #158 BaselineDiffColumn: NullReferenceException if one of the benchmark methods was failed. #161 Build warnings after update to 0.9.5 #171 Problem with ExceptionDispatchInfo (assignee: @AndreyAkinshin ) Merged pull requests (2) #138 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn ) #164 Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn ) Commits (40) 9e625a copying validators when merging configs, fixes #153 (by @adamsitnik ) 5d0a7d returning empty objects instead of nulls, fixes #152 (by @adamsitnik ) cfff3b switching back to the old moniker that is supported not only by dnx and dotne... (by @adamsitnik ) 522fde Initial work on Json export (#84) (by @mattwarren ) 31452f Make SimpleJson build under \"DNXCore,Version=v5.0\" - (#84) (by @mattwarren ) 48b17a Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren ) d8dad6 removing ClrMD dependencies that were causing troubles with nuget package rel... (by @adamsitnik ) 0a81d4 removing ClrMd diagnosers, they are kept in clrmd branch (by @adamsitnik ) 972ea2 setting BenchmarkDotNet version to one that is not in the Nuget yet to get do... (by @adamsitnik ) 1e6581 Removing final traces or Runtime and Source SourceDiagnosers (by @mattwarren ) 3576d4 Make BaselineDiffColumn more robust - fixes #158 and #151 (by @mattwarren ) 3f0d7b Exclude \"BenchmarkDotNet.Artifacts\" folder (can get in the way when building) (by @mattwarren ) 00995d Percentiles added into Statistics, StatisticColumn, BaselineDiffColumn (by @ig-sinicyn ) 2410d4 Update project.json files (by @AndreyAkinshin ) ed75f6 Assembly-level config attribute, Fixes #141 (by @AndreyAkinshin ) 6f3a0c Add a BenchmarkSwitcher constructor for assembly, see #141 (by @AndreyAkinshin ) 4124d0 Catch InvalidOperationException in ClassicBuilder (by @AndreyAkinshin ) 9c8513 Cleanup benchmark folders (by default!), fixes #156 (by @adamsitnik ) d0179f merge KeepBenchmarkFiles and allow fluent api usage, #156 (by @adamsitnik ) b8130a Readd an ability to define and to use custom Toolchain, fixes #140 (by @adamsitnik ) 8a263b moving KeepBenchmarkFiles merge logic to Add method (by @adamsitnik ) e1e5c7 Sample & documentation for percentiles (by @ig-sinicyn ) 0d4262 Merge commit '00995dfac270ae71e81897348ec379cd97fb01c3' into feature-percentiles (by @ig-sinicyn ) 54b4f0 Merge pull request #164 from ig-sinicyn/feature-percentiles (by @AndreyAkinshin ) f8278c Generic benchmark support, fixes #100, fixes #112 (by @AndreyAkinshin ) c28056 Support Mono+.NET4.6 in CommonExtensions.ToStr. (by @AndreyAkinshin ) 285f77 set dependencies to MSBuild dlls as \"type\": \"build\" to make them implicit dep... (by @adamsitnik ) 42abd1 Merge remote-tracking branch 'refs/remotes/origin/develop' into develop (by @mattwarren ) 030d6c Rename \"GCDiagnoser\" -> \"MemoryDiagnoser\" (by @mattwarren ) 4e96e6 give compilation error instead of warning or exception at runtime (by @adamsitnik ) 0fbe10 Revert \"give compilation error instead of warning or exception at runtime\" (by @adamsitnik ) 19708a Tidy up of the Integration tests (by @mattwarren ) f7b3a4 Thread safe jobs, fixes #171 (by @AndreyAkinshin ) edf293 DisableTestParallelization for Classic integration tests to avoid races (by @adamsitnik ) 89165f moving dll that is required for custom path integration tests out of root folder (by @adamsitnik ) cbaa3b README: Add additional info about RPlotExprter (by @AndreyAkinshin ) 1cc936 The benchmark is improperly testing the Max operation because as all the numb... (by @redknightlois ) 40a1ea Merge pull request #173 from redknightlois/develop (by @AndreyAkinshin ) a9bf3b README: add information about the diagnostics package (by @AndreyAkinshin ) 5191bc Set library version: 0.9.6 (by @AndreyAkinshin ) Contributors (5) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Federico Andres Lois ( @redknightlois ) ig-sinicyn ( @ig-sinicyn ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Milestone: v0.9.6 Date: May 11, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.6 https://www.nuget.org/packages/BenchmarkDotNet/0.9.6-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.6"
  },
  "changelog/v0.9.7.html": {
    "href": "changelog/v0.9.7.html",
    "title": "BenchmarkDotNet v0.9.7 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.7 .NET Core RC2 support (see #187 ) Bugfixes Milestone details In the v0.9.7 scope, 8 issues were resolved and 0 pull requests were merged. This release includes 27 commits by 3 contributors. Resolved issues (8) #168 Unable to run tests locally #170 Error handling in the spawned Benchmark process (assignee: @mattwarren ) #172 Ensure CsvMeasurementsExporter is enabled when RPlotExporter is used (assignee: @mattwarren ) #179 Job.GetAllProperties(): old property names are used #181 CompositeValidator: some validators will be skipped #183 [Suggestion] Make ValidationError public #187 .NET Core RC2 (assignee: @adamsitnik ) #192 Avoid creating .cs files at execution time Merged pull requests (0) Commits (27) 7568c0 Initial work on #130 (currently just matching existing behaviour) (by @mattwarren ) 34965e Fixes #170 (by @mattwarren ) 4d6d32 Remove \"@\" from the ProcessorName (by @AndreyAkinshin ) 57b402 Specify HintPath for all referenced assemblies (for mono support) (by @AndreyAkinshin ) 0d065b Merge branch 'develop' of github.com:PerfDotNet/BenchmarkDotNet into develop (by @mattwarren ) c24a9c Less \"magic\" strings - Fixes #179 (by @mattwarren ) 1371ea Allow Exporters to have dependencies, fixes #172 (by @mattwarren ) d6a55c Further work on #130 (by @mattwarren ) e0ebd4 Tidy up of the Json exporter code (part of #189) (by @mattwarren ) ae330c Allow formatted/indented Json (see #189) (by @mattwarren ) 83fd20 Also allow args with \"--\", i.e. --exporters=json (see #189) (by @mattwarren ) 78af45 File missing from previous check-in \"ae330c4\" (#189) (by @mattwarren ) 9352d0 \"Measurments\" -> \"Measurements\" (by @mattwarren ) a34507 .NET Core RC2 support, fixes #187 (by @adamsitnik ) 0c9524 remove IValidationError interface, make the implementation public, fixes #183 (by @adamsitnik ) 30a6ec Avoid creating .cs files at execution time, fixes #192 (by @adamsitnik ) 792176 hiding CompositeValidator, fix few typos, fixes #181 (by @adamsitnik ) a345e7 Use short, hard coded name for folders to avoid PathTooLongEx if user does no... (by @adamsitnik ) 354b28 minor cleanup after moving to RC2 (by @adamsitnik ) 53b7ff dotnet cli bug workaround, Tornhoof's idea (by @adamsitnik ) 8e6d30 added missing Nuget feeds to NuGet.Config, removed launchSettings which we do... (by @adamsitnik ) 9addd0 Improvements in MethodInvoker (by @AndreyAkinshin ) ccd91d Update Chronometer.HardwareTimerKind (by @AndreyAkinshin ) e9db3d Update year in LICENSE.md (by @AndreyAkinshin ) acd019 updated docs for .NET Core RC2 #187 (by @adamsitnik ) 605aa1 README.md: add a link to BenchmarkDotNet.Diagnostics.Windows (by @AndreyAkinshin ) 571b3d Set library version: 0.9.7 (by @AndreyAkinshin ) Contributors (3) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Matt Warren ( @mattwarren ) Thank you very much! Additional details Milestone: v0.9.7 Date: May 29, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.7 https://www.nuget.org/packages/BenchmarkDotNet/0.9.7-beta https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.7"
  },
  "changelog/v0.9.8.html": {
    "href": "changelog/v0.9.8.html",
    "title": "BenchmarkDotNet v0.9.8 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.8 CoreCLR RTM support (see #216 ). Breaking change: we have dropped dnx451 and dnxcore50 support. Migration from MSBuild to Roslyn, which supports Mono on Linux and MacOS (see #149 ). Breaking change: we have dropped .NET 4.0 support. Ability to manage GC mode: turn on/off the Server/Concurrent GC modes, extend to CPU groups, set gcAllowVeryLargeObjects and avoid BenchmarkDotNet from forcing GC.Collect (see #188 , #76 and #211 ) Support CopyToOutput (see #212 ). Now you can use native dependencies as well as custom files. Copying custom settings from app.config (see #108 ). It means we support assembly binding redirects as well as custom connection strings etc. AsciiDocExporter (see #169 ) Framework setting in Job has been removed (see #194 ) Minor bugfixes and improvements Milestone details In the v0.9.8 scope, 21 issues were resolved and 1 pull requests were merged. This release includes 69 commits by 5 contributors. Resolved issues (21) #57 Make Benchmark, Setup and Params attribute sealed in explicit way #76 Allow users to set gcAllowVeryLargeObjects for Runtime Settings (assignee: @AndreyAkinshin ) #77 Implement a C.I build (assignee: @mattwarren ) #108 Copy custom setting from app.config #131 [Mono] BenchmarkDotNet doesn't work on Mac OS #149 Migrate from MSBuild to Roslyn #174 NRE in Summary indexer property. #176 Split and simplify printed summaries #188 Ability to manage GC mode: turn on/off the Server/Concurrent GC modes and extend to CPU groups #191 MSBuild dependency - best way of fixing? #194 Framework settings in Jobs (assignee: @mattwarren ) #196 Allow specifying a gist url to RunUrl #197 Regression in 0.9.7: --help option fails under dotnet run #203 Third-party libraries must be explicitly included in test context to be loaded by runner #209 Fix appveyor bug #211 Possibility to turn off GC.Collect after each benchmark run (assignee: @adamsitnik ) #212 Support CopyToOutput #214 Benchmark ignores binding redirects #216 Update to .NET Core RTM (assignee: @adamsitnik ) #218 Errors in BenchmarkDotNet.Samples.FSharp.Core/projects.json #222 A problem with System.Threading.Tasks Merged pull requests (1) #169 Support export to asciidoc (by @russcam ) Commits (69) fcf48e Support export to asciidoc (by @russcam ) 590a0a Road to Roslyn: first attempt (by @AndreyAkinshin ) 704605 Added appveyor ci build (by @gigi81 ) 3859a1 Catch exception when accessing Console.WindowWidth, fixes #197 (by @mattwarren ) 7b92eb Filter tests by attribute (see #130) (by @mattwarren ) dd3464 Merge pull request #202 from gigi81/appveyor-build-2 (by @adamsitnik ) 29d106 Added missing 'build dependency' (by @gigi81 ) 2e8209 Merge pull request #205 from gigi81/fix-missing-dependency (by @AndreyAkinshin ) ff298d Appveyor build improvements (by @gigi81 ) 600cdd Merge pull request #206 from gigi81/appveyor-4 (by @AndreyAkinshin ) 68b070 Fixed tests not using OutputLogger (by @gigi81 ) 7d0501 Renamed _output to output (by @gigi81 ) ae5eab Merge pull request #207 from gigi81/fix-outputlogger (by @AndreyAkinshin ) dfe110 Small cleanup: remove compilation warnings (by @AndreyAkinshin ) ffe9f7 Clean up, part 2 (by @AndreyAkinshin ) 559f20 appveyor specific test fixes (by @AndreyAkinshin ) 38af24 MemoryDiagnoserTests: double.Parse Culture fix (by @AndreyAkinshin ) 02048d StatResultExtenderTests: SpeedUp (by @AndreyAkinshin ) f2b21f Clean up, part 3 (by @AndreyAkinshin ) d32328 SpeedUp: BaselineScaledColumnsTest, StatResultExtenderTests (by @AndreyAkinshin ) 5e37fa MemoryDiagnoserTests: additional parsing fixes (by @AndreyAkinshin ) 45c66f Merge branch 'develop' into Roslyn (by @adamsitnik ) a4cb8c MemoryDiagnoserTests: Temporarily suppressed (by @AndreyAkinshin ) ae38a5 README: add the appveyor badge (by @AndreyAkinshin ) 77bd64 README: update badges (by @AndreyAkinshin ) a74f82 README: update badges, part 2 (by @AndreyAkinshin ) 453a49 merging recent changes from develop with Roslyn branch to get it working again (by @adamsitnik ) ce4af5 add dependencies in recursive way, fixes #203 (by @adamsitnik ) a36af4 farewell MSBuid (by @adamsitnik ) d2dd83 Workaround for xunit bug (by @gigi81 ) 46f2b7 Merge pull request #210 from gigi81/xunit-workaround-2 (by @AndreyAkinshin ) c5b4ae Merge remote-tracking branch 'refs/remotes/origin/develop' into Roslyn (by @AndreyAkinshin ) 54109b copy custom settings from app.config file, fixes #108 (by @adamsitnik ) 20c41f enable GC settings customization, fixes #188 (by @adamsitnik ) dd0bc4 tests fix ;) (by @adamsitnik ) 0726b5 Possibility to turn off GC.Collect after each benchmark run, fixes #211 (by @adamsitnik ) da24b4 rename GC to GarbageCollection to avoid conflicts with System.GC (by @adamsitnik ) 3bf420 gcAllowVeryLargeObjects, fixes #76 (by @adamsitnik ) bdce98 split EnvironmentInfo into Host and Benchmark specific, make expensive method... (by @adamsitnik ) e819c8 added GC info to BenchmarkEnvironmentInfo (by @adamsitnik ) 9e0480 change GC settings display order (Workstation Concurrent => Concurrent Workst... (by @adamsitnik ) d03d17 support CopyToOutput: build in output directory + some refacotring, fixes #212 (by @adamsitnik ) 237370 minor bug fix: support spaces in parameters representation (by @adamsitnik ) 06349a Update to .NET Core RTM, drop DNX* support, fixes #216 (by @adamsitnik ) 106477 Merge branch 'develop' of https://github.com/russcam/BenchmarkDotNet into rus... (by @AndreyAkinshin ) 2e18db Merge branch 'russcam-develop' into develop (by @AndreyAkinshin ) 388155 Fix a NRE bug in Summary indexer, fixes #174 (by @AndreyAkinshin ) d448b4 Now RunUrl can work with non-raw github and gist urls, fixes #196 (by @AndreyAkinshin ) 7e1b95 Welch's Two Sample t-test (by @AndreyAkinshin ) cc70cb specify version of F# compiler in explicit way to workaround nuget bug, fixes... (by @adamsitnik ) e21373 use Roslyn's managed API for compilation, drop .NET 4.0 support!! fixes #149 (by @adamsitnik ) cd25cc use single reflection api after update to .NET 4.5 (by @adamsitnik ) 785d92 make Benchmark, Setup and Params Attribute sealed #57 (by @adamsitnik ) 8a3212 hopefully a workaround for appveyor build (by @adamsitnik ) ef7e35 hopefully a workaround for appveyor build, which does not have the latest dot... (by @adamsitnik ) 918a6d Remove xmlns for packages.config in IntegrationTests.Classic (by @AndreyAkinshin ) b897ed Merge branch 'Roslyn' into develop (by @adamsitnik ) 742a16 skip test that fails for Core on appveyor, #221 (by @adamsitnik ) a94a8b skip test that fails for Classic on appveyor, #221 (by @adamsitnik ) fec206 Fix incorrect xml-docs in MathHelper (by @AndreyAkinshin ) 1567d9 DEVELOPING.md: add a section about develop NuGet feed (by @AndreyAkinshin ) 5c3c31 appveyor: add BenchmarkDotNet.Diagnostics.Windows.nupkg to artifacts (by @AndreyAkinshin ) a69188 DEVELOPING.md: fix a typo (by @AndreyAkinshin ) 4e99b4 project.json: add tags (by @AndreyAkinshin ) 61b4c1 use System.Threading.Tasks as nuget package to fix nuget installation problem... (by @adamsitnik ) 976118 remove Framework settings from Jobs, fixes #194 (by @adamsitnik ) be0b71 try to remove the directory few more times when it's still not released to ma... (by @adamsitnik ) 0647a0 use the Configuration from the hosting process, not BDN dll (by @adamsitnik ) c6405a Set library version: 0.9.8 (by @AndreyAkinshin ) Contributors (5) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Luigi Grilli ( @gigi81 ) Matt Warren ( @mattwarren ) Russ Cam ( @russcam ) Thank you very much! Additional details Milestone: v0.9.8 Date: July 07, 2016 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.8 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.8"
  },
  "changelog/v0.9.9.html": {
    "href": "changelog/v0.9.9.html",
    "title": "BenchmarkDotNet v0.9.9 | BenchmarkDotNet",
    "keywords": "BenchmarkDotNet v0.9.9 Attribute config style (see #166 ) Online documentation (see #219 ) Mono LLVM support (see #226 ) Async method support (see #236 ) NuGet packages and repo layout restructuring (see #225 , #228 ) [Cleanup] attribute (see #215 ) New statistics columns: Skewness , Kurtosis , WelchTTestPValue , Improved math for the Scaled column Now current default branch is master Minor improvements and bug fixes Milestone details In the v0.9.9 scope, 14 issues were resolved and 1 pull requests were merged. This release includes 46 commits by 4 contributors. Resolved issues (14) #166 Suggestion: Attribute Config style (assignee: @AndreyAkinshin ) #215 Allow a [Cleanup] method to be specified #219 Online documentation and API reference #223 Add support for System.Type in Params #224 [Breaking change] BenchmarkAttribute become sealed. #225 Refactoring the roslyn dependency into another package #226 Support Mono/LLVM as a runtime/jit #227 Suggestion: change default branch (assignee: @AndreyAkinshin ) #228 Suggestion: clean up the root folder #231 Add references to default framework assemblies (System.Runtime etc) #232 Make all tests use OutputLogger (assignee: @adamsitnik ) #235 Don't show non-error output of dotnet cli (assignee: @adamsitnik ) #236 Possibility to benchmark asynchronous methods (assignee: @adamsitnik ) #240 Total Time reports hour rounded up Merged pull requests (1) #233 Add support of Cleanup attribute #215 (by @DenisIstomin ) Commits (46) f9f748 Improved \"Scaled\" column (by @AndreyAkinshin ) 5d7ba9 Warmup improvements (by @AndreyAkinshin ) 664c64 Add Skewness, Kurtosis, and WelchTTestPValue columns and configs (by @AndreyAkinshin ) c9e802 Attribute Config style, fixes #166 (by @AndreyAkinshin ) 378173 README: add supported OS (by @AndreyAkinshin ) 50ac57 Make Benchmark, Params and Setup attributes non-sealed again, fixes #224, #57 (by @adamsitnik ) b9c815 Support Mono/LLVM as a runtime/jit, fixes #226 (by @adamsitnik ) cdfbd5 Update info about default branch, see #227 (by @AndreyAkinshin ) 42e9b9 Add System.Type support in Params, fixes #223 (by @AndreyAkinshin ) db3dc3 Suggestion: clean up the root folder, fixes #228 (by @adamsitnik ) 4e1db3 use shorter names for test for xunit test runner (method name instead of full... (by @adamsitnik ) a35b22 make sure all framework assemblies are referenced, #231 (by @adamsitnik ) 19426a spliting BenchmarkDotNet.dll to few dlls to avoid mandatory Roslyn dependency... (by @adamsitnik ) 356a39 move BenchmarkRunner's core to separate class to .Core project so it can be ... (by @adamsitnik ) 0121a6 minor cleanup: rename LLVM => Llvm, remove [Obsolete] things (by @adamsitnik ) fb8047 Make all tests use OutputLogger, fixes #232 (by @adamsitnik ) ae17a7 Add support of Cleanup attribute, fix #215 (by @DenisIstomin ) 3bf9c0 Merge branch 'master' of https://github.com/PerfDotNet/BenchmarkDotNet (by @adamsitnik ) 355c6f Don't show non-error output of dotnet cli, fixes #235 (by @adamsitnik ) 76df80 Possibility to benchmark asynchronous methods #236 (by @adamsitnik ) 3ab578 use GetAwaiter().GetResult() for Tasks instead of .Wait or .Result, #236 (by @adamsitnik ) d1db7d Added documentation source and output based on readme.md (by @FransBouma ) ac8cf2 Updated folder structure, removed html output, updated gitignore (by @FransBouma ) bed0f9 Removed unused folder copy directive from docnet.json (by @FransBouma ) 650fca Merge pull request #239 from FransBouma/master (by @AndreyAkinshin ) aceb96 Added Api docs generation directives (by @FransBouma ) a9ee7c Fix in total time formatting, fix #240 (by @AndreyAkinshin ) 1d2141 Update README.md (by @AndreyAkinshin ) 7b9fdb Fixed a couple of issues with api doc generation (by @FransBouma ) 682837 Merge pull request #243 from FransBouma/master (by @AndreyAkinshin ) 9a2cf2 docs improvements (by @AndreyAkinshin ) 334925 Rename: GarbageCollection -> GcMode (by @AndreyAkinshin ) 7a740a SummaryTableTests and minor refactorings (by @AndreyAkinshin ) c9d358 Transform GcModeColumn with null values to a trivial column (by @AndreyAkinshin ) cb6359 Improved HardwareTimerKind detection (by @AndreyAkinshin ) 04f736 Fix references in the IntegrationTests project files (by @AndreyAkinshin ) a9403a Fix warnings (by @AndreyAkinshin ) 691a05 BenchmarkDotNet.Tests: Remove the System.Globalization dependency (by @AndreyAkinshin ) 9e97d7 Show JitModules in EnvInfo only for the classic toolchain (by @AndreyAkinshin ) 823518 Improved docs (by @AndreyAkinshin ) 5fb854 Update README (by @AndreyAkinshin ) 5ebf8b Minor fixes (by @AndreyAkinshin ) 086dfd generic wrapper for config values (by @adamsitnik ) cf58b0 Merge branch 'gc' (by @adamsitnik ) bbccbe docs: add informations about NuGet packages (by @AndreyAkinshin ) 60bea3 Set library version: 0.9.9 (by @AndreyAkinshin ) Contributors (4) Adam Sitnik ( @adamsitnik ) Andrey Akinshin ( @AndreyAkinshin ) Denis Istomin ( @DenisIstomin ) Frans Bouma ( @FransBouma ) Thank you very much! Additional details Date: August 18, 2016 Milestone: v0.9.9 NuGet Packages: https://www.nuget.org/packages/BenchmarkDotNet/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Core/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Toolchains.Roslyn/0.9.9 https://www.nuget.org/packages/BenchmarkDotNet.Diagnostics.Windows/0.9.9 Online Documentation: https://perfdotnet.github.io/BenchmarkDotNet/"
  },
  "index.html": {
    "href": "index.html",
    "title": "| BenchmarkDotNet",
    "keywords": "Features · Getting started · Documentation · Learn more about benchmarking BenchmarkDotNet helps you to transform methods into benchmarks, track their performance, and share reproducible measurement experiments. It's no harder than writing unit tests! Under the hood, it performs a lot of magic that guarantees reliable and precise results thanks to the perfolizer statistical engine. BenchmarkDotNet protects you from popular benchmarking mistakes and warns you if something is wrong with your benchmark design or obtained measurements. The results are presented in a user-friendly form that highlights all the important facts about your experiment. The library is adopted by 6800+ projects including .NET Runtime and supported by the .NET Foundation . It's easy to start writing benchmarks, check out an example (copy-pastable version is here ): [SimpleJob(RuntimeMoniker.Net472, baseline: true)] [SimpleJob(RuntimeMoniker.NetCoreApp30)] [SimpleJob(RuntimeMoniker.CoreRt30)] [SimpleJob(RuntimeMoniker.Mono)] [RPlotExporter] public class Md5VsSha256 { private SHA256 sha256 = SHA256.Create(); private MD5 md5 = MD5.Create(); private byte[] data; [Params(1000, 10000)] public int N; [GlobalSetup] public void Setup() { data = new byte[N]; new Random(42).NextBytes(data); } [Benchmark] public byte[] Sha256() => sha256.ComputeHash(data); [Benchmark] public byte[] Md5() => md5.ComputeHash(data); } BenchmarkDotNet automatically runs the benchmarks on all the runtimes, aggregates the measurements, and prints a summary table with the most important information: BenchmarkDotNet=v0.12.0, OS=Windows 10.0.17763.805 (1809/October2018Update/Redstone5) Intel Core i7-7700K CPU 4.20GHz (Kaby Lake), 1 CPU, 8 logical and 4 physical cores [Host] : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT Net472 : .NET Framework 4.7.2 (4.7.3468.0), X64 RyuJIT NetCoreApp30 : .NET Core 3.0.0 (CoreCLR 4.700.19.46205, CoreFX 4.700.19.46214), X64 RyuJIT CoreRt30 : .NET CoreRT 1.0.28231.02 @Commit: 741d61493c560ba96e8151f9e56876d4d3828489, X64 AOT Mono : Mono 6.4.0 (Visual Studio), X64 | Method | Runtime | N | Mean | Error | StdDev | Ratio | |------- |-------------- |------ |-----------:|----------:|----------:|------:| | Sha256 | .NET 4.7.2 | 1000 | 7.735 us | 0.1913 us | 0.4034 us | 1.00 | | Sha256 | .NET Core 3.0 | 1000 | 3.989 us | 0.0796 us | 0.0745 us | 0.50 | | Sha256 | CoreRt 3.0 | 1000 | 4.091 us | 0.0811 us | 0.1562 us | 0.53 | | Sha256 | Mono | 1000 | 13.117 us | 0.2485 us | 0.5019 us | 1.70 | | | | | | | | | | Md5 | .NET 4.7.2 | 1000 | 2.872 us | 0.0552 us | 0.0737 us | 1.00 | | Md5 | .NET Core 3.0 | 1000 | 1.848 us | 0.0348 us | 0.0326 us | 0.64 | | Md5 | CoreRt 3.0 | 1000 | 1.817 us | 0.0359 us | 0.0427 us | 0.63 | | Md5 | Mono | 1000 | 3.574 us | 0.0678 us | 0.0753 us | 1.24 | | | | | | | | | | Sha256 | .NET 4.7.2 | 10000 | 74.509 us | 1.5787 us | 4.6052 us | 1.00 | | Sha256 | .NET Core 3.0 | 10000 | 36.049 us | 0.7151 us | 1.0025 us | 0.49 | | Sha256 | CoreRt 3.0 | 10000 | 36.253 us | 0.7076 us | 0.7571 us | 0.49 | | Sha256 | Mono | 10000 | 116.350 us | 2.2555 us | 3.0110 us | 1.58 | | | | | | | | | | Md5 | .NET 4.7.2 | 10000 | 17.308 us | 0.3361 us | 0.4250 us | 1.00 | | Md5 | .NET Core 3.0 | 10000 | 15.726 us | 0.2064 us | 0.1930 us | 0.90 | | Md5 | CoreRt 3.0 | 10000 | 15.627 us | 0.2631 us | 0.2461 us | 0.89 | | Md5 | Mono | 10000 | 30.205 us | 0.5868 us | 0.6522 us | 1.74 | The measured data can be exported to different formats (md, html, csv, xml, json, etc.) including plots: Supported runtimes: .NET 5+, .NET Framework 4.6.1+, .NET Core 2.0+, Mono, CoreRT Supported languages: C#, F#, Visual Basic Supported OS: Windows, Linux, macOS Supported architectures: x86, x64, ARM, ARM64 and Wasm Features BenchmarkDotNet has tons of features that are essential in comprehensive performance investigations. Four aspects define the design of these features: simplicity , automation , reliability , and friendliness . Simplicity You shouldn't be an experience performance engineer if you want to write benchmarks. You can design very complicated performance experiments in the declarative style using simple APIs. For example, if you want to parameterize your benchmark, mark a field or a property with [Params(1, 2, 3)] : BenchmarkDotNet will enumerate all of the specified values and run benchmarks for each case. If you want to compare benchmarks with each other, mark one of the benchmark as the baseline via [Benchmark(baseline: true)] : BenchmarkDotNet will compare it with all of the other benchmarks. If you want to compare performance in different environments, use jobs . For example, you can run all the benchmarks on .NET Core 3.0 and Mono via [SimpleJob(RuntimeMoniker.NetCoreApp30)] and [SimpleJob(RuntimeMoniker.Mono)] . If you don't like attributes, you can call most of the APIs via the fluent style and write code like this: ManualConfig.CreateEmpty() // A configuration for our benchmarks .With(Job.Default // Adding first job .With(ClrRuntime.Net472) // .NET Framework 4.7.2 .With(Platform.X64) // Run as x64 application .With(Jit.LegacyJit) // Use LegacyJIT instead of the default RyuJIT .WithGcServer(true) // Use Server GC ).With(Job.Default // Adding second job .AsBaseline() // It will be marked as baseline .WithEnvironmentVariable(\"Key\", \"Value\") // Setting an environment variable .WithWarmupCount(0) // Disable warm-up stage ); If you prefer command-line experience, you can configure your benchmarks via the console arguments in any console application (other types of applications are not supported). Automation Reliable benchmarks always include a lot of boilerplate code. Let's think about what should you do in a typical case. First, you should perform a pilot experiment and determine the best number of method invocations. Next, you should execute several warm-up iterations and ensure that your benchmark achieved a steady state. After that, you should execute the main iterations and calculate some basic statistics. If you calculate some values in your benchmark, you should use it somehow to prevent the dead code elimination. If you use loops, you should care about an effect of the loop unrolling on your results (which may depend on the processor architecture). Once you get results, you should check for some special properties of the obtained performance distribution like multimodality or extremely high outliers. You should also evaluate the overhead of your infrastructure and deduct it from your results. If you want to test several environments, you should perform the measurements in each of them and manually aggregate the results. If you write this code from scratch, it's easy to make a mistake and spoil your measurements. Note that it's a shortened version of the full checklist that you should follow during benchmarking: there are a lot of additional hidden pitfalls that should be handled appropriately. Fortunately, you shouldn't worry about it because BenchmarkDotNet will do this boring and time-consuming stuff for you. Moreover, the library can help you with some advanced tasks that you may want to perform during the investigation. For example, BenchmarkDotNet can measure the managed and native memory traffic and print disassembly listings for your benchmarks. Reliability A lot of hand-written benchmarks produce wrong numbers that lead to incorrect business decisions. BenchmarkDotNet protects you from most of the benchmarking pitfalls and allows achieving high measurement precision. You shouldn't worry about the perfect number of method invocation, the number of warm-up and actual iterations: BenchmarkDotNet tries to choose the best benchmarking parameters and achieve a good trade-off between the measurement prevision and the total duration of all benchmark runs. So, you shouldn't use any magic numbers (like \"We should perform 100 iterations here\"), the library will do it for you based on the values of statistical metrics. BenchmarkDotNet also prevents benchmarking of non-optimized assemblies that was built using DEBUG mode because the corresponding results will be unreliable. It will print a warning you if you have an attached debugger, if you use hypervisor (HyperV, VMware, VirtualBox), or if you have any other problems with the current environment. During 6+ years of development, we faced dozens of different problems that may spoil your measurements. Inside BenchmarkDotNet, there are a lot of heuristics, checks, hacks, and tricks that help you to increase the reliability of the results. Friendliness Analysis of performance data is a time-consuming activity that requires attentiveness, knowledge, and experience. BenchmarkDotNet performs the main part of this analysis for you and presents results in a user-friendly form. After the experiments, you get a summary table that contains a lot of useful data about the executed benchmarks. By default, it includes only the most important columns, but they can be easily customized . The column set is adaptive and depends on the benchmark definition and measured values. For example, if you mark one of the benchmarks as a baseline , you will get additional columns that will help you to compare all the benchmarks with the baseline. By default, it always shows the Mean column, but if we detected a vast difference between the Mean and the Median values, both columns will be presented. BenchmarkDotNet tries to find some unusual properties of your performance distributions and prints nice messages about it. For example, it will warn you in case of multimodal distribution or high outliers. In this case, you can scroll the results up and check out ASCII-style histograms for each distribution or generate beautiful png plots using [RPlotExporter] . BenchmarkDotNet doesn't overload you with data; it shows only the essential information depending on your results: it allows you to keep summary small for primitive cases and extend it only for the complicated cases. Of course, you can request any additional statistics and visualizations manually. If you don't customize the summary view, the default presentation will be as much user-friendly as possible. :) Who uses BenchmarkDotNet? Everyone! BenchmarkDotNet is already adopted by more than 6800+ projects including dotnet/performance (reference benchmarks for all .NET Runtimes), dotnet/runtime (.NET Core runtime and libraries), Roslyn (C# and Visual Basic compiler), Mono , ASP.NET Core , ML.NET , Entity Framework Core , PowerShell SignalR , F# , Orleans , Newtonsoft.Json , Elasticsearch.Net , Dapper , Expecto , ImageSharp , RavenDB , NodaTime , Jint , NServiceBus , Serilog , Autofac , Npgsql , Avalonia , ReactiveUI , SharpZipLib , LiteDB , GraphQL for .NET , .NET Docs , RestSharp , MediatR , TensorFlow.NET , Apache Thrift . On GitHub, you can find 4500+ issues , 2500+ commits , and 500,000+ files that involve BenchmarkDotNet. Learn more about benchmarking BenchmarkDotNet is not a silver bullet that magically makes all of your benchmarks correct and analyzes the measurements for you. Even if you use this library, you still should know how to design the benchmark experiments and how to make correct conclusions based on the raw data. If you want to know more about benchmarking methodology and good practices, it's recommended to read a book by Andrey Akinshin (the BenchmarkDotNet project lead): \"Pro .NET Benchmarking\" . Use this in-depth guide to correctly design benchmarks, measure key performance metrics of .NET applications, and analyze results. This book presents dozens of case studies to help you understand complicated benchmarking topics. You will avoid common pitfalls, control the accuracy of your measurements, and improve the performance of your software. Build status Build server Platform Build status Azure Pipelines Windows Azure Pipelines Ubuntu Azure Pipelines macOS AppVeyor Windows Travis Linux Travis macOS Contributions are welcome! BenchmarkDotNet is already a stable full-featured library that allows performing performance investigation on a professional level. And it continues to evolve! We add new features all the time, but we have too many new cool ideas. Any help will be appreciated. You can develop new features, fix bugs, improve the documentation, or do some other cool stuff. If you want to contribute, check out the Contributing guide and up-for-grabs issues. If you have new ideas or want to complain about bugs, feel free to create a new issue . Let's build the best tool for benchmarking together! Code of Conduct This project has adopted the code of conduct defined by the Contributor Covenant to clarify expected behavior in our community. For more information, see the .NET Foundation Code of Conduct ."
  }
}