using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;
using System.Linq;
using System.Text;

namespace BenchmarkDotNet.SourceGenerators
{
    [Generator]
    public class BenchmarkGenerator : ISourceGenerator
    {
        public void Initialize(GeneratorInitializationContext context)
        {
            // TODO: Register the Runner source
            //context.RegisterForPostInitialization((i) => i.AddSource("AutoNotifyAttribute", attributeText));

            // Register a syntax receiver that will be created for each generation pass
            context.RegisterForSyntaxNotifications(() => new BenchmarkSyntaxReceiver());
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is BenchmarkSyntaxReceiver receiver) || !receiver.HasFound)
            {
                return;
            }

            foreach (var group in receiver.AllSymbols().GroupBy(symbol => symbol.ContainingType, SymbolEqualityComparer.Default))
            {
                string classSource = GenerateClassSource((INamedTypeSymbol)group.Key, group.ToArray());
                context.AddSource($"{group.Key.Name}_BDN.cs", SourceText.From(classSource, Encoding.UTF8));
            }
        }

        private string GenerateClassSource(INamedTypeSymbol classSymbol, ISymbol[] symbols)
        {
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // begin building the generated source
            StringBuilder source = new StringBuilder($@"
namespace {namespaceName}
{{
    public class {classSymbol.Name}_Autogenerated : {classSymbol.Name}
    {{
    }}
}}
");
            return source.ToString();
        }
    }
}
