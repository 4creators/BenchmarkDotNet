using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Xml;
using BenchmarkDotNet.Extensions;
using BenchmarkDotNet.Jobs;
using BenchmarkDotNet.Loggers;
using BenchmarkDotNet.Running;
using BenchmarkDotNet.Toolchains.DotNetCli;
using JetBrains.Annotations;

namespace BenchmarkDotNet.Toolchains.CsProj
{
    [PublicAPI]
    public class RewriteGenerator : DotNetCliGenerator
    {
        private static readonly ImmutableHashSet<string> PropertiesToRemove =
            new HashSet<string>(
                new string[]
                {
                    "TargetFrameworks", "TargetFramework",
                    "AssemblyTitle", "AssemblyName", "PackageId",
                    "OutputType",
                    "PlatformTarget",
                    "TreatWarningsAsErrors",
                    "CodeAnalysisRuleSet",
                    "Deterministic",
                    "Optimize",
                })
            .ToImmutableHashSet();

        private static readonly ImmutableHashSet<string> ItemsToRemove =
            new HashSet<string>(
                new string[]
                {
                    "Compile"
                })
            .ToImmutableHashSet();

        public string RuntimeFrameworkVersion { get; }

        public RewriteGenerator(string targetFrameworkMoniker, string cliPath, string packagesPath, string runtimeFrameworkVersion, bool isNetCore = true)
            : base(targetFrameworkMoniker, cliPath, packagesPath, isNetCore)
        {
            RuntimeFrameworkVersion = runtimeFrameworkVersion;
        }

        // we want to store the new auto-generated project file next to the one that defines benchmarks
        protected override string GetBuildArtifactsDirectoryPath(BuildPartition buildPartition, string programName)
            => GetProjectFilePath(buildPartition.RepresentativeBenchmarkCase.Descriptor.Type, buildPartition.RepresentativeBenchmarkCase.Config.GetCompositeLogger()).DirectoryName;

        // we use a file extension that does not end with "proj" to avoid the following error:
        // "Specify which project file to use because $FOLDER contains more than one project file."
        protected override string GetProjectFilePath(BuildPartition buildPartition, string buildArtifactsDirectoryPath)
            => Path.Combine(buildArtifactsDirectoryPath, $"BenchmarkDotNet.Autogenerated.{buildPartition.Index}.csprojnot");

        protected override string[] GetArtifactsToCleanup(ArtifactsPaths artifactsPaths) => new string[]
        {
            artifactsPaths.ProjectFilePath,
            artifactsPaths.BuildScriptFilePath,
            artifactsPaths.ProgramCodePath,
            artifactsPaths.AppConfigPath
        };

        protected override void GenerateProject(BuildPartition buildPartition, ArtifactsPaths artifactsPaths, ILogger logger)
        {
            var benchmark = buildPartition.RepresentativeBenchmarkCase;
            var projectFile = GetProjectFilePath(benchmark.Descriptor.Type, logger);

            using (var source = new StreamReader(File.OpenRead(projectFile.FullName)))
            using (var destination = new StreamWriter(File.OpenWrite(artifactsPaths.ProjectFilePath)))
            {
                GenerateProjectFile(source, destination, buildPartition, artifactsPaths, projectFile.Name, TargetFrameworkMoniker, RuntimeFrameworkVersion);
            }
        }

        private FileInfo GetProjectFilePath(Type benchmarkTarget, ILogger logger)
        {
            if (!GetSolutionRootDirectory(out var rootDirectory) && !GetProjectRootDirectory(out rootDirectory))
            {
                logger.WriteLineError(
                    $"Unable to find .sln or .csproj file. Will use current directory {Directory.GetCurrentDirectory()} to search for project file. If you don't use .sln file on purpose it should not be a problem.");
                rootDirectory = new DirectoryInfo(Directory.GetCurrentDirectory());
            }

            // important assumption! project's file name === output dll name
            string projectName = benchmarkTarget.GetTypeInfo().Assembly.GetName().Name;

            // I was afraid of using .GetFiles with some smart search pattern due to the fact that the method was designed for Windows
            // and now .NET is cross platform so who knows if the pattern would be supported for other OSes
            var possibleNames = new HashSet<string> { $"{projectName}.csproj", $"{projectName}.fsproj", $"{projectName}.vbproj" };
            var projectFile = rootDirectory
                .EnumerateFiles("*.*", SearchOption.AllDirectories)
                .FirstOrDefault(file => possibleNames.Contains(file.Name));

            if (projectFile == default(FileInfo))
            {
                throw new NotSupportedException(
                    $"Unable to find {projectName} in {rootDirectory.FullName} and its subfolders. Most probably the name of output exe is different than the name of the .(cs/fs/vb)proj");
            }
            return projectFile;
        }

        internal static void GenerateProjectFile(TextReader source, TextWriter destination,
            BuildPartition buildPartition, ArtifactsPaths artifactsPaths,
            string projectToReference,
            string targetFrameworkMoniker, string runtimeFrameworkVersion)
        {
            using (var xmlReader = XmlReader.Create(source))
            {
                var xmlDocument = new XmlDocument();

                xmlDocument.Load(xmlReader);

                var projectElement = xmlDocument.SelectSingleNode("/Project");

                RemoveSettings(projectElement.SelectNodes("PropertyGroup"), PropertiesToRemove);
                RemoveSettings(projectElement.SelectNodes("ItemGroup"), ItemsToRemove);

                var newPropertyGroup = projectElement.AppendChild(xmlDocument.CreateNode(XmlNodeType.Element, "PropertyGroup", string.Empty));
                AddProperties(xmlDocument, newPropertyGroup, buildPartition, artifactsPaths, targetFrameworkMoniker, runtimeFrameworkVersion);

                var newItemGroup = projectElement.AppendChild(xmlDocument.CreateNode(XmlNodeType.Element, "ItemGroup", string.Empty));
                AddReferences(xmlDocument, newItemGroup, artifactsPaths, projectToReference);

                xmlDocument.Save(destination);
            }
        }

        private static void RemoveSettings(XmlNodeList nodes, ImmutableHashSet<string> settingsToRemove)
        {
            foreach (XmlNode node in nodes)
            {
                for (int i = node.ChildNodes.Count - 1; i >= 0 ; i--)
                {
                    if (settingsToRemove.Contains(node.ChildNodes[i].Name))
                    {
                        node.RemoveChild(node.ChildNodes[i]);
                    }
                }
            }
        }

        private static void AddProperties(XmlDocument xmlDocument, XmlNode propertyGroup, BuildPartition buildPartition, ArtifactsPaths artifactsPaths, string targetFrameworkMoniker, string runtimeFrameworkVersion)
        {
            AddProperty(xmlDocument, propertyGroup, "TargetFramework", targetFrameworkMoniker);
            AddProperty(xmlDocument, propertyGroup, "PlatformTarget", buildPartition.Platform.ToConfig());

            AddProperty(xmlDocument, propertyGroup, "AssemblyTitle", artifactsPaths.ProgramName);
            AddProperty(xmlDocument, propertyGroup, "AssemblyName", artifactsPaths.ProgramName);

            AddProperty(xmlDocument, propertyGroup, "OutputType", "Exe");
            AddProperty(xmlDocument, propertyGroup, "TreatWarningsAsErrors", "false"); // auto-generated boilerplate code might contain warnings
            AddProperty(xmlDocument, propertyGroup, "CodeAnalysisRuleSet", string.Empty); // auto-generated boilerplate code might not pass static code analysis
            AddProperty(xmlDocument, propertyGroup, "Deterministic", "true");
            AddProperty(xmlDocument, propertyGroup, "Optimize", "true"); // todo: add condition <Optimize Condition=" '$(Configuration)' != 'Debug' ">true</Optimize>
            AddProperty(xmlDocument, propertyGroup, "EnableDefaultItems", "false"); // we don't want all .cs files to be included by default
            AddProperty(xmlDocument, propertyGroup, "UseSharedCompilation", "false"); // no MSBuild zombie processes

            // we put the project file in the same folder as project with benchmarks to avoid the need of having to update relative file paths
            // but if there is more than known 1 project file in given folder, dotnet cli commands require to provide the path to it in explicit way
            // to avoid that, we don't call the project file `.csproj` but `.bdnproj` and use the following way to tell MSBuild that this IS a C# project file
            AddProperty(xmlDocument, propertyGroup, "LanguageTargets", @"$(MSBuildToolsPath)\Microsoft.CSharp.targets");

            if (!string.IsNullOrEmpty(runtimeFrameworkVersion))
            {
                AddProperty(xmlDocument, propertyGroup, nameof(RuntimeFrameworkVersion), runtimeFrameworkVersion);
            }

            var gcMode = buildPartition.RepresentativeBenchmarkCase.Job.Environment.Gc;
            if (gcMode.HasChanges)
            {
                var resolver = buildPartition.Resolver;
                AddProperty(xmlDocument, propertyGroup, "ServerGarbageCollection", gcMode.ResolveValue(GcMode.ServerCharacteristic, resolver).ToLowerCase());
                AddProperty(xmlDocument, propertyGroup, "ConcurrentGarbageCollection", gcMode.ResolveValue(GcMode.ConcurrentCharacteristic, resolver).ToLowerCase());
                AddProperty(xmlDocument, propertyGroup, "RetainVMGarbageCollection", gcMode.ResolveValue(GcMode.RetainVmCharacteristic, resolver).ToLowerCase());
            }
        }

        private static void AddReferences(XmlDocument xmlDocument, XmlNode itemGroup, ArtifactsPaths artifactsPaths, string projectToReference)
        {
            // everything is the same folder as generated project file so we just provide file names, not full file paths
            AddNodeWithAttribute(xmlDocument, itemGroup, "Compile", "Include", Path.GetFileName(artifactsPaths.ProgramCodePath));
            AddNodeWithAttribute(xmlDocument, itemGroup, "ProjectReference", "Include", projectToReference);
        }

        private static void AddProperty(XmlDocument xmlDocument, XmlNode propertyGroup, string name, string value)
        {
            var propertyNode = xmlDocument.CreateNode(XmlNodeType.Element, name, string.Empty);
            propertyNode.InnerText = value;
            propertyGroup.AppendChild(propertyNode);
        }

        private static void AddNodeWithAttribute(
            XmlDocument document,
            XmlNode parentNode,
            string nodeName,
            string attributeName,
            string attributeValue)
        {
            var node = document.CreateNode(XmlNodeType.Element, nodeName, string.Empty);
            var attribute = document.CreateAttribute(attributeName);
            attribute.Value = attributeValue;
            node.Attributes.SetNamedItem(attribute);

            parentNode.AppendChild(node);
        }
    }
}
