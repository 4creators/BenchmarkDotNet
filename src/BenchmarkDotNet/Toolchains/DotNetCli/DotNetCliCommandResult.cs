using System;
using System.IO;
using System.Linq;
using BenchmarkDotNet.Toolchains.Results;
using JetBrains.Annotations;

namespace BenchmarkDotNet.Toolchains.DotNetCli
{
    public struct DotNetCliCommandResult
    {
        [PublicAPI] public bool IsSuccess { get; }

        [PublicAPI] public TimeSpan ExecutionTime { get; }

        [PublicAPI] public string StandardOutput { get; }

        [PublicAPI] public string StandardError { get; }

        public string AllInformation => $"Standard output: {Environment.NewLine} {StandardOutput} {Environment.NewLine} Standard error: {Environment.NewLine} {StandardError}";

        [PublicAPI] public bool HasNonEmptyErrorMessage => !string.IsNullOrEmpty(StandardError);

        private DotNetCliCommandResult(bool isSuccess, TimeSpan executionTime, string standardOutput, string standardError)
        {
            IsSuccess = isSuccess;
            ExecutionTime = executionTime;
            StandardOutput = standardOutput;
            StandardError = standardError;
        }

        public static DotNetCliCommandResult Success(TimeSpan time, string standardOutput)
            => new DotNetCliCommandResult(true, time, standardOutput, string.Empty);

        public static DotNetCliCommandResult Failure(TimeSpan time, string standardError, string standardOutput)
            => new DotNetCliCommandResult(false, time, standardOutput, standardError);

        [PublicAPI]
        public BuildResult ToBuildResult(GenerateResult generateResult)
            => TryParseOutputExecutablePath(StandardOutput, Path.GetFileNameWithoutExtension(generateResult.ArtifactsPaths.ProjectFilePath), out string executablePath)
                ? BuildResult.Success(generateResult, executablePath)
                : BuildResult.Failure(generateResult, AllInformation);

        // the line that we are looking for is sth like this:
        // "  BenchmarkDotNet.Autogenerated.0 -> C:\Projects\BenchmarkDotNet\samples\BenchmarkDotNet.Samples\bin\Release\netcoreapp2.1\BenchmarkDotNet.Autogenerated.0.dll"
        private static bool TryParseOutputExecutablePath(string standardOutput, string projectName, out string executablePath)
        {
            using (var reader = new StringReader(standardOutput))
            {
                string line;
                while ((line = reader.ReadLine()) != null)
                {
                    if (!line.TrimStart().StartsWith(projectName))
                        continue;

                    string filePath = line.Split(new string[] { "->" }, StringSplitOptions.RemoveEmptyEntries).LastOrDefault();
                    if (!string.IsNullOrEmpty(filePath))
                    {
                        executablePath = filePath.Trim();
                        return File.Exists(executablePath);
                    }
                }
            }

            executablePath = null;
            return false;
        }
    }
}